<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[zookeeper 分布式锁]]></title>
      <url>http://zsr.github.io/2016/08/29/zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h3 id="可重入锁Shared-Reentrant-Lock"><a href="#可重入锁Shared-Reentrant-Lock" class="headerlink" title="可重入锁Shared Reentrant Lock"></a>可重入锁Shared Reentrant Lock</h3><p>Shared意味着锁是全局可见的， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类<code>InterProcessMutex</code>来实现。<br>它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></div></pre></td></tr></table></figure>
<p>通过<code>acquire</code>获得锁，并提供超时机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Acquire the mutex - blocking until it's available. Note: the same thread can call acquire</div><div class="line">* re-entrantly. Each call to acquire must be balanced by a call to release()</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Acquire the mutex - blocks until it's available or the given time expires. Note: the same </div><div class="line">* thread can call acquire re-entrantly. Each call to acquire that returns true must be </div><div class="line">* balanced by a call to release()</div><div class="line">* Parameters:</div><div class="line">* time - time to wait</div><div class="line">* unit - time unit</div><div class="line">* Returns:</div><div class="line">* true if the mutex was acquired, false if not</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time,</span></div><div class="line">                       TimeUnit unit)</div></pre></td></tr></table></figure>
<p>通过<code>release()</code>方法释放锁。InterProcessMutex 实例可以重用。</p>
<p><strong>Revoking</strong><br>ZooKeeper recipes wiki定义了可协商的撤销机制。<br>为了撤销mutex, 调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 将锁设为可撤销的. 当别的进程或线程想让你释放锁是Listener会被调用。</div><div class="line">* Parameters:</div><div class="line">* listener - the listener</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRevocable</span><span class="params">(RevocationListener&lt;T&gt; listener)</span></span></div></pre></td></tr></table></figure>
<p>如果请求撤销当前的锁， 调用<code>Revoker</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Utility to mark a lock for revocation. Assuming that the lock has been registered</div><div class="line">* with a RevocationListener, it will get called and the lock should be released. Note,</div><div class="line">* however, that revocation is cooperative.</div><div class="line">* Parameters:</div><div class="line">* client - the client</div><div class="line">* path - the path of the lock - usually from something like </div><div class="line">* InterProcessMutex.getParticipantNodes()</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRevoke</span><span class="params">(CuratorFramework client,</span></span></div><div class="line">                                 String path)</div><div class="line">                         <span class="keyword">throws</span> Exception</div></pre></td></tr></table></figure>
<p><strong>错误处理</strong><br>还是强烈推荐你使用<code>ConnectionStateListener</code>处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>首先创建一个模拟的共享资源， 这个资源期望只能单线程的访问，否则会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Simulates some external resource that can only be access by one process at a time</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></div><div class="line">    <span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></div><div class="line">	<span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></div><div class="line">    <span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Needs to be used by one client at a time"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      inUse.set(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后创建一个<code>ExampleClientThatLocks</code>类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientThatLocks</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex lock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClientThatLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource,</span></span></div><div class="line">      String clientName) &#123;</div><div class="line">    <span class="keyword">this</span>.resource = resource;</div><div class="line">    <span class="keyword">this</span>.clientName = clientName;</div><div class="line">    lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" has the lock"</span>);</div><div class="line">      resource.use();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">      lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后创建主程序来测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    ExecutorService service = Executors.newFixedThreadPool(QTY);</div><div class="line">    <span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">        Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              client.start();</div><div class="line">              <span class="keyword">final</span> ExampleClientThatLocks example = <span class="keyword">new</span> ExampleClientThatLocks(client, PATH, resource, <span class="string">"Client "</span> + index);</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</div><div class="line">                example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">              &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">              e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">              CloseableUtils.closeQuietly(client);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        service.submit(task);</div><div class="line">      &#125;</div><div class="line">      service.shutdown();</div><div class="line">      service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。每个client都在独立的线程中。结果可以看到，锁是随机的被每个实例排他性的使用。</p>
<p>既然是可重用的，可以在一个线程中多次调用<code>acquire</code>,在线程拥有锁时它总是返回true。</p>
<p>不应该在多个线程中用同一个InterProcessMutex， 你可以在每个线程中都生成一个InterProcessMutex实例，它们的path都一样，这样它们可以共享同一个锁。</p>
<h3 id="不可重入锁Shared-Lock"><a href="#不可重入锁Shared-Lock" class="headerlink" title="不可重入锁Shared Lock"></a>不可重入锁Shared Lock</h3><p>这个锁和上面的相比，就是少了<code>Reentrant</code>的功能，也就意味着它不能在同一个线程中重入。<br>这个类是<code>InterProcessSemaphoreMutex</code>。<br>使用方法和上面的类类似。</p>
<p>将上面的例子修改一下，测试一下它的重入。修改<code>ExampleClientThatLocks.doWork</code>,连续两次<code>acquire</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println(clientName + <span class="string">" has the lock"</span>);</div><div class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println(clientName + <span class="string">" has the lock again"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> &#123;			</div><div class="line">		resource.use(); <span class="comment">//access resource exclusively</span></div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong>我们也需要调用<code>release</code>两次。这和JDK的ReentrantLock用法一致。如果少调用一次<code>release</code>，则此线程依然拥有锁。<br>上面的代码没有问题，我们可以多次调用<code>acquire</code>，后续的<code>acquire</code>也不会阻塞。<br>将上面的<code>InterProcessMutex</code>换成不可重入锁<code>InterProcessSemaphoreMutex</code>,如果再运行上面的代码，结果就会发现线程被阻塞再第二个<code>acquire</code>上。 也就是此锁不是可重入的。</p>
<h3 id="可重入读写锁Shared-Reentrant-Read-Write-Lock"><a href="#可重入读写锁Shared-Reentrant-Read-Write-Lock" class="headerlink" title="可重入读写锁Shared Reentrant Read Write Lock"></a>可重入读写锁Shared Reentrant Read Write Lock</h3><p>类似JDK的<code>ReentrantReadWriteLock</code>.<br>一个读写锁管理一对相关的锁。 一个负责读操作，另外一个负责写操作。 读操作在写锁没被使用时可同时由多个进程使用，而写锁使用时不允许读 (阻塞)。<br>此锁是可重入的。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。<br>这也意味着写锁可以降级成读锁， 比如请求写锁 —&gt;读锁 —-&gt;释放写锁。 从读锁升级成写锁是不成的。</p>
<p>主要由两个类实现：</p>
<ul>
<li>InterProcessReadWriteLock</li>
<li>InterProcessLock</li>
</ul>
<p>使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁， 读写锁的类型是<code>InterProcessLock</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InterProcessLock <span class="title">readLock</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> InterProcessLock <span class="title">writeLock</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>例子和上面的类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientReadWriteLocks</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessReadWriteLock lock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readLock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeLock;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClientReadWriteLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource,</span></span></div><div class="line">      String clientName) &#123;</div><div class="line">    <span class="keyword">this</span>.resource = resource;</div><div class="line">    <span class="keyword">this</span>.clientName = clientName;</div><div class="line">    lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</div><div class="line">    readLock = lock.readLock();</div><div class="line">    writeLock = lock.writeLock();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!writeLock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the writeLock"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(clientName + <span class="string">" has the writeLock"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!readLock.acquire(time, unit)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the readLock"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(clientName + <span class="string">" has the readLock too"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      resource.use(); <span class="comment">// access resource exclusively</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(clientName + <span class="string">" releasing the lock"</span>);</div><div class="line">      readLock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">      writeLock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个类中我们首先请求了一个写锁， 然后降级成读锁。 执行业务处理，然后释放读写锁。</p>
<h3 id="信号量Shared-Semaphore"><a href="#信号量Shared-Semaphore" class="headerlink" title="信号量Shared Semaphore"></a>信号量Shared Semaphore</h3><p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(permits)，而Curator中称之为租约(Lease)。<br>有两种方式可以决定semaphore的最大租约数。第一种方式是有用户给定的path决定。第二种方式使用<code>SharedCountReader</code>类。<br>如果不使用SharedCountReader, 没有内部代码检查进程是否假定有10个租约而进程B假定有20个租约。 所以所有的实例必须使用相同的numberOfLeases值.</p>
<p>这次调用<code>acquire</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。<br>租约还可以通过下面的方式返还：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLease</span><span class="params">(Lease lease)</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong>一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty)</span></div><div class="line"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></div><div class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span></div></pre></td></tr></table></figure>
<p>主要类有:</p>
<ul>
<li>InterProcessSemaphoreV2</li>
<li>Lease</li>
<li>SharedCountReader</li>
</ul>
<p>下面是使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.Lease;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEASE = <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    <span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</div><div class="line">      CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">          <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">      client.start();</div><div class="line">      InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, PATH, MAX_LEASE);</div><div class="line">      Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="number">5</span>);</div><div class="line">      System.out.println(<span class="string">"get "</span> + leases.size() + <span class="string">" leases"</span>);</div><div class="line">      Lease lease = semaphore.acquire();</div><div class="line">      System.out.println(<span class="string">"get another lease"</span>);</div><div class="line">      resource.use();</div><div class="line">      Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">      System.out.println(<span class="string">"Should timeout and acquire return "</span> + leases2);</div><div class="line">      System.out.println(<span class="string">"return one lease"</span>);</div><div class="line">      semaphore.returnLease(lease);</div><div class="line">      System.out.println(<span class="string">"return another 5 leases"</span>);</div><div class="line">      semaphore.returnAll(leases);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先先获得了5个租约， 最后我们把它还给了semaphore。<br>接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。<br>然后再请求一个租约，因为租约不够，阻塞到超时，还是没能满足，返回结果为null。</p>
<p>上面所讲的锁都是公平锁(fair)。 从ZooKeeper的角度看， 每个客户端都按照请求的顺序获得锁，相当公平。</p>
<h3 id="多锁对象-Multi-Shared-Lock"><a href="#多锁对象-Multi-Shared-Lock" class="headerlink" title="多锁对象 Multi Shared Lock"></a>多锁对象 Multi Shared Lock</h3><p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire</code>， 所有的锁都会被<code>acquire</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(失败被忽略)。<br>基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<ul>
<li>InterProcessMultiLock</li>
<li>InterProcessLock</li>
</ul>
<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></div></pre></td></tr></table></figure>
<p>用法和Shared Lock相同。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMultiLockExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH1 = <span class="string">"/examples/locks1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/examples/locks2"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</div><div class="line">    <span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</div><div class="line">      CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">          <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">      client.start();</div><div class="line"></div><div class="line">      InterProcessLock lock1 = <span class="keyword">new</span> InterProcessMutex(client, PATH1);</div><div class="line">      InterProcessLock lock2 = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, PATH2);</div><div class="line"></div><div class="line">      InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(Arrays.asList(lock1, lock2));</div><div class="line">      <span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"could not acquire the lock"</span>);</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"has the lock"</span>);</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</div><div class="line">      System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        resource.use(); <span class="comment">// access resource exclusively</span></div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        System.out.println(<span class="string">"releasing the lock"</span>);</div><div class="line">        lock.release(); <span class="comment">// always release the lock in a finally block</span></div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</div><div class="line">      System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建一个InterProcessMultiLock， 包含一个重入锁和一个非重入锁。<br>调用<code>acquire</code>后可以看到线程同时拥有了这两个锁。<br>调用<code>release</code>看到这两个锁都被释放了。</p>
<p><strong>注意：</strong>强烈推荐使用ConnectionStateListener监控连接的状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper leader选举]]></title>
      <url>http://zsr.github.io/2016/08/29/zookeeper-leader%E9%80%89%E4%B8%BE/</url>
      <content type="html"><![CDATA[<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>在实际使用ZooKeeper开发中，我们最常用的是<a href="http://curator.apache.org/index.html" target="_blank" rel="external">Apache Curator</a>。 在使用ZK API开发时会遇到让人头疼的几个问题，ZK连接管理、SESSION失效等一些异常问题的处理，Curator替我们解决了这些问题，通过对ZK连接状态的监控来做出相应的重连等操作，并触发事件。</p>
<p>更好的地方是Curator对ZK的一些应用场景提供了非常好的实现，而且有很多扩充，这些都符合ZK使用规范。<br>它的主要组件为：</p>
<ul>
<li><strong>Recipes</strong>: ZooKeeper的系列recipe实现, 基于 Curator Framework.**</li>
<li><strong>Framework</strong>: 封装了大量ZooKeeper常用API操作，降低了使用难度, 基于Zookeeper增加了一些新特性，对ZooKeeper链接的管理，对链接丢失自动重新链接。**</li>
<li><strong>Utilities</strong>: 一些ZooKeeper操作的工具类包括ZK的集群测试工具路径生成等非常有用，在Curator-Client包下org.apache.curator.utils。</li>
<li><strong>Client</strong>: ZooKeeper的客户端API封装，替代官方 ZooKeeper class，解决了一些繁琐低级的处理，提供一些工具类。</li>
<li><strong>Errors</strong>: 异常处理, 连接异常等</li>
<li><strong>Extensions</strong>: 对curator-recipes的扩展实现，拆分为curator-: stuck_out_tongue_closed_eyes: iscovery和curator-: stuck_out_tongue_closed_eyes: iscovery-server提供基于RESTful的Recipes WEB服务.</li>
</ul>
<p>在分布式计算中， leader election是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader或者coordinator. 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader.<br>除此之外， 选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p>Curator 有两种选举recipe， 可以根据需求选择合适的。</p>
<h3 id="Leader-latch"><a href="#Leader-latch" class="headerlink" title="Leader latch"></a>Leader latch</h3><p>使用<code>LeaderLatch</code>类选举的例子.</p>
<p>构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath,  String id)</span></div></pre></td></tr></table></figure>
<p>启动LeaderLatch: <code>leaderLatch.start();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Add this instance to the leadership election and attempt to acquire leadership.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> Exception errors</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line">    &#123;</div><div class="line">        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), <span class="string">"Cannot be started more than once"</span>);</div><div class="line"></div><div class="line">        startTask.set(AfterConnectionEstablished.execute(client, <span class="keyword">new</span> Runnable()</div><div class="line">                &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">                    &#123;</div><div class="line">                        <span class="keyword">try</span></div><div class="line">                        &#123;</div><div class="line">                            internalStart();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">finally</span></div><div class="line">                        &#123;</div><div class="line">                            startTask.set(<span class="keyword">null</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>一旦启动， LeaderLatch会和其它使用相同latch path的其它LeaderLatch交涉，然后随机的选择其中一个作为leader。 可以随时查看一个给定的实例是否是leader:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeadership</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>LeaderLatch在请求成为leadership时有block方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></div><div class="line">     <span class="keyword">throws</span> InterruptedException, EOFException</div><div class="line">   &#123;</div><div class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">while</span> ((<span class="keyword">this</span>.state.get() == State.STARTED) &amp;&amp; (!<span class="keyword">this</span>.hasLeadership.get()))</div><div class="line">       &#123;</div><div class="line">         wait();</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.state.get() != State.STARTED)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">Causes the current thread to wait until <span class="keyword">this</span> instance acquires leadership</div><div class="line">unless the thread is interrupted or closed.</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></div><div class="line">                     TimeUnit unit)</div><div class="line">            <span class="keyword">throws</span> InterruptedException</div></pre></td></tr></table></figure>
<p>一旦不使用LeaderLatch了，必须调用<code>close</code>方法。 如果它是leader,会释放leadership， 其它的参与者将会重新选举一个leader。</p>
<p><strong>异常处理</strong><br>LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader.当LOST 连接重连后 RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个.<br>LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<p><strong>LeaderLatch案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatch;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchExample</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</div><div class="line">    List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</div><div class="line">    TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">        clients.add(client);</div><div class="line">        LeaderLatch example = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</div><div class="line">        examples.add(example);</div><div class="line">        client.start();</div><div class="line">        example.start();</div><div class="line">      &#125;</div><div class="line">      Thread.sleep(<span class="number">2000</span>);</div><div class="line">      LeaderLatch currentLeader = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        LeaderLatch example = examples.get(i);</div><div class="line">        <span class="keyword">if</span> (example.hasLeadership())</div><div class="line">          currentLeader = example;</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</div><div class="line">      System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</div><div class="line">      currentLeader.close();</div><div class="line">      examples.get(<span class="number">0</span>).await(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">      System.out.println(<span class="string">"Client #0 maybe is elected as the leader or not although it want to be"</span>);</div><div class="line">      System.out.println(<span class="string">"the new leader is "</span> + examples.get(<span class="number">0</span>).getLeader().getId());</div><div class="line">      </div><div class="line">      System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</div><div class="line">      <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(<span class="string">"Shutting down..."</span>);</div><div class="line">      <span class="keyword">for</span> (LeaderLatch exampleClient : examples) &#123;</div><div class="line">        CloseableUtils.closeQuietly(exampleClient);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (CuratorFramework client : clients) &#123;</div><div class="line">        CloseableUtils.closeQuietly(client);</div><div class="line">      &#125;</div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先创建了10个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>通过<code>hasLeadership</code>查看自己是否是leader， 如果是的话返回true。<br>可以通过<code>.getLeader().getId()</code>可以得到当前的leader的ID。<br>只能通过<code>close</code>释放当前的领导权。<br><code>await</code>是一个阻塞方法， 尝试获取leader地位，但是未必能选中。</p>
<h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><p>Curator还提供了另外一种选举方法。<br>主要涉及以下四个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter</li>
<li>CancelLeadershipException</li>
</ul>
<p>重要的是LeaderSelector类，它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></div></pre></td></tr></table></figure>
<p>类似LeaderLatch,必须<code>start</code>: <code>leaderSelector.start();</code><br>一旦启动，当实例取得领导权时你的listener的<code>takeLeadership()</code>方法被调用. 而takeLeadership()方法只有领导权被释放时才返回。<br>当你不再使用<code>LeaderSelector</code>实例时，需要调用它的close方法</p>
<p><strong>异常处理</strong><br>LeaderSelectorListener类继承ConnectionStateListener。LeaderSelector必须小心连接状态的改变. 如果实例成为leader, 它应该响应SUSPENDED 或 LOST. 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， takeLeadership方法返回.</p>
<p><strong>注意：</strong>推荐处理方式是当收到SUSPENDED 或 LOST时抛出CancelLeadershipException异常. 这会导致LeaderSelector实例中断并取消执行takeLeadership方法的异常. 这非常重要， 你必须考虑扩展LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter提供了推荐的处理逻辑。</p>
<p><strong>LeaderSelector案例</strong></p>
<p>首先创建一个ExampleClient类， 它继承LeaderSelectorListenerAdapter， 它实现了takeLeadership方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Closeable;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An example leader selector client. Note that &#123;<span class="doctag">@link</span> LeaderSelectorListenerAdapter&#125; which has the</div><div class="line"> * recommended handling for connection state issues</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClient</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger leaderCount = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleClient</span><span class="params">(CuratorFramework client, String path, String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="comment">// create a leader selector using the given path for management</span></div><div class="line">    <span class="comment">// all participants in a given leader selection must use the same path</span></div><div class="line">    <span class="comment">// ExampleClient here is also a LeaderSelectorListener but this isn't required</span></div><div class="line">    leaderSelector = <span class="keyword">new</span> LeaderSelector(client, path, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// for most cases you will want your instance to requeue when it relinquishes leadership</span></div><div class="line">    leaderSelector.autoRequeue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// the selection for this instance doesn't start until the leader selector is started</span></div><div class="line">    <span class="comment">// leader selection is done in the background so this call to leaderSelector.start() returns</span></div><div class="line">    <span class="comment">// immediately</span></div><div class="line">    leaderSelector.start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    leaderSelector.close();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// we are now the leader. This method should not return until we want to relinquish leadership</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> waitSeconds = (<span class="keyword">int</span>) (<span class="number">5</span> * Math.random()) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    System.out.println(name + <span class="string">" is now the leader. Waiting "</span> + waitSeconds + <span class="string">" seconds..."</span>);</div><div class="line">    System.out.println(name + <span class="string">" has been leader "</span> + leaderCount.getAndIncrement() + <span class="string">" time(s) before."</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      System.err.println(name + <span class="string">" was interrupted."</span>);</div><div class="line">      Thread.currentThread().interrupt();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(name + <span class="string">" relinquishing leadership.\n"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在takeLeadership进行任务的分配等等，并且不要返回，如果你想要要此实例一直是leader的话可以加一个死循环。<br><code>leaderSelector.autoRequeue();</code>：保证在此实例释放领导权之后还可能获得领导权。<br>在这里我们使用AtomicInteger来记录此client获得领导权的次数， 它是公平的， 每个client有平等的机会获得领导权。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.curator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</div><div class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorExample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// all of the useful sample code is in ExampleClient.java</span></div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Create "</span> + CLIENT_QTY</div><div class="line">        + <span class="string">" clients, have each negotiate for leadership and then wait a random number of seconds before letting another leader election occur."</span>);</div><div class="line">    System.out.println(</div><div class="line">        <span class="string">"Notice that leader election is fair: all clients will become leader and will do so the same number of times."</span>);</div><div class="line"></div><div class="line">    List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</div><div class="line">    List&lt;ExampleClient&gt; examples = Lists.newArrayList();</div><div class="line">    TestingServer server = <span class="keyword">new</span> TestingServer();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</div><div class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(),</div><div class="line">            <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line">        clients.add(client);</div><div class="line"></div><div class="line">        ExampleClient example = <span class="keyword">new</span> ExampleClient(client, PATH, <span class="string">"Client #"</span> + i);</div><div class="line">        examples.add(example);</div><div class="line"></div><div class="line">        client.start();</div><div class="line">        example.start();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</div><div class="line">      <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      System.out.println(<span class="string">"Shutting down..."</span>);</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (ExampleClient exampleClient : examples) &#123;</div><div class="line">        CloseableUtils.closeQuietly(exampleClient);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (CuratorFramework client : clients) &#123;</div><div class="line">        CloseableUtils.closeQuietly(client);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      CloseableUtils.closeQuietly(server);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与LeaderLatch相比， 通过<code>LeaderSelectorListener</code>可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。 而LeaderLatch除非调用close方法，否则它不会释放领导权。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java mock]]></title>
      <url>http://zsr.github.io/2016/08/26/java-mock/</url>
      <content type="html"><![CDATA[<h3 id="Mock-测试"><a href="#Mock-测试" class="headerlink" title="Mock 测试"></a>Mock 测试</h3><p>Mock 最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。</p>
<p>比如一段代码有这样的依赖：</p>
<p><img src="http://media.techtarget.com/tss/static/articles/content/JMockTestDrivenDev/images/image004.jpg" alt="img"></p>
<p>当我们需要测试A类的时候，如果没有 Mock，则我们需要把整个依赖树都构建出来，而使用 Mock 的话就可以将结构分解开，像下面这样：</p>
<p><img src="http://media.techtarget.com/tss/static/articles/content/JMockTestDrivenDev/images/image010.jpg" alt="img"></p>
<p>mock对象就是在调试期间用来作为真实对象的替代品。</p>
<p>mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。</p>
<h3 id="Mock-对象使用范畴"><a href="#Mock-对象使用范畴" class="headerlink" title="Mock 对象使用范畴"></a>Mock 对象使用范畴</h3><ul>
<li>真实对象具有不可确定的行为，产生不可预测的效果，（如：股票行情，天气预报） </li>
<li>真实对象很难被创建的 </li>
<li>真实对象的某些行为很难被触发 </li>
<li>真实对象实际上还不存在的（和其他开发小组或者和新的硬件打交道）等等</li>
</ul>
<h3 id="Mockito-使用"><a href="#Mockito-使用" class="headerlink" title="Mockito 使用"></a>Mockito 使用</h3><h4 id="声明-mockito-依赖"><a href="#声明-mockito-依赖" class="headerlink" title="声明 mockito 依赖"></a>声明 mockito 依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.0.111-beta&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h4 id="1-验证行为"><a href="#1-验证行为" class="headerlink" title="1. 验证行为"></a>1. 验证行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Let's import Mockito statically so that the code looks clearer</span></div><div class="line"> <span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"> <span class="comment">//mock creation</span></div><div class="line"> List mockedList = mock(List.class);</div><div class="line"></div><div class="line"> <span class="comment">//using mock object</span></div><div class="line"> mockedList.add(<span class="string">"one"</span>);</div><div class="line"> mockedList.clear();</div><div class="line"></div><div class="line"> <span class="comment">//verification</span></div><div class="line"> verify(mockedList).add(<span class="string">"one"</span>);</div><div class="line"> verify(mockedList).clear();</div></pre></td></tr></table></figure>
<p>一旦创建 mock 将会记得所有的交互。你可以选择验证你感兴趣的任何交互</p>
<h4 id="2-stubbing"><a href="#2-stubbing" class="headerlink" title="2. stubbing"></a>2. stubbing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//You can mock concrete classes, not just interfaces</span></div><div class="line">LinkedList mockedList = mock(LinkedList.class);</div><div class="line"></div><div class="line"><span class="comment">//stubbing</span></div><div class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</div><div class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</div><div class="line"></div><div class="line"><span class="comment">//following prints "first"</span></div><div class="line">System.out.println(mockedList.get(<span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">//following throws runtime exception</span></div><div class="line">System.out.println(mockedList.get(<span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">//following prints "null" because get(999) was not stubbed</span></div><div class="line">System.out.println(mockedList.get(<span class="number">999</span>));</div><div class="line"></div><div class="line"><span class="comment">//Although it is possible to verify a stubbed invocation, usually it's just redundant</span></div><div class="line"><span class="comment">//If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).</span></div><div class="line"><span class="comment">//If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here.</span></div><div class="line">verify(mockedList).get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>默认情况下，所有方法都会返回值，一个 mock 将返回要么 null，一个原始/基本类型的包装值或适当的空集。例如，对于一个 int/Integer 就是 0，而对于 boolean/Boolean 就是 false。</li>
<li>Stubbing 可以被覆盖。</li>
<li>一旦 stub，该方法将始终返回一个 stub 的值，无论它有多少次被调用。</li>
<li>最后的 stubbing 是很重要的 - 当你使用相同的参数 stub 多次同样的方法。换句话说：stubbing 的顺序是重要的，但它唯一有意义的却很少，例如当 stubbing 完全相同的方法调用，或者有时当参数匹配器的使用，等等。</li>
</ul>
<h4 id="3-参数匹配器"><a href="#3-参数匹配器" class="headerlink" title="3. 参数匹配器"></a>3. 参数匹配器</h4><p>Mockito 验证参数值使用 Java 方式：通过使用 equals() 方法。有时，当需要额外的灵活性，可以使用参数匹配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//stubbing using built-in anyInt() argument matcher</span></div><div class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</div><div class="line"></div><div class="line"><span class="comment">//stubbing using custom matcher (let's say isValid() returns your own matcher implementation):</span></div><div class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following prints "element"</span></div><div class="line">System.out.println(mockedList.get(<span class="number">999</span>));</div><div class="line"></div><div class="line"><span class="comment">//you can also verify using an argument matcher</span></div><div class="line">verify(mockedList).get(anyInt());</div></pre></td></tr></table></figure>
<p>下面的示例演示验证，但同样适用于 stubbing：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">"third argument"</span>));</div><div class="line"><span class="comment">//above is correct - eq() is also an argument matcher</span></div><div class="line"></div><div class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">"third argument"</span>);</div><div class="line"><span class="comment">//above is incorrect - exception will be thrown because third argument is given without an argument matcher.</span></div></pre></td></tr></table></figure>
<h4 id="4-调用额外的调用数字-at-least-never"><a href="#4-调用额外的调用数字-at-least-never" class="headerlink" title="4. 调用额外的调用数字/at least / never"></a>4. 调用额外的调用数字/at least / never</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mock</span></div><div class="line">mockedList.add(<span class="string">"once"</span>);</div><div class="line"></div><div class="line">mockedList.add(<span class="string">"twice"</span>);</div><div class="line">mockedList.add(<span class="string">"twice"</span>);</div><div class="line"></div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line">mockedList.add(<span class="string">"three times"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following two verifications work exactly the same - times(1) is used by default</span></div><div class="line">verify(mockedList).add(<span class="string">"once"</span>);</div><div class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"once"</span>);</div><div class="line"></div><div class="line"><span class="comment">//exact number of invocations verification</span></div><div class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">"twice"</span>);</div><div class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verification using never(). never() is an alias to times(0)</span></div><div class="line">verify(mockedList, never()).add(<span class="string">"never happened"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verification using atLeast()/atMost()</span></div><div class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"three times"</span>);</div><div class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">"five times"</span>);</div><div class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">"three times"</span>);</div></pre></td></tr></table></figure>
<p>times(1) 是默认的，因此，使用的 times(1) 可以显示的省略。</p>
<h4 id="5-Stubbing-void-方法处理异常"><a href="#5-Stubbing-void-方法处理异常" class="headerlink" title="5. Stubbing void 方法处理异常"></a>5. Stubbing void 方法处理异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</div><div class="line"></div><div class="line"><span class="comment">//following throws RuntimeException:</span></div><div class="line">mockedList.clear();</div></pre></td></tr></table></figure>
<h4 id="6-有序的验证"><a href="#6-有序的验证" class="headerlink" title="6. 有序的验证"></a>6. 有序的验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A. Single mock whose methods must be invoked in a particular order</span></div><div class="line">List singleMock = mock(List.class);</div><div class="line"></div><div class="line"><span class="comment">//using a single mock</span></div><div class="line">singleMock.add(<span class="string">"was added first"</span>);</div><div class="line">singleMock.add(<span class="string">"was added second"</span>);</div><div class="line"></div><div class="line"><span class="comment">//create an inOrder verifier for a single mock</span></div><div class="line">InOrder inOrder = inOrder(singleMock);</div><div class="line"></div><div class="line"><span class="comment">//following will make sure that add is first called with "was added first, then with "was added second"</span></div><div class="line">inOrder.verify(singleMock).add(<span class="string">"was added first"</span>);</div><div class="line">inOrder.verify(singleMock).add(<span class="string">"was added second"</span>);</div><div class="line"></div><div class="line"><span class="comment">// B. Multiple mocks that must be used in a particular order</span></div><div class="line">List firstMock = mock(List.class);</div><div class="line">List secondMock = mock(List.class);</div><div class="line"></div><div class="line"><span class="comment">//using mocks</span></div><div class="line">firstMock.add(<span class="string">"was called first"</span>);</div><div class="line">secondMock.add(<span class="string">"was called second"</span>);</div><div class="line"></div><div class="line"><span class="comment">//create inOrder object passing any mocks that need to be verified in order</span></div><div class="line">InOrder inOrder = inOrder(firstMock, secondMock);</div><div class="line"></div><div class="line"><span class="comment">//following will make sure that firstMock was called before secondMock</span></div><div class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</div><div class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Oh, and A + B can be mixed together at will</span></div></pre></td></tr></table></figure>
<p>有序验证是为了灵活 - 不必一个接一个验证所有的交互。</p>
<p>此外，还可以通过创建 InOrder 对象传递只与有序验证相关的 mock 。</p>
<h4 id="7-确保-mock-上不会发生交互"><a href="#7-确保-mock-上不会发生交互" class="headerlink" title="7. 确保 mock 上不会发生交互"></a>7. 确保 mock 上不会发生交互</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mocks - only mockOne is interacted</span></div><div class="line">mockOne.add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//ordinary verification</span></div><div class="line">verify(mockOne).add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verify that method was never called on a mock</span></div><div class="line">verify(mockOne, never()).add(<span class="string">"two"</span>);</div><div class="line"></div><div class="line"><span class="comment">//verify that other mocks were not interacted</span></div><div class="line">verifyZeroInteractions(mockTwo, mockThree);</div></pre></td></tr></table></figure>
<h4 id="8-寻找多余的调用"><a href="#8-寻找多余的调用" class="headerlink" title="8. 寻找多余的调用"></a>8. 寻找多余的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//using mocks</span></div><div class="line">mockedList.add(<span class="string">"one"</span>);</div><div class="line">mockedList.add(<span class="string">"two"</span>);</div><div class="line"></div><div class="line">verify(mockedList).add(<span class="string">"one"</span>);</div><div class="line"></div><div class="line"><span class="comment">//following verification will fail</span></div><div class="line">verifyNoMoreInteractions(mockedList);</div></pre></td></tr></table></figure>
<p>注意：不建议 verifyNoMoreInteractions() 在每个测试方法中使用。 verifyNoMoreInteractions() 是从交互测试工具包一个方便的断言。只有与它的相关时才使用它。滥用它导致难以维护。</p>
<h4 id="9-标准创建-mock-方式-使用-Mock-注解"><a href="#9-标准创建-mock-方式-使用-Mock-注解" class="headerlink" title="9. 标准创建 mock 方式 - 使用 @Mock 注解"></a>9. 标准创建 mock 方式 - 使用 <code>@Mock</code> 注解</h4><ul>
<li>最小化可重用 mock 创建代码</li>
<li>使测试类更加可读性</li>
<li>使验证错误更加易读，因为字段名称用于唯一识别 mock</li>
</ul>
<p>public class ArticleManagerTest {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</div><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</div><div class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</div><div class="line"></div><div class="line"><span class="keyword">private</span> ArticleManager manager;</div></pre></td></tr></table></figure>
<p>在基础类或者测试 runner 里面，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MockitoAnnotations.initMocks(testClass);</div></pre></td></tr></table></figure>
<p>可以使用内建 runner: <a href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html" target="_blank" rel="external">MockitoJUnitRunner</a> 或者 rule: <a href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html" target="_blank" rel="external">MockitoRule</a></p>
<p>更多详见 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html" target="_blank" rel="external">MockitoAnnotations</a></p>
<h4 id="10-Stubbing-连续调用（迭代器式的-stubbing）"><a href="#10-Stubbing-连续调用（迭代器式的-stubbing）" class="headerlink" title="10. Stubbing 连续调用（迭代器式的 stubbing）"></a>10. Stubbing 连续调用（迭代器式的 stubbing）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(<span class="string">"some arg"</span>))</div><div class="line"> .thenThrow(<span class="keyword">new</span> RuntimeException())</div><div class="line"> .thenReturn(<span class="string">"foo"</span>);</div><div class="line"></div><div class="line"><span class="comment">//First call: throws runtime exception:</span></div><div class="line">mock.someMethod(<span class="string">"some arg"</span>);</div><div class="line"></div><div class="line"><span class="comment">//Second call: prints "foo"</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</div><div class="line"></div><div class="line"><span class="comment">//Any consecutive call: prints "foo" as well (last stubbing wins).</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</div></pre></td></tr></table></figure>
<p>下面是一个精简版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(<span class="string">"some arg"</span>))</div><div class="line"> .thenReturn(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</div></pre></td></tr></table></figure>
<h4 id="11-回调-Stubbing"><a href="#11-回调-Stubbing" class="headerlink" title="11. 回调 Stubbing"></a>11. 回调 Stubbing</h4><p>允许使用泛型 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/stubbing/Answer.html" target="_blank" rel="external">Answer</a> 接口。</p>
<p>然而，这是不包括在最初的 Mockito 另一个有争议的功能。建议只需用thenReturn() 或 thenThrow() 来 stubbing ，这在测试/测试驱动中应用简洁与简单的代码足够了。但是，如果有一个需要 stub 到泛型 Answer 接口，这里是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">when(mock.someMethod(anyString())).thenAnswer(<span class="keyword">new</span> Answer() &#123;</div><div class="line">   <span class="function">Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</div><div class="line">       Object[] args = invocation.getArguments();</div><div class="line">       Object mock = invocation.getMock();</div><div class="line">       <span class="keyword">return</span> <span class="string">"called with arguments: "</span> + args;</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//the following prints "called with arguments: foo"</span></div><div class="line">System.out.println(mock.someMethod(<span class="string">"foo"</span>));</div></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigDecimal minimumSalary = <span class="keyword">new</span> BigDecimal(<span class="number">20000</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> EmployeeDAO employeeDAO;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TaxCalculator taxCalculator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getNetSalary</span><span class="params">(<span class="keyword">long</span> employeeId)</span> </span>&#123;</div><div class="line">        BigDecimal netSalary = <span class="keyword">null</span>;</div><div class="line">        BigDecimal grossSalary = employeeDAO.getAnnualSalary(employeeId);</div><div class="line">        BigDecimal taxes = taxCalculator.calculateTaxes(grossSalary);</div><div class="line">        <span class="keyword">if</span> (taxedSalaryIsGreaterThanMinimumSalary(grossSalary)) &#123;</div><div class="line">            netSalary = grossSalary.subtract(taxes);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            netSalary = grossSalary;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> netSalary;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">taxedSalaryIsGreaterThanMinimumSalary</span><span class="params">(BigDecimal taxedSalary)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> taxedSalary.compareTo(minimumSalary) == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getAnnualSalary</span><span class="params">(<span class="keyword">long</span> employeeId)</span> </span>&#123;</div><div class="line">        <span class="comment">// conncetTODB</span></div><div class="line">        <span class="comment">// run select for employeeId;</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(<span class="number">70000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaxCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calculateTaxes</span><span class="params">(BigDecimal salary)</span> </span>&#123;</div><div class="line">        BigDecimal result = salary.multiply(<span class="keyword">new</span> BigDecimal(<span class="number">200</span>));</div><div class="line">        <span class="comment">// some other weird calculation ....</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryServiceTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UserId = <span class="number">123l</span>;</div><div class="line"></div><div class="line">  <span class="meta">@InjectMocks</span></div><div class="line">  <span class="keyword">private</span> SalaryService salaryService;</div><div class="line"></div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> EmployeeDAO employeeDAO;</div><div class="line"></div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="keyword">private</span> TaxCalculator taxCalculator;</div><div class="line"></div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMinimumSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">      BigDecimal annualSalary = <span class="keyword">new</span> BigDecimal(<span class="number">10000</span>);</div><div class="line">      Mockito.when(employeeDAO.getAnnualSalary(UserId)).thenReturn(annualSalary);</div><div class="line">      Mockito.when(taxCalculator.calculateTaxes(annualSalary)).thenReturn(<span class="keyword">new</span> BigDecimal(<span class="number">1000</span>));</div><div class="line">      BigDecimal actual = salaryService.getNetSalary(UserId);</div><div class="line">      assertThat(actual.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">10000</span>)), is(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMaximumSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">      BigDecimal annualSalary = <span class="keyword">new</span> BigDecimal(<span class="number">80000</span>);</div><div class="line">      Mockito.when(employeeDAO.getAnnualSalary(UserId)).thenReturn(annualSalary);</div><div class="line">      Mockito.when(taxCalculator.calculateTaxes(annualSalary)).thenReturn(<span class="keyword">new</span> BigDecimal(<span class="number">8000</span>));</div><div class="line">      BigDecimal actual = salaryService.getNetSalary(UserId);</div><div class="line">      assertThat(actual.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">72000</span>)), is(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.vogella.com/tutorials/Mockito/article.html#prerequisites" target="_blank" rel="external">Mockito</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper 安装]]></title>
      <url>http://zsr.github.io/2016/08/24/zookeeper-%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h1 id="Zookeeper-安装及配置（Mac）"><a href="#Zookeeper-安装及配置（Mac）" class="headerlink" title="Zookeeper 安装及配置（Mac）"></a>Zookeeper 安装及配置（Mac）</h1><p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<h3 id="Zookeeper-的安装"><a href="#Zookeeper-的安装" class="headerlink" title="Zookeeper 的安装"></a>Zookeeper 的安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下载地址：http://www.apache.org/dyn/closer.cgi/zookeeper</div></pre></td></tr></table></figure>
<p>首先从官网下载ZooKeeper压缩包，然后解压下载得到的ZooKeeper压缩包，发现有“bin，conf，lib”等目录。“bin目录”中存放有运行脚本；“conf目录”中存放有配置文件；“lib目录”中存放有运行所需要第三方库。<br>解压文件： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf zookeeper-3.4.8.tar.gz</div></pre></td></tr></table></figure>
<h3 id="Zookeeper-的配置"><a href="#Zookeeper-的配置" class="headerlink" title="Zookeeper 的配置"></a>Zookeeper 的配置</h3><h4 id="伪分布式部署"><a href="#伪分布式部署" class="headerlink" title="伪分布式部署"></a>伪分布式部署</h4><ol>
<li>在“conf”目录下，新建一个名为“zoo.cfg”的文件，准备部署3个节点，其中内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   tickTime=2000</div><div class="line">initLimit=5</div><div class="line">syncLimit=2</div><div class="line">dataDir=/Users/nali/program/zookeeper-3.4.8_1/data</div><div class="line">dataLogDir=/Users/nali/program/zookeeper-3.4.8_1/logs </div><div class="line">clientPort=2181(不同节点注意不同)</div><div class="line">server.1=127.0.0.1:2888:3888</div><div class="line">server.2=127.0.0.1:2889:3889</div><div class="line">server.3=127.0.0.1:2890:3890</div></pre></td></tr></table></figure>
<p><strong>参数说明:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#tickTime: 客户端和服务端或者服务端多个节点之间维持心跳的时间间隔，单位毫秒。</div><div class="line"></div><div class="line">#initLimit：zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower.</div><div class="line">initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5   倍tickTime, 即5*2000=10000ms=10s.</div><div class="line"></div><div class="line">#syncLimit：该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms.</div><div class="line"></div><div class="line">#dataDir: 数据文件存放目录,可以是任意目录</div><div class="line"></div><div class="line">#dataLogDir: 用来重做数据的事务日志文件存放目录.</div><div class="line"></div><div class="line">#clientPort: 监听client连接的端口号.</div><div class="line"></div><div class="line">#server.1，server.2，server.3: 表示节点编号，后边用冒号隔开的三个数字，分别表示节点的ip，交换数据的端口号，某个节点挂掉之后专门用来选举的端口号。</div></pre></td></tr></table></figure>
<font color="red">注：initLimit，syncLimit在单节点部署模式下，不需要配置。</font>

<ol>
<li>在dataDir目录下创建myid文件，写入该节点的编号 1 。这样一个节点就配置完成了。</li>
<li>复制 zookeeper-3.4.8-1 到 zookeeper-3.4.8-2和 zookeeper-3.4.8-3，要修改的地方是 zoo.cfg里的 dataDir,dataLogDir,clientPort。还有需要在自己的data目录下新建myid文件，写入自己的编号。</li>
</ol>
<table>
<thead>
<tr>
<th>myid</th>
<th>Data目录</th>
<th>Client</th>
<th>Server</th>
<th>Leader</th>
<th>配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>/zookeeper-3.4.8_1/data</td>
<td>2181</td>
<td>2888</td>
<td>3888</td>
<td>z1.cfg</td>
</tr>
<tr>
<td>2</td>
<td>/zookeeper-3.4.8_2/data</td>
<td>2182</td>
<td>2889</td>
<td>3889</td>
<td>z2.cfg</td>
</tr>
<tr>
<td>3</td>
<td>/zookeeper-3.4.8_3/data</td>
<td>2183</td>
<td>2890</td>
<td>3890</td>
<td>z3.cfg</td>
</tr>
</tbody>
</table>
<ol>
<li>启动和测试</li>
</ol>
<p>分别进入三个节点的bin目录，启动zookeeper，运行./zkServer.sh start。</p>
<p>注：前边节点启动的时候，会抛出一些错误，可忽略。这是因为另外的节点没启动，导致的通信异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:program nali$ <span class="built_in">cd</span> zookeeper-3.4.8_3/bin/</div><div class="line">nalideMacBook-Pro-4:bin nali$ ./zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /Users/nali/program/zookeeper-3.4.8_3/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div></pre></td></tr></table></figure>
<p>​       </p>
<p>可以用自带的基于telnet的客户端测试一下，看看是否启动成功。随便进入一个节点的bin目录，比如节点0</p>
<p>./zkCli.sh -server 127.0.0.1:2180，随便输入一个字符，他会跳出help界面。说明服务端启动成功。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:bin nali$ ./zkCli.sh -server 127.0.0.1:2181</div><div class="line">Connecting to 127.0.0.1:2181</div><div class="line">2016-08-25 21:02:28,712 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.8--1, built on 02/06/2016 03:18 GMT</div><div class="line">2016-08-25 21:02:28,715 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=192.168.120.222</div><div class="line">2016-08-25 21:02:28,715 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_91</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre</div><div class="line">2016-08-25 21:02:28,717 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/Users/nali/program/zookeeper-3.4.8_1/bin/../build/classes:/Users/nali/program/zookeeper-3.4.8_1/bin/../build/lib/*.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/slf4j-log4j12-1.6.1.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/slf4j-api-1.6.1.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/netty-3.7.0.Final.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/<span class="built_in">log</span>4j-1.2.16.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../lib/jline-0.9.94.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../zookeeper-3.4.8.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../src/java/lib/*.jar:/Users/nali/program/zookeeper-3.4.8_1/bin/../conf:</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/Users/nali/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/var/folders/jr/rgnrtr4n13n3d6tbwsch9_qr0000gn/T/</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=&lt;NA&gt;</div><div class="line">2016-08-25 21:02:28,718 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Mac OS X</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=x86_64</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=10.11.4</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=nali</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/Users/nali</div><div class="line">2016-08-25 21:02:28,719 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/Users/nali/program/zookeeper-3.4.8_1/bin</div><div class="line">2016-08-25 21:02:28,721 [myid:] - INFO  [main:ZooKeeper@438] - Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain<span class="variable">$MyWatcher</span>@531d72ca</div><div class="line">Welcome to ZooKeeper!</div></pre></td></tr></table></figure>
<ol>
<li>Zookeeper常用命令<ul>
<li>ZooKeeper服务端命令:<ul>
<li>启动ZK服务:  bin/zkServer.sh start</li>
<li>查看ZK服务状态: bin/zkServer.sh status</li>
<li>停止ZK服务:  bin/zkServer.sh stop</li>
<li>重启ZK服务:  bin/zkServer.sh restart</li>
</ul>
</li>
<li>zk客户端命令<ul>
<li>显示根目录下、文件： ls / 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</li>
<li>显示根目录下、文件： ls2 / 查看当前节点数据并能看到更新次数等数据</li>
<li>创建文件，并设置初始内容： create /zk “test” 创建一个新的 znode节点“ zk ”以及与它关联的字符</li>
<li>获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串</li>
<li>修改文件内容： set /zk “zkbak” 对 zk 所关联的字符串进行设置</li>
<li>删除文件： delete /zk 将刚才创建的 znode 删除</li>
<li>退出客户端： quit</li>
<li>帮助命令： help</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>zookeeper仅仅是维护了一个分布式的树形目录。如下图。它通过<a href="http://baike.baidu.com/view/8438269.htm" target="_blank" rel="external">fast paxos算法</a>保证多个节点上znode的数据一致性。一套zookeeper可以同时给多个应用程序使用，只需要隔离好各自的path~。在生产环境中，多个程序，比如hadoop，hbase，strom共用一套zookeeper也是常事。结构如下图。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0099/3476/b395cbf0-55aa-387e-af65-b5bcd9fcf234.jpg" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava cache]]></title>
      <url>http://zsr.github.io/2016/08/24/Guava-cache/</url>
      <content type="html"><![CDATA[<h1 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h1><p>Guava cache是一个应用内缓存(一般作为应用的本地缓存，redis作为集中式分布式缓存)。</p>
<p>一个缓存需要考虑的问题：</p>
<ul>
<li>缓存读取失败如何加载数据</li>
<li>加载策略（同步还是异步）</li>
<li>缓存过期问题</li>
<li>统计缓存命中情况</li>
<li>缓存数据失效时设置监听</li>
<li>缓存满时替换策略（LRU、FIFO）</li>
<li>……</li>
</ul>
<h3 id="Guava简单的示例："><a href="#Guava简单的示例：" class="headerlink" title="Guava简单的示例："></a>Guava简单的示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">    CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"call.."</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//fluent风格...</span></div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);</div><div class="line">    System.out.println(cache.size());</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"aaa"</span>));</div><div class="line">    System.out.println(cache.size());</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"aaa"</span>));</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(cache.get(<span class="string">"cjp"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该示例中，仅仅将一个类型是字符串作为key，value为它的大写形式。运行的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">call..</div><div class="line">AAA</div><div class="line">1</div><div class="line">AAA</div><div class="line">call..</div><div class="line">CJP</div></pre></td></tr></table></figure>
<p>Guava的缓存是一个LoadingCache实例，通过CacheBuilder创建该实例，并传入一个CacheLoader，CacheLoader实例注明了在缓存读取失败时如何加载数据，开始时，缓存中没有任何数据，size为0，当取aaa的时候，触发了缓存加载数据，输出call…，虽然缓存的size变成了1。然后再取aaa时，因为缓存中已经有了该key对应的value，就没有触发加载。</p>
<p>需要注意一下getUnchecked方法和get方法的不同，前者不对可能的异常做检查，调用代码不需要显式的捕捉异常，而后者调用代码需要显式的捕获异常。</p>
<p>这是一个非常简单的示例，可以看到使用guava实现一个缓存非常简单，如果将创建CacheLoader实例和build LoadingCache的两行代码合并，使用仅一行代码就可以实现一个缓存，并且Guava的缓存是线程安全的，可以放心的在多线程的环境中使用。</p>
<h3 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子:"></a>复杂一点的例子:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//缓存同步删除</span></div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).recordStats().removalListener(<span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"remove key["</span> + notification.getKey() + <span class="string">"],value["</span> + notification.getValue() + <span class="string">"],remove reason["</span> + notification.getCause() + <span class="string">"]"</span>);</div><div class="line">            System.out.println(<span class="string">"remove thread name "</span> + Thread.currentThread().getName());</div><div class="line">        &#125;</div><div class="line">    &#125;).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"key["</span> + key + <span class="string">"] to upper case"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    System.out.println(<span class="string">"thread name "</span> + Thread.currentThread().getName());</div><div class="line">    cache.invalidate(<span class="string">"b"</span>);<span class="comment">//删除key为b的值</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.stats().toString());</div><div class="line">    System.out.println(<span class="string">"end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">key[a] to upper <span class="keyword">case</span></div><div class="line">A</div><div class="line">key[b] to upper <span class="keyword">case</span></div><div class="line">B</div><div class="line">thread name main</div><div class="line">remove key[b],value[B],remove reason[EXPLICIT]</div><div class="line">remove thread name main A</div><div class="line">remove key[a],value[A],remove reason[EXPIRED]</div><div class="line">remove thread name main key[c] to upper <span class="keyword">case</span></div><div class="line">C</div><div class="line">key[a] to upper <span class="keyword">case</span></div><div class="line">A</div><div class="line">CacheStats&#123;hitCount=1, missCount=4, loadSuccessCount=4, loadExceptionCount=0, totalLoadTime=3460000, evictionCount=1&#125;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>创建了一个稍复杂的LoadingCache实例。各方法意义如下：</p>
<p><strong>expireAfterWrite</strong>：写入缓存后的过期时间<br><strong>maximumSize</strong>：缓存的最多存放元素个数<br><strong>recordStats</strong>：对缓存命中情况进行统计<br><strong>removalListener</strong>：设置缓存数据失效时监听器</p>
<p>Guava中很多地方都是这种fluent的方式.</p>
<p>在删除的监听器中打印线程的名字是为了显示该监听器是同步的还是异步的。可以看到删除监听是同步的，因为和主线程的名字是一样的，其实可以理解，因为我们并没有指定额外的线程池。删除监听器中可以看到删除的key、value、cause。主线程sleep 5s后，缓存中key为a的元素就过期了，可以看到监听器被调用，最后通过cache.stats()取得缓存命中的情况统计。可以看到命中1次，miss了4次（load了4次），事实上的确如此。</p>
<p>可以通过RemovalListeners.asynchronous方法就可以创建一个异步的listener对象。如下方式创建LoadingCache：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).recordStats().removalListener(RemovalListeners.asynchronous(<span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</div><div class="line">    <span class="comment">//删除缓存监听器异步删除</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"remove key["</span> + notification.getKey() + <span class="string">"],value["</span> + notification.getValue() + <span class="string">"],remove reason["</span> + notification.getCause() + <span class="string">"]"</span>);</div><div class="line">        System.out.println(<span class="string">"remove thread name "</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;, Executors.newCachedThreadPool())).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"key["</span> + key + <span class="string">"] to upper case"</span>);</div><div class="line">        <span class="keyword">return</span> key.toUpperCase();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>RemovalListeners.asynchronous方法接受两个参数，第一个参数是RemovalListener对象，第二个参数接收一个线程池，这样就可以异步的设置删除监听器了。运行可以看到主线程的线程名和监听器中的线程名是不同的。</p>
<p>上面创建缓存的方式是通过expireAfterWrite指定元素的过期时间，达到重新加载的。也就是说当过期后，这个元素就不存在了，再获取的时候就要通过load重新加载，当加载的时候，获取value的主线程必须同步的等缓存加载完获得数据后才能继续执行。这在一定程度上限制了访问速度。</p>
<p>如果数据量不大的情况下，就不必使用过期时间这种方式，而使用刷新，使用refreshAfterWrite指定刷新的时间间隔。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().recordStats().refreshAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"load key["</span> + key + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">reload</span><span class="params">(String key, String oldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"],oldValue["</span> + oldValue + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.reload(key, oldValue);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    cache.refresh(<span class="string">"a"</span>);</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的refresh示例，如果使用refreshAfterWrite，需要实现CacheLoader的reload方法，如果不实现，他有一个默认的实现，就是本示例展示的代码，直接调用load方法。代码的运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">load key[a]</div><div class="line">A</div><div class="line">load key[b] B</div><div class="line">reload key[a],oldValue[A]</div><div class="line">load key[a] reload key[a],oldValue[A]</div><div class="line">load key[a] A</div><div class="line">load key[c] C</div></pre></td></tr></table></figure>
<p>本例中刷新的时间设置为3s，再第一次显式的调用<code>cache.refresh(&quot;a&quot;)</code>的时候，可以看到reload方法被调用了。但是reload直接走默认的实现，调用了load方法，所以接着就输出了<code>load key[a]</code>当主线程sleep 3s后，再取a的值时因为超过刷新间隔，又会调用reload方法。可以想象这里的reload肯定是以同步的方式进行的，因为我们并没有指定额外的线程池用来执行reload方法，也就是说当到达刷新时间间隔后，取value的主线程还是要等refresh结束，才能拿到数据后执行，这和刚才的expireAfterWrite方式差不多。Guava提供了异步刷新的方式,看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 缓存失效时异步重现加载，缓存调用者永远不用阻塞等</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().recordStats().refreshAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"load key["</span> + key + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> key.toUpperCase();</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">reload</span><span class="params">(<span class="keyword">final</span> String key, String oldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"] synchronize at thread["</span> + Thread.currentThread().getName() + <span class="string">"],this will take 1 second..."</span>);</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    System.out.println(<span class="string">"reload end..."</span>);</div><div class="line">                    <span class="keyword">return</span> key.toUpperCase();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            Executors.newCachedThreadPool().execute(task);</div><div class="line">            System.out.println(<span class="string">"reload key["</span> + key + <span class="string">"],oldValue["</span> + oldValue + <span class="string">"]"</span>);</div><div class="line">            <span class="keyword">return</span> task;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//注意：如果重来没有被get过，在缓存中完全没有，第一次调用会执行load，然后加入到cache中，只有被加入到其中的</span></div><div class="line">    <span class="comment">//到达失效时间后，再被加载的时候才会触发reload</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    cache.refresh(<span class="string">"a"</span>);</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line">    <span class="comment">//这里的取a 不会触发reload，因为上面refresh需要耗1s才能结束，而主线程这里只需要等3s</span></div><div class="line">    <span class="comment">//所以这里的a还有1s的存活时间</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"a"</span>));</div><div class="line">    <span class="comment">//但是这里的b 就必须reload了，但是reload的过程需要注意下：先调用load方法，然后发现失效了，但是还会返回之前</span></div><div class="line">    <span class="comment">//缓存中的值，同时会加载reload，因为是异步reload，主线程这里不用等reload结束，继续向下运行获取c的值</span></div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"b"</span>));</div><div class="line">    System.out.println(cache.getUnchecked(<span class="string">"c"</span>));</div><div class="line">    <span class="comment">//这里再暂停5s是为了看清楚上面reload b的结束</span></div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本示例依然设置refresh时间为3s。重点是reload方法，先打印出reload执行所在的线程名，为了能清楚的看到主线程不需要等refresh完，这里sleep了1s。其他代码跟之前的差不多，运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">load key[a]</div><div class="line">A</div><div class="line">load key[b] B</div><div class="line">reload key[a],oldValue[A]</div><div class="line">reload key[a] synchronize at thread[pool-1-thread-1],this will take 1 second...</div><div class="line">reload end...</div><div class="line">A</div><div class="line">reload key[b],oldValue[B]</div><div class="line">B</div><div class="line">load key[c] C</div><div class="line">reload key[b] synchronize at thread[pool-2-thread-1],this will take 1 second...</div><div class="line">reload end...</div></pre></td></tr></table></figure>
<p>当执行<code>cache.refresh(&quot;a&quot;)</code>代码的时候，调用了reload方法，可以看到reload所在线程名是线程池中的。这句代码紧接着主线程sleep了3s，然后又去取a的值，按理说这时候a应该到达了刷新的时间间隔了，但是因为之前的reload方法执行就需要1s，所以对于a来说，还有1s的刷新时间剩余，所以这时取a的值，并不会触发reload。而紧接着取b的值就不同了，因为b没有被refresh过，这时候取b的值达到了刷新的时间间隔，所以会触发reload b。但是因为是异步的刷新，主线程根本不用等刷新完，所以立即输出了原来旧的值B，并立即输出了load c的结果，然后才看到 reload b的过程在继续进行，直到结束。</p>
<p>异步刷新，主线程永远不用等缓存的加载！现在在工作中所有使用Guava cahe的地方全部采用这种方式。</p>
<p><strong>注意如下几点：</strong></p>
<ul>
<li>refreshAfterWrite和expireAfterWrite的区别<ul>
<li>refreshAfterWrite只不过在刷新时间间隔到的时候，调用reload方法获取对于的key对于的value后替换当前内存中的key值。原来内存中的key对于的value是一直存在的。</li>
<li>expireAfterWrite方式当达到过期时间后，内存中的对应的key-value就被删除了（应该是被动删除方式，其实还在内存中，获取key的瞬间被删除）。只能通过load方法重新加载key对于的value。</li>
</ul>
</li>
<li>refresh方式并不是达到时间间隔后就立即刷新，而是在get数据的时候，发现超过刷新时间间隔了才会刷新，是被动的方式。</li>
<li>只有缓存中存在的key，在到达刷新时间时，才会通过reload刷新，如果缓存中没有对应key的value，第一次永远是调用load加载数据。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava future]]></title>
      <url>http://zsr.github.io/2016/08/24/Guava-future/</url>
      <content type="html"><![CDATA[<h2 id="Guava-Future"><a href="#Guava-Future" class="headerlink" title="Guava Future"></a>Guava Future</h2><h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><ul>
<li><p>同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</p>
</li>
<li><p>异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
</li>
<li><p>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>线程的并发方式一般有两种：</p>
<ul>
<li>异步执行一个任务，不需要返回结果</li>
<li>需要异步执行返回结果</li>
</ul>
<p>第一种，直接往线程池中仍Runnable对象，代码大概如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Executors.newCachedThreadPool().execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二种，一般有两种情况：</p>
<ul>
<li>主线程block到数据</li>
<li>设置回调</li>
</ul>
<p>JDK提供的方式就是主线程block到数据，类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future = Executors.newCachedThreadPool().submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object data = future.get();<span class="comment">//block直到拿到数据</span></div></pre></td></tr></table></figure>
<p>这种方式缺点很显然，主线程阻塞。而JDK对Future设置回调没有相应的方法，Guava扩展了这一点，引入ListenableFuture，可以对ListenableFuture设置回调。</p>
<h2 id="ListenableFuture"><a href="#ListenableFuture" class="headerlink" title="ListenableFuture"></a>ListenableFuture</h2><p>Guava为Java并行编程Future提供了很多有用扩展，其主要接口为ListenableFuture，并借助于Futures静态扩展。获得ListenableFuture实例有两种方法：</p>
<ul>
<li>向装饰后的线程池中提交callable</li>
<li>将普通的future转换为listenableFuture</li>
</ul>
<p>继承至Future的ListenableFuture，允许我们添加回调函数在线程运算完成时返回值或者方法执行完成立即返回。</p>
<p>对ListenableFuture添加回调函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(ListenableFuture&lt;V&gt;, FutureCallback&lt;V&gt;, Executor)</div></pre></td></tr></table></figure>
<p>其中 FutureCallback是一个包含onSuccess(V),onFailure(Throwable)的接口。</p>
<p>使用如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(ListenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"onSuccess with: %s%n"</span>, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"onFailure %s%n"</span>, thrown.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时Guava中Futures对于Future扩展还有：</p>
<ul>
<li>transform：对于ListenableFuture的返回值进行转换。</li>
<li>allAsList：对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。</li>
<li>successfulAsList：和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</li>
<li>immediateFuture/immediateCancelledFuture： 立即返回一个待返回值的ListenableFuture。</li>
<li>makeChecked: 将ListenableFuture 转换成CheckedFuture。CheckedFuture 是一个ListenableFuture ，其中包含了多个版本的get 方法，方法声明抛出检查异常.这样使得创建一个在执行逻辑中可以抛出异常的Future更加容易</li>
<li>JdkFutureAdapters.listenInPoolThread(future): guava同时提供了将JDK Future转换为ListenableFuture的接口函数。</li>
</ul>
<h3 id="装饰线程池"><a href="#装饰线程池" class="headerlink" title="装饰线程池"></a>装饰线程池</h3><p>Guava提供了方法将JDK的线程池装饰成一个“可监听的线程池”。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">        <span class="keyword">private</span> AtomicLong index = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnable, <span class="string">"commons-thread-"</span> + index.incrementAndGet());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    ListeningExecutorService listeningExecutorService = MoreExecutors.listeningDecorator(threadPool);</div><div class="line">    ListenableFuture&lt;String&gt; listenableFuture = listeningExecutorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">            <span class="comment">//System.out.println(1 / 0);</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> 	<span class="comment">//1)监听</span></div><div class="line">    listenableFuture.addListener(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"can't get return value"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, MoreExecutors.directExecutor());</div><div class="line"></div><div class="line">    <span class="comment">//2)回调</span></div><div class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"the result of future is: "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"exception:"</span> + t.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码先定义了普通的线程池，Guava通过<code>MoreExecutors.listeningDecorator(threadPool)</code>将普通的线程池装饰成一个可监听的线程池，向装饰后的线程池中提交callable，就可以获得listenableFuture实例了。</p>
<p>可以对listenableFuture设置listener(方法：addListener )，同时指定listen执行的线程池，也可以设置回调(方法：Futures.addCallback )，获取listenableFuture的结果。</p>
<ul>
<li><p>方法一：通过ListenableFuture的addListener方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">listenableFuture.addListener(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"get listenable future's result "</span> + listenableFuture.get());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, executorService);</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过Futures的静态方法addCallback给ListenableFuture添加回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;Integer&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer result)</span> </span>&#123;</div><div class="line">                  System.out.println(<span class="string">"get listenable future's result with callback "</span> + result);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">                  t.printStackTrace();</div><div class="line">              &#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>推荐使用第二种方法，因为第二种方法可以直接得到Future的返回值，或者处理错误情况。本质上第二种方法是通过调动第一种方法实现的，做了进一步的封装。</p>
<p>另外ListenableFuture接口还有其他几种内置具体实现：</p>
<ul>
<li>SettableFuture：不需要实现一个方法来计算返回值，而只需要返回一个固定值来做为返回值，可以通过程序设置此Future的返回值或者异常信息</li>
<li>CheckedFuture： 这是一个继承自ListenableFuture接口，他提供了checkedGet()方法，此方法在Future执行发生异常时，可以抛出指定类型的异常。</li>
</ul>
<p>可以在callable内部捕获异常，也可以抛出，在回调的onFailure中处理异常。</p>
<p>上面演示的是对JDK普通的线程池，当然也可以对时间调度的线程池进行装饰。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示定时调度线程池装饰成listen的效果</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ListeningScheduledExecutorService listeningScheduledExecutorService = MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(<span class="number">3</span>));</div><div class="line">    <span class="comment">//只有callable才对应有future</span></div><div class="line">    ListenableScheduledFuture&lt;?&gt; listenableScheduledFuture = listeningScheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello world"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">    <span class="comment">//因为上面的传的是runnable，所以没有返回值，没有返回值就不会触发future的callBack</span></div><div class="line">    Futures.addCallback(listenableScheduledFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"not result: "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">12000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰后的可监听的时间调度线程池使用方式和原来一样。这里调度了一个runnable对象。延迟5s后，每3s执行一次。因为runnable没有返回值，所以下面的回调不会被调用。当然可以向装饰后的线程池中提交callable，这样回调就会执行。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ListeningScheduledExecutorService listeningScheduledExecutorService = MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(<span class="number">3</span>));</div><div class="line">    ListenableScheduledFuture&lt;String&gt; schedule = listeningScheduledExecutorService.schedule(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">    Futures.addCallback(schedule, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">4000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将Future转换为ListenerableFuture"><a href="#将Future转换为ListenerableFuture" class="headerlink" title="将Future转换为ListenerableFuture"></a>将Future转换为ListenerableFuture</h3><p>Guava提供了方法将普通的future转换为listenerableFuture，以便于添加回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示将jdk的future转换为ListenableFuture</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName());</div><div class="line">            <span class="keyword">return</span> <span class="string">"world"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    ListenableFuture&lt;String&gt; listenableFuture = JdkFutureAdapters.listenInPoolThread(future);</div><div class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": hello "</span> + result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;, threadPool);<span class="comment">//MoreExecutors.directExecutor();这种方式拿到的线程池还是当前的现场环境，还是同步的。</span></div><div class="line">  System.out.println(<span class="string">"end."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>JdkFutureAdapters.listenInPoolThread(future)</code>转换一个普通的future。设置回调时，可以指定回调执行的线程池。</p>
<p>Guava提供的listenerableFuture处理可以设置回调，还能通过function进行变换。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java future]]></title>
      <url>http://zsr.github.io/2016/08/23/java-future/</url>
      <content type="html"><![CDATA[<h2 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h2><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p>
<p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h3 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h3><p>java.lang.Runnable:它是一个接口，在它里面只声明了一个run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法call()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure>
<p>第一个submit方法里面的参数类型就是Callable。<br>一般情况下使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future类位于java.util.concurrent包下，它是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ul>
<li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li>
</ul>
<p>也就是说Future提供了三种功能：</p>
<ul>
<li>1)判断任务是否完成；</li>
<li>2)能够中断任务；</li>
<li>3)能够获取任务执行结果。</li>
</ul>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask。</p>
<h4 id="Callable-Future-获取执行结果"><a href="#Callable-Future-获取执行结果" class="headerlink" title="Callable+Future 获取执行结果"></a>Callable+Future 获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        <span class="comment">//return the thread name executing this callable task</span></div><div class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="comment">//Get ExecutorService from Executors utility class, thread pool size is 10</span></div><div class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="comment">//create a list to hold the Future object associated with Callable</span></div><div class="line">        List&lt;Future&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</div><div class="line">        <span class="comment">//Create MyCallable instance</span></div><div class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</div><div class="line">            <span class="comment">//submit Callable tasks to be executed by thread pool</span></div><div class="line">            Future&lt;String&gt; future = executor.submit(callable);</div><div class="line">            <span class="comment">//add Future to the list, we can get return value using Future</span></div><div class="line">            list.add(future);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fut : list)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//print the return value of Future, notice the output delay in console</span></div><div class="line">                <span class="comment">// because Future.get() waits for task to get completed</span></div><div class="line">                System.out.println(<span class="keyword">new</span> Date()+ <span class="string">"::"</span>+fut.get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//shut down the executor service now</span></div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Tue Aug 23 12:02:44 CST 2016::pool-1-thread-1</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-2</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-3</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-4</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-5</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-6</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-7</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-8</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-9</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-10</div><div class="line">Tue Aug 23 12:02:45 CST 2016::pool-1-thread-8</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-4</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-7</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-9</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-1</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-5</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-3</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-6</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-2</div><div class="line">Tue Aug 23 12:02:46 CST 2016::pool-1-thread-10</div><div class="line">........I</div></pre></td></tr></table></figure>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>我们先来看一下FutureTask的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<p>FutureTask类实现了RunnableFuture接口，RunnableFuture接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>FutureTask提供了2个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Callable-FutureTask获取执行结果"><a href="#Callable-FutureTask获取执行结果" class="headerlink" title="Callable+FutureTask获取执行结果"></a>Callable+FutureTask获取执行结果</h4><ul>
<li>Callable 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span> waitTime;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> timeInMillis)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.waitTime=timeInMillis;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Thread.sleep(waitTime);</div><div class="line">        <span class="comment">//return the thread name executing this callable task</span></div><div class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FutureTask 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyCallable callable1 = <span class="keyword">new</span> MyCallable(<span class="number">1000</span>);</div><div class="line">		MyCallable callable2 = <span class="keyword">new</span> MyCallable(<span class="number">2000</span>);</div><div class="line"></div><div class="line">		FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(callable1);</div><div class="line">		FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(callable2);</div><div class="line"></div><div class="line">		ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">		executor.execute(futureTask1);</div><div class="line">		executor.execute(futureTask2);</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span>(futureTask1.isDone() &amp;&amp; futureTask2.isDone())&#123;</div><div class="line">					System.out.println(<span class="string">"Done"</span>);</div><div class="line">					<span class="comment">//shut down executor service</span></div><div class="line">					executor.shutdown();</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">if</span>(!futureTask1.isDone())&#123;</div><div class="line">				<span class="comment">//wait indefinitely for future task to complete</span></div><div class="line">				System.out.println(<span class="string">"FutureTask1 output="</span>+futureTask1.get());</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"Waiting for FutureTask2 to complete"</span>);</div><div class="line">				String s = futureTask2.get(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</div><div class="line">				<span class="keyword">if</span>(s !=<span class="keyword">null</span>)&#123;</div><div class="line">					System.out.println(<span class="string">"FutureTask2 output="</span>+s);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">catch</span>(TimeoutException e)&#123;</div><div class="line">				<span class="comment">//do nothing</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FutureTask1 output=pool-1-thread-1</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">Waiting <span class="keyword">for</span> FutureTask2 to complete</div><div class="line">FutureTask2 output=pool-1-thread-2</div><div class="line">Done</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring 自定义标签]]></title>
      <url>http://zsr.github.io/2016/08/22/Spring-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h2 id="Spring-自定义标签"><a href="#Spring-自定义标签" class="headerlink" title="Spring 自定义标签"></a>Spring 自定义标签</h2><p>步骤:</p>
<ol>
<li><p>编写java bean</p>
</li>
<li><p>编写xsd配置文件</p>
</li>
<li><p>编写spring.handlers和spring.schmas</p>
</li>
<li><p>编写applicationContext.xml</p>
</li>
<li><p>编写NamespaceHandler和BeanDefinitionParser</p>
</li>
</ol>
<h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-编写java-bean"><a href="#1-编写java-bean" class="headerlink" title="1. 编写java bean"></a>1. 编写java bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">  private String id;</div><div class="line">  private String name;</div><div class="line">  private String sex;</div><div class="line">  private int age;</div><div class="line"></div><div class="line">  public String getId() &#123;</div><div class="line">    return id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setId(String id) &#123;</div><div class="line">    this.id = id;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public String getName() &#123;</div><div class="line">    return name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setName(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public String getSex() &#123;</div><div class="line">    return sex;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setSex(String sex) &#123;</div><div class="line">    this.sex = sex;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public int getAge() &#123;</div><div class="line">    return age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setAge(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-定义一个XSD文件"><a href="#2-定义一个XSD文件" class="headerlink" title="2. 定义一个XSD文件"></a>2. 定义一个XSD文件</h4><p>META-INF/user-1.0.xsd文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;xsd:schema xmlns=&quot;http://zsr.github.io/schema/test&quot;</div><div class="line">  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">  xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">  targetNamespace=&quot;http://zsr.github.io/schema/test&quot;&gt;</div><div class="line"></div><div class="line">  &lt;xsd:import namespace=&quot;http://www.springframework.org/schema/beans&quot; /&gt;</div><div class="line">  &lt;xsd:import namespace=&quot;http://www.springframework.org/schema/tool&quot; /&gt;</div><div class="line"></div><div class="line">  &lt;xsd:annotation&gt;</div><div class="line">    &lt;xsd:documentation&gt;&lt;![CDATA[ Namespace support for the test]]&gt;&lt;/xsd:documentation&gt;</div><div class="line">  &lt;/xsd:annotation&gt;</div><div class="line"></div><div class="line">  &lt;xsd:element name=&quot;user&quot;&gt;</div><div class="line">    &lt;xsd:complexType&gt;</div><div class="line">      &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;</div><div class="line">            &lt;![CDATA[</div><div class="line">              Unique id</div><div class="line">            ]]&gt;</div><div class="line">          &lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;姓名&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;sex&quot; type=&quot;xsd:string&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;性别&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line"></div><div class="line">      &lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:int&quot;&gt;</div><div class="line">        &lt;xsd:annotation&gt;</div><div class="line">          &lt;xsd:documentation&gt;年龄&lt;/xsd:documentation&gt;</div><div class="line">        &lt;/xsd:annotation&gt;</div><div class="line">      &lt;/xsd:attribute&gt;</div><div class="line">    &lt;/xsd:complexType&gt;</div><div class="line">  &lt;/xsd:element&gt;</div><div class="line"></div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure>
<h4 id="3-新建spring-handlers，-spring-shcemas"><a href="#3-新建spring-handlers，-spring-shcemas" class="headerlink" title="3. 新建spring.handlers， spring.shcemas"></a>3. 新建spring.handlers， spring.shcemas</h4><p>在项目的META-INF目录下新建两个文件spring.handlers，和spring.shcemas.</p>
<ul>
<li>Spring.handlers</li>
</ul>
<p>在类org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver中已经写死了要取mapping的handlerMappingsLocation的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static finalString DEFAULT_HANDLER_MAPPINGS_LOCATION =&quot;META-INF/spring.handlers&quot;;</div></pre></td></tr></table></figure>
<p>spring.handlers内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.zsr.com/schema/test=com.zsr.spring.schema.MyNamespaceHandler</div></pre></td></tr></table></figure>
<ul>
<li>Spring.Schemas </li>
</ul>
<p>在org.springframework.beans.factory.xml.PluggableSchemaResolver这个类中<br>同样写死了位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static finalString DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;</div></pre></td></tr></table></figure>
<p>spring.schemas内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.zsr.com/schema/test/user-1.0.xsd=META-INF/user-1.0.xsd</div></pre></td></tr></table></figure>
<p>初始化的时候第一次调用的时候会调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation,this.classLoader)</div></pre></td></tr></table></figure>
<p>把所有的文件名包含的取出来放入map中。</p>
<h4 id="4-编写applicationContext-xml"><a href="#4-编写applicationContext-xml" class="headerlink" title="4. 编写applicationContext.xml"></a>4. 编写applicationContext.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:test=&quot;http://www.zsr.com/schema/test&quot;</div><div class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </div><div class="line">    http://www.zsr.com/schema/test </div><div class="line">    http://www.zsr.com/schema/test/user-1.0.xsd&quot;&gt;</div><div class="line"></div><div class="line">  &lt;test:user id=&quot;zsr&quot; name=&quot;zsr&quot; sex=&quot;male&quot; age=&quot;24&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h4 id="5-编写NamespaceHandler和BeanDefinitionParser"><a href="#5-编写NamespaceHandler和BeanDefinitionParser" class="headerlink" title="5. 编写NamespaceHandler和BeanDefinitionParser"></a>5. 编写NamespaceHandler和BeanDefinitionParser</h4><ul>
<li>NamespaceHandler</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.xml.NamespaceHandlerSupport;</div><div class="line"></div><div class="line">public class MyNamespaceHandler extends NamespaceHandlerSupport &#123;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void init() &#123;</div><div class="line">    registerBeanDefinitionParser(&quot;user&quot;, new UserBeanDefinitionParser());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BeanDefinitionParser</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zsr.spring.schema;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</div><div class="line">import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;</div><div class="line">import org.w3c.dom.Element;</div><div class="line"></div><div class="line">public class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser &#123;</div><div class="line"></div><div class="line">  protected static final String USER_ID = &quot;id&quot;;</div><div class="line">  protected static final String USER_NAME = &quot;name&quot;;</div><div class="line">  protected static final String USER_AGE = &quot;age&quot;;</div><div class="line">  protected static final String USER_SEX = &quot;sex&quot;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected Class&lt;?&gt; getBeanClass(Element element) &#123;</div><div class="line">    return User.class;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void doParse(Element element, BeanDefinitionBuilder builder) &#123;</div><div class="line">    String id = element.getAttribute(USER_ID);</div><div class="line">    String name = element.getAttribute(USER_NAME);</div><div class="line">    String sex = element.getAttribute(USER_SEX);</div><div class="line">    int age = Integer.parseInt(element.getAttribute(USER_AGE));</div><div class="line"></div><div class="line">    builder.addPropertyValue(USER_ID, id);</div><div class="line">    builder.addPropertyValue(USER_NAME, name);</div><div class="line">    builder.addPropertyValue(USER_SEX, sex);</div><div class="line">    builder.addPropertyValue(USER_AGE, age);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google MapReduce中文版]]></title>
      <url>http://zsr.github.io/2016/08/19/Google-MapReduce/</url>
      <content type="html"><![CDATA[<h2 id="Google-MapReduce中文版"><a href="#Google-MapReduce中文版" class="headerlink" title="Google MapReduce中文版"></a>Google MapReduce中文版</h2><pre><code>译者: alex
</code></pre><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于 key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有的具有相同中间key值的中间value值。现实世界中有很多满足上述处理模型的例子，本论文将详细描述这个模型。</p>
<p>MapReduce架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的 集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的 程序员有效利用分布式系统的丰富资源。</p>
<p>我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理 以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个 MapReduce程序在执行。</p>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法 用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图 结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的数据处理运算在概念上很容易理解。然而由 于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这 些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</p>
<p>为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、 数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。设计这个抽象模型的灵感来自Lisp和许多其他函数式语言的Map和Reduce的原 语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的“逻辑”记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用 MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的“再 次执行”（re-execution）功能，也提供了初级的容灾实现方案。</p>
<p>这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。</p>
<p>第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个经过裁剪的、适合我们的基于集群的计算环境的MapReduce实现。第四部分 描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在 Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。</p>
<h3 id="2、编程模型"><a href="#2、编程模型" class="headerlink" title="2、编程模型"></a>2、编程模型</h3><p>MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。</p>
<p>用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合。MapReduce库把所有具有相同中间key值I的中间value值集合在一起后传递给reduce函数。</p>
<p>用户自定义的Reduce函数接受一个中间key的值I和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小 的value值的集合。一般的，每次Reduce函数调用只产生0或1个输出value值。通常我们通过一个迭代器把中间value值提供给Reduce 函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。</p>
<h4 id="2-1、例子"><a href="#2-1、例子" class="headerlink" title="2.1、例子"></a>2.1、例子</h4><p>例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">map(String key, String value):</div><div class="line">    // key: document name</div><div class="line">    // value: document contents</div><div class="line">    for each word w in value:</div><div class="line">        EmitIntermediate(w, “1″);</div><div class="line">        </div><div class="line">reduce(String key, Iterator values):</div><div class="line">    // key: a word</div><div class="line">    // values: a list of counts</div><div class="line">    int result = 0;</div><div class="line">    for each v in values:</div><div class="line">        result += ParseInt(v);</div><div class="line">    Emit(AsString(result));</div></pre></td></tr></table></figure>
<p>Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。</p>
<p>另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce 函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。</p>
<h4 id="2-2、类型"><a href="#2-2、类型" class="headerlink" title="2.2、类型"></a>2.2、类型</h4><p>尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">map(k1,v1) -&gt;list(k2,v2)</div><div class="line"></div><div class="line">reduce(k2,list(v2)) -&gt;list(v2)</div></pre></td></tr></table></figure>
<p>比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。<br><strong>（alex注：原文中这个domain的含义不是很清楚，我参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，我把domain翻译成类型推导的域）</strong>。<br>我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。</p>
<h4 id="2-3、更多的例子"><a href="#2-3、更多的例子" class="headerlink" title="2.3、更多的例子"></a>2.3、更多的例子</h4><p>这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示：</p>
<ul>
<li>分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</li>
<li>计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</li>
<li>倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</li>
<li>每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机 名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索 词，输出一个最终的(主机名,检索词向量)。</li>
<li>倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</li>
<li>分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</li>
</ul>
<h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><p>MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。</p>
<p>本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括：</p>
<ul>
<li>1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。 </li>
<li>2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 （alex注：这里需要网络专家解释一下了） </li>
<li>3.集群中包含成百上千的机器，因此，机器故障是常态。 </li>
<li>4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 </li>
<li>5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。</li>
</ul>
<h4 id="3-1、执行概括"><a href="#3-1、执行概括" class="headerlink" title="3.1、执行概括"></a>3.1、执行概括</h4><p>通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使 用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p>
<p><img src="/images/GoogleMR3-1.jpg"></p>
<p>图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）： </p>
<ul>
<li><p>1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。 </p>
</li>
<li><p>2.这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。 </p>
</li>
<li><p>3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value pair，并缓存在内存中。 </p>
</li>
<li><p>4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p>
</li>
<li><p>5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 </p>
</li>
<li><p>6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p>
</li>
<li><p>7.当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p>
</li>
</ul>
<p>在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况 下，用户不需要将这R个输出文件合并成一个文件–他们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式 应用中使用。</p>
<h4 id="3-2、Master数据结构"><a href="#3-2、Master数据结构" class="headerlink" title="3.2、Master数据结构"></a>3.2、Master数据结构</h4><p>Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。</p>
<p>Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任 务，master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐 步递增的推送给那些正在工作的Reduce任务。</p>
<h4 id="3-3、容错"><a href="#3-3、容错" class="headerlink" title="3.3、容错"></a>3.3、容错</h4><p>因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。</p>
<ul>
<li><strong>worker故障:</strong></li>
</ul>
<p>master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，master将把这个 worker标记为失效。所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样 的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</p>
<p>当worker故障时，由于已经完成的Map任务的输出存储在这台机器上，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。</p>
<p>当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个“重新执行”的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。</p>
<p>MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起 80台机器在几分钟内不可访问了，MapReduce master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。</p>
<ul>
<li><strong>master失败 </strong></li>
</ul>
<p>一个简单的解决办法是让master周期性的将上面描述的数据结构 （alex注：指3.2节）的 写入磁盘，即检查点（checkpoint）。如果这个master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个 master进程。然而，由于只有一个master进程，master失效后再恢复是比较麻烦的，因此我们现在的实现是如果master失效，就中止 MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</p>
<ul>
<li><strong>在失效方面的处理机制</strong></li>
</ul>
<p>当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p>
<p>我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任 务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包 含R个临时文件名的完成消息给master。如果master从一个已经完成的Map任务再次接收到到一个完成消息，master将忽略这个消息；否 则，master将这R个文件的名字记录在数据结构里。</p>
<p>当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名 操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。</p>
<p>使用MapReduce模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的Map和Reduce操作是确定性的，而且存在这样的一个 事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map或/和Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使 用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个Reduce任务R2的输出也许符合一个 不同的非确定顺序程序执行产生的R2的输出。</p>
<p>考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。当e(R1)读取了由M一次执行产生的输出，而e(R2)读取了由M的另一次执行产生的输出，导致了较弱的失效处理。</p>
<h4 id="3-4、存储位置"><a href="#3-4、存储位置" class="headerlink" title="3.4、存储位置"></a>3.4、存储位置</h4><p>在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带 宽。GFS把每个文件按64MB一个Block分隔，每个Block保存在多台机器上，环境中就存放了多份拷贝(一般是3个拷贝)。MapReduce的 master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败 了，master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的 worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗 非常少的网络带宽。</p>
<h4 id="3-5、任务粒度"><a href="#3-5、任务粒度" class="headerlink" title="3.5、任务粒度"></a>3.5、任务粒度</h4><p>如前所述，我们把Map拆分成了M个片段、把Reduce拆分成R个片段执行。理想情况下，M和R应当比集群中worker的机器数量要多得 多。在每台worker机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量Map任务都可以 分布到所有其他的worker机器上去执行。</p>
<p>但是实际上，在我们的具体实现中对M和R的取值都有一定的客观限制，因为master必须执行O(M+R)次调度，并且在内存中保存O(M <em> R)个状态（对影响内存使用的因素还是比较小的：O(M </em> R)块状态，大概每对Map任务/Reduce任务1个字节就可以了）。</p>
<p>更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得 每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的 worker机器数量的小的倍数。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。</p>
<h4 id="3-6、备用任务"><a href="#3-6、备用任务" class="headerlink" title="3.6、备用任务"></a>3.6、备用任务</h4><p>影响一个MapReduce的总执行时间最通常的因素是“落伍者”：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现“落伍者”的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经 常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其他的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。</p>
<p>我们有一个通用的机制来减少“落伍者”出现的情况。当一个MapReduce操作接近完成的时候，master调度备用（backup）任务进 程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任 务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的 总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。</p>
<h3 id="4、技巧"><a href="#4、技巧" class="headerlink" title="4、技巧"></a>4、技巧</h3><p>虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。</p>
<h4 id="4-1、分区函数"><a href="#4-1、分区函数" class="headerlink" title="4.1、分区函数"></a>4.1、分区函数</h4><p>MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行 分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用 “hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</p>
<h4 id="4-2、顺序保证"><a href="#4-2、顺序保证" class="headerlink" title="4.2、顺序保证"></a>4.2、顺序保证</h4><p>我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p>
<h4 id="4-3、Combiner函数"><a href="#4-3、Combiner函数" class="headerlink" title="4.3、Combiner函数"></a>4.3、Combiner函数</h4><p>在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的 词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录。所 有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选 的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p>
<p>Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。 Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而 Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。</p>
<p>部分的合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用combiner函数的例子。</p>
<h4 id="4-4、输入和输出的类型"><a href="#4-4、输入和输出的类型" class="headerlink" title="4.4、输入和输出的类型"></a>4.4、输入和输出的类型</h4><p>MapReduce库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必 须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一 个简单的Reader接口实现就能够支持一个新的输入类型。</p>
<p>Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。</p>
<p>类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</p>
<h4 id="4-5、副作用"><a href="#4-5、副作用" class="headerlink" title="4.5、副作用"></a>4.5、副作用</h4><p>在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种“副作用”变成原子的和幂等的 <strong>（alex注：幂等的指一个总是产生相同结果的数学运算）</strong>。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。</p>
<p>如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过程中，这个限制还没有给我们带来过麻烦。</p>
<h4 id="4-6、跳过损坏的记录"><a href="#4-6、跳过损坏的记录" class="headerlink" title="4.6、跳过损坏的记录"></a>4.6、跳过损坏的记录</h4><p>有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做 法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里边，而我们手 头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种执行模式，在 这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</p>
<p>每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将 用“最后一口气”通过UDP包向master发送处理的最后一条记录的序号。当master看到在处理某条特定记录不止失败一次时，master就标志着 条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。</p>
<h4 id="4-7、本地执行"><a href="#4-7、本地执行" class="headerlink" title="4.7、本地执行"></a>4.7、本地执行</h4><p>调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的 执行位置是由master进行动态调度的，这又大大增加了调试的难度。为了简化调试、profile和小规模测试，我们开发了一套MapReduce库的 本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序的执行。用户可以控制MapReduce操作的执行， 可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。</p>
<h4 id="4-8、状态信息"><a href="#4-8、状态信息" class="headerlink" title="4.8、状态信息"></a>4.8、状态信息</h4><p>master使用嵌入式的HTTP服务器（如Jetty）显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的 进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的 stderr和stdout文件的链接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用来分析什么时候计 算执行的比预期的要慢。</p>
<p>另外，处于最顶层的状态页面显示了哪些worker失效了，以及他们失效的时候正在运行的Map和Reduce任务。这些信息对于调试用户代码中的bug很有帮助。</p>
<h4 id="4-9、计数器"><a href="#4-9、计数器" class="headerlink" title="4.9、计数器"></a>4.9、计数器</h4><p>MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。</p>
<p>为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Counter* uppercase;</div><div class="line">uppercase = GetCounter(“uppercase”);</div><div class="line">map(String name, String contents):</div><div class="line"> for each word w in contents:</div><div class="line">  if (IsCapitalized(w)):</div><div class="line">   uppercase-&gt;Increment();</div><div class="line">  EmitIntermediate(w, “1″);</div></pre></td></tr></table></figure>
<p>这些计数器的值周期性的从各个单独的worker机器上传递给master（附加在ping的应答包中传递）。master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。</p>
<p>计数器当前的值也会显示在master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p>
<p>有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。</p>
<p>计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保输出的key value pair精确的等于输入的key value pair，或者处理的German文档数量在处理的整个文档数量中属于合理范围。</p>
<h3 id="5、性能"><a href="#5、性能" class="headerlink" title="5、性能"></a>5、性能</h3><p>本节我们用在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。</p>
<p>这两个程序在大量的使用MapReduce的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分的用户感兴趣的数据。</p>
<h4 id="5-1、集群配置"><a href="#5-1、集群配置" class="headerlink" title="5.1、集群配置"></a>5.1、集群配置</h4><p>所有这些程序都运行在一个大约由1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有 100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络来回时间小于1毫秒。</p>
<p>在4GB内存里，大概有1-1.5G用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。</p>
<h4 id="5-2、GREP"><a href="#5-2、GREP" class="headerlink" title="5.2、GREP"></a>5.2、GREP</h4><p>这个分布式的grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。</p>
<p><img src="/images/GoogleMR5-2.jpg"></p>
<p>图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当 1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程 从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各个worker机器上的时间、 等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。</p>
<h4 id="5-3、排序"><a href="#5-3、排序" class="headerlink" title="5.3、排序"></a>5.3、排序</h4><p>排序程序处理10的10次方个100个字节组成的记录（大概1TB的数据）。这个程序模仿TeraSort benchmark[10]。</p>
<p>排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作 为中间的key/value pair值输出。我们使用了一个内置的恒等函数作为Reduce操作函数。这个函数把中间的key/value pair值不作任何改变输出。最终排序结果输出到两路复制的GFS文件系统（也就是说，程序输出2TB的数据）。</p>
<p>如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。</p>
<p>在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。</p>
<p><img src="/images/GoogleMR5-3.jpg"></p>
<p>图三（a）显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务完 成之后，即大约200秒之后迅速滑落到0。值得注意的是，排序程序输入数据读取速度小于分布式grep程序。这是因为排序程序的Map任务花了大约一半的 处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式grep程序的中间结果输出几乎可以忽略不计。</p>
<p>左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动了。图示的第一 个高峰是启动了第一批大概1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任 务）。排序程序运行大约300秒后，第一批启动的Reduce任务有些完成了，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。</p>
<p>左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始写入磁盘之间有一个小的延时，这是因为 worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运 算消耗了891秒。这个速度和TeraSort benchmark[18]的最高纪录1057秒相差不多。</p>
<p>还有一些值得注意的现象：输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份（我们使用了2路的GFS文件 系统，写入复制节点的原因是为了保证数据可靠性和可用性）。我们把输出数据写入到两个复制节点的原因是因为这是底层文件系统的保证数据可靠性和可用性的实 现机制。如果底层文件系统使用类似容错编码<a href="erasure coding">14</a>的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低网络带宽的使用。</p>
<h4 id="5-4、高效的backup任务"><a href="#5-4、高效的backup任务" class="headerlink" title="5.4、高效的backup任务"></a>5.4、高效的backup任务</h4><p>图三（b）显示了关闭了备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了输出数据写磁盘的动作在时间上拖了一个很长的尾巴，而 且在这段时间里，几乎没有什么写入动作。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了 1283秒，多了44%的执行时间。</p>
<h4 id="5-5、失效的机器"><a href="#5-5、失效的机器" class="headerlink" title="5.5、失效的机器"></a>5.5、失效的机器</h4><p>在图三（c）中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。</p>
<p>图三（c）显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被 kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。</p>
<h3 id="6、经验"><a href="#6、经验" class="headerlink" title="6、经验"></a>6、经验</h3><p>我们在2003年1月完成了第一个版本的MapReduce库，在2003年8月的版本有了显著的增强，这包括了输入数据本地优化、 worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在 Google内部各个领域得到广泛应用，包括：</p>
<ul>
<li>大规模机器学习问题</li>
<li>Google News和Froogle产品的集群问题</li>
<li>从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</li>
<li>从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</li>
<li>大规模的图形计算。</li>
</ul>
<p><img src="/images/GoogleMR6.jpg"></p>
<p>图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004 年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时时间内写出一个简单的程序，这个简单的 程序能够在上千台机器的组成的集群上做大规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用MapReduce库，可以让完全没有分布式和/ 或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</p>
<p><img src="/images/GoogleMR6-2.jpg"></p>
<p>在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。</p>
<h4 id="6-1、大规模索引"><a href="#6-1、大规模索引" class="headerlink" title="6.1、大规模索引"></a>6.1、大规模索引</h4><p>到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档原始内容 （alex注：raw contents，我认为就是网页中的剔除html标记后的内容、pdf和word等有格式文档中提取的文本内容等）的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：</p>
<ul>
<li><p>实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大概700行代码。</p>
</li>
<li><p>MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以期减少数据传递的额外消耗。概念 上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用 MapReduce的新系统上，这样的更改只需要花几天时间就可以了。</p>
</li>
<li><p>索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</p>
</li>
</ul>
<h3 id="7、相关工作"><a href="#7、相关工作" class="headerlink" title="7、相关工作"></a>7、相关工作</h3><p>很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完[6，9，13]。MapReduce可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。</p>
<p>Bulk Synchronous Programming[17]和一些MPI原语[11]提供了更高级别的并行处理抽象，可以更容易写出并行处理的程序。MapReduce和这些系统的 关键不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。</p>
<p>我们数据本地优化策略的灵感来源于active disks[12,15]等技术，在active disks中，计算任务是尽量推送到数据存储的节点处理 <strong>（alex注：即靠近数据源处理）</strong>，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。</p>
<p>我们的备用任务机制和Charlotte System[3]提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。</p>
<p>MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor[16]是一样。</p>
<p>MapReduce库的排序机制和NOW-Sort[1]的操作上很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备 MapReduce库广泛的实用性。</p>
<p>River[2]提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不 对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce 库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的“小”任务。这些任务在可用的worker集群上动态的调度， 这样快速的worker就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度备用任务，缩短在硬件配置不均衡的情况下缩小整 个操作完成的时间（比如有的机器性能差、或者机器被某些操作阻塞了）。</p>
<p>BAD-FS[5]采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。</p>
<ul>
<li><p>（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。</p>
</li>
<li><p>（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。</p>
</li>
</ul>
<p>TACC[7]是一个用于简化构造高可用性网络服务的系统。和MapReduce一样，它也依靠重新执行机制来实现的容错处理。</p>
<h3 id="8、结束语"><a href="#8、结束语" class="headerlink" title="8、结束语"></a>8、结束语</h3><p>MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，由于MapReduce封装了并行处 理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得MapReduce库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员 而言；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用 来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署运行的MapReduce。这个 实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用来解决Google遇到的其他很多需要大量计算的问题。</p>
<p>我们也从MapReduce开发过程中学到了不少东西。首先，约束编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带 宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节 约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响<strong>（alex注：即硬件配置的不平衡）</strong>，同时解决了由于机器失效导致的数据丢失问题。</p>
<h3 id="9、参考资料"><a href="#9、参考资料" class="headerlink" title="9、参考资料"></a>9、参考资料</h3><p>[1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau,David E. Culler, Joseph M. Hellerstein, and David A. Patterson.High-performance sorting on networks of workstations.In Proceedings of the 1997 ACM SIGMOD InternationalConference on Management of Data, Tucson,Arizona, May 1997.<br>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, NoahTreuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River:Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10.22, Atlanta, Georgia, May 1999.<br>[3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996. [4] Luiz A. Barroso, Jeffrey Dean, and Urs H¨olzle. Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22.28, April 2003.<br>[5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004.<br>[6] Guy E. Blelloch. Scans as primitive parallel operations.IEEE Transactions on Computers, C-38(11), November 1989.<br>[7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78. 91, Saint-Malo, France, 1997.<br>[8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29.43, Lake George, New York, 2003. To appear in OSDI 2004 12<br>[9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401.408. Springer-Verlag, 1996.<br>[10] Jim Gray. Sort benchmark home page. <a href="http://research.microsoft.com/barc/SortBenchmark/" target="_blank" rel="external">http://research.microsoft.com/barc/SortBenchmark/</a>.<br>[11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA, 1999.<br>[12] L. Huston, R. Sukthankar, R.Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004 USENIX File and Storage Technologies FAST Conference, April 2004.<br>[13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831.838, 1980.<br>[14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of the ACM, 36(2):335.348, 1989.<br>[15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68.74, June 2001.<br>[16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004.<br>[17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103.111, 1997.<br>[18] Jim Wyllie. Spsort: How to sort a terabyte quickly. <a href="http://alme1.almaden.ibm.com/cs/spsort.pdf" target="_blank" rel="external">http://alme1.almaden.ibm.com/cs/spsort.pdf</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google GFS文件系统]]></title>
      <url>http://zsr.github.io/2016/08/19/Google-GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h1 id="The-Google-File-System中文版"><a href="#The-Google-File-System中文版" class="headerlink" title="The Google File System中文版"></a>The Google File System中文版</h1><p>译者：alex</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们设计并实现了Google GFS文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。</p>
<p>虽然GFS的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础 的，不管现在还是将来，GFS和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计 思路。</p>
<p>GFS完全满足了我们对存储的需求。GFS作为存储平台已经被广泛的部署在Google内部，存储我们的服务产生和处理的数据，同时还用于那些 需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百TB的存储空间，同时为数百个客户机服务。</p>
<p>在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。</p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>为了满足Google迅速增长的数据处理需求，我们设计并实现了Google文件系统(Google File System – GFS)。GFS与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用 的负载情况和技术环境的观察的影响，不管现在还是将来，GFS和早期文件系统的假设都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择， 衍生出了完全不同的设计思路。</p>
<ul>
<li><p>首先，组件失效被认为是常态事件，而不是意外事件。GFS包括几百甚至几千台普通的廉价设备组装的存储机器，同时被相当数量的客户机访问。 GFS组件的数量和质量导致在事实上，任何给定时间内都有可能发生某些组件无法工作，某些组件无法从它们目前的失效状态中恢复。我们遇到过各种各样的问 题，比如应用程序bug、操作系统的bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗 余以及自动恢复的机制必须集成在GFS中。</p>
</li>
<li><p>其次，以通常的标准衡量，我们的文件非常巨大。数GB的文件非常普遍。每个文件通常都包含许多应用程序对象，比如web文档。当我们经常需要处 理快速增长的、并且由数亿个对象构成的、数以TB的数据集时，采用管理数亿个KB大小的小文件的方式是非常不明智的，尽管有些文件系统支持这样的管理方 式。因此，设计的假设条件和参数，比如I/O操作和Block的尺寸都需要重新考虑。</p>
</li>
<li><p>第三，绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。对文件的随机写入操作在实际中几乎不存在。一旦写完之后，对文 件的操作就只有读，而且通常是按顺序读。大量的数据符合这些特性，比如：数据分析程序扫描的超大的数据集；正在运行的应用程序生成的连续的数据流；存档的 数据；由一台机器生成、另外一台机器处理的中间数据，这些中间数据的处理可能是同时进行的、也可能是后续才处理的。对于这种针对海量文件的访问模式，客户 端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。</p>
</li>
<li><p>第四，应用程序和文件系统API的协同设计提高了整个系统的灵活性。比如，我们放松了对GFS一致性模型的要求，这样就减轻了文件系统对应用程 序的苛刻要求，大大简化了GFS的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一 致性。本文后面还有对这些问题的细节的详细讨论。</p>
</li>
</ul>
<p>Google已经针对不同的应用部署了多套GFS集群。最大的一个集群拥有超过1000个存储节点，超过300TB的硬盘空间，被不同机器上的数百个客户端连续不断的频繁访问。 </p>
<h3 id="2-设计概述"><a href="#2-设计概述" class="headerlink" title="2 设计概述"></a>2 设计概述</h3><h4 id="2-1-设计预期"><a href="#2-1-设计预期" class="headerlink" title="2.1 设计预期"></a>2.1 设计预期</h4><p>在设计满足我们需求的文件系统时候，我们的设计目标既有机会、又有挑战。之前我们已经提到了一些需要关注的关键点，这里我们将设计的预期目标的细节展开讨论。</p>
<ul>
<li><p>系统由许多廉价的普通组件组成，组件失效是一种常态。系统必须持续监控自身的状态，它必须将组件失效作为一种常态，能够迅速地侦测、冗余并恢复失效的组件。</p>
</li>
<li><p>系统存储一定数量的大文件。我们预期会有几百万文件，文件的大小通常在100MB或者以上。数个GB大小的文件也是普遍存在，并且要能够被有效的管理。系统也必须支持小文件，但是不需要针对小文件做专门的优化。</p>
</li>
<li><p>系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。大规模的流式读取通常一次读取数百KB的数据，更常见的是一次读取 1MB甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。小规模的随机读取通常是在文件某个随机的位置读取几个KB数 据。如果应用程序对性能非常关注，通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取，这样就避免了在文件中前后来回的移动读取位置。</p>
</li>
<li><p>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。一般情况下，每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。系统支持小规模的随机位置写入操作，但是可能效率不彰。</p>
</li>
<li><p>系统必须高效的、行为定义明确的实现多客户端并行追加数据到同一个文件里的语意。我们的文件通常被用于”生产者-消费者“队列，或者其它多路文件合并操作。通常会有数百个生产者，每个生产者进 程运行在一台机器上，同时对一个文件进行追加操作。使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的。文件可以在稍后读取，或者是消费者在 追加的操作的同时读取文件。</p>
</li>
<li><p>高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。</p>
</li>
</ul>
<h4 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h4><p>GFS提供了一套类似传统文件系统的API接口函数，虽然并不是严格按照POSIX等标准API的形式实现的。文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p>
<p>另外，GFS提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追 加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及”生产者-消费者”队列非常有用，多个客户端可以在不需要额外的同步锁 定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的。快照和记录追加操作将在3.4和3.3节分别讨论。</p>
<h4 id="2-3-架构"><a href="#2-3-架构" class="headerlink" title="2.3 架构"></a>2.3 架构</h4><p>一个GFS集群包含一个单独的Master节点<strong>(alex注：这里的一个单 独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件。后面我们还会提到Master节点复制，因此，为了理解方便，我们把 Master节点视为一个逻辑上的概念，一个逻辑的Master节点包括两台物理主机，即两台Master服务器）</strong>、多台 Chunk服务器，并且同时被多个客户端访问，如图1所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务 进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。</p>
<p><img src="/images/GFS2-3.jpg"></p>
<p>GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，Master服务器会给每个Chunk分配一个不变的、全球唯一的 64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。 出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<p>Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。Master节点还管理着系统范围内的活动，比如，Chunk租用管理 <strong>(alex注：BDB也有关于lease的描述，不知道是否相同)</strong>、孤儿Chunk <strong>(alex注：orphaned chunks)</strong>的回收、以及Chunk在Chunk服务器之间的迁移。Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p>
<p>GFS客户端代码以库的形式被链接到客户程序里。客户端代码实现了GFS文件系统的API接口函数、应用程序与Master节点和Chunk服 务器通讯、以及对数据进行读写操作。客户端和Master节点的通信只获取元数据，所有的数据操作都是由客户端直接和Chunk服务器进行交互的。我们不 提供POSIX标准的API的功能，因此，GFS API调用不需要深入到Linux vnode级别。</p>
<p>无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要 么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存 文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p>
<h4 id="2-4-单一Master节点"><a href="#2-4-单一Master节点" class="headerlink" title="2.4 单一Master节点"></a>2.4 单一Master节点</h4><p>单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另 外，我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。客户端并不通过Master节点读写文件数据。反之，客户端向 Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p>
<p>我们利用图1解释一下一次简单读取的流程。首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索 引。然后，它把文件名和Chunk索引发送给Master节点。Master节点将相应的Chunk标识和副本的位置信息发还给客户端。客户端用文件名和 Chunk索引作为key缓存这些信息。</p>
<p>之后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了Chunk的标识和字节范围。在对这个Chunk的后续读取操作中， 客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个Chunk信 息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避 免了客户端和Master节点未来可能会发生的几次通讯。</p>
<h4 id="2-5-Chunk尺寸"><a href="#2-5-Chunk尺寸" class="headerlink" title="2.5 Chunk尺寸"></a>2.5 Chunk尺寸</h4><p>Chunk的大小是关键的设计参数之一。我们选择了64MB，这个尺寸远远大于一般文件系统的Block size。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成 的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。</p>
<p>选择较大的Chunk尺寸有几个重要的优点。首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以 获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续 读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信 息。其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。第 三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部 放在内存中带来的额外的好处。</p>
<p>另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷。小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户 端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。在实际应用中，由于我们的程序通常是连续的读取包含多个 Chunk的大文件，热点还不是主要的问题。</p>
<p>然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件， 之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。我们通过使用更大 的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它 客户端读取数据。</p>
<h4 id="2-6-元数据"><a href="#2-6-元数据" class="headerlink" title="2.6 元数据"></a>2.6 元数据</h4><p>Master服务器 <strong>（alex注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）</strong>存储3种主要类型的元数据，包括：文件和Chunk的命名空间、文件和Chunk的对应关系、每个Chunk副本的存放地点。所有的元数据都保存在 Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件 中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器 的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或 者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p>
<h5 id="2-6-1-内存中的数据结构"><a href="#2-6-1-内存中的数据结构" class="headerlink" title="2.6.1 内存中的数据结构"></a>2.6.1 内存中的数据结构</h5><p>因为元数据保存在内存中，所以Master服务器的操作速度非常快。并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部 状态信息。这种周期性的状态扫描也用于实现Chunk垃圾收集、在Chunk服务器失效的时重新复制数据、通过Chunk的迁移实现跨Chunk服务器的 负载均衡以及磁盘使用状况统计等功能。4.3和4.4章节将深入讨论这些行为。</p>
<p>将元数据全部保存在内存中的方法有潜在问题：Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。但是在实际 应用中，这并不是一个严重的问题。Master服务器只需要不到64个字节的元数据就能够管理一个64MB的Chunk。由于大多数文件都包含多个 Chunk，因此绝大多数Chunk都是满的，除了文件的最后一个Chunk是部分填充的。同样的，每个文件的在命名空间中的数据大小通常在64字节以 下，因为保存的文件名是用前缀压缩算法压缩过的。</p>
<p>即便是需要支持更大的文件系统，为Master服务器增加额外内存的费用是很少的，而通过增加有限的费用，我们就能够把元数据全部保存在内存里，增强了系统的简洁性、可靠性、高性能和灵活性。</p>
<h5 id="2-6-2-Chunk位置信息"><a href="#2-6-2-Chunk位置信息" class="headerlink" title="2.6.2 Chunk位置信息"></a>2.6.2 Chunk位置信息</h5><p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服 务器以获取这些信息。Master服务器能够保证它持有的信息始终是最新的，因为它控制了所有的Chunk位置的分配，而且通过周期性的心跳信息监控 Chunk服务器的状态。</p>
<p>最初设计时，我们试图把Chunk的位置信息持久的保存在Master服务器上，但是后来我们发现在启动的时候轮询Chunk服务器，之后定期轮询 更新的方式更简单。这种设计简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步 的问题。在一个拥有数百台服务器的集群中，这类事件会频繁的发生。</p>
<p>可以从另外一个角度去理解这个设计决策：只有Chunk服务器才能最终确定一个Chunk是否在它的硬盘上。我们从没有考虑过在Master服务器 上维护一个这些信息的全局视图，因为Chunk服务器的错误可能会导致Chunk自动消失(比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命 名一个Chunk服务器。</p>
<h5 id="2-6-3-操作日志"><a href="#2-6-3-操作日志" class="headerlink" title="2.6.3 操作日志"></a>2.6.3 操作日志</h5><p>操作日志包含了关键的元数据变更历史记录。这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线<strong>（alex注：也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的LSN）</strong>。文件和Chunk，连同它们的版本(参考4.5节)，都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。否则，即使Chunk本身没有出现任 何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程 机器的硬盘后，才会响应客户端的操作请求。Master服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p>
<p>Master服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短Master启动的时间，我们必须使日志足够小 <strong>（alex注：即重演系统操作的日志量尽量的少）</strong>。Master服务器在日志增长到一定量时对系统状态做一次Checkpoint <strong>(alex注：Checkpoint是一种行为，一种对数据库状态作一次快照的行为)</strong>，将所有的状态数据写入一个Checkpoint文件 <strong>（alex注：并删除之前的日志文件）</strong>。 在灾难恢复的时候，Master服务器就通过从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件就能够恢复系统。Checkpoint文件以压缩B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>
<p>由于创建一个Checkpoint文件需要一定的时间，所以Master服务器的内部状态被组织为一种格式，这种格式要确保在Checkpoint 过程中不会阻塞正在进行的修改操作。Master服务器使用独立的线程切换到新的日志文件和创建新的Checkpoint文件。新的Checkpoint 文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个Checkpoint文件需要1分钟左右的时间。创建完成后，Checkpoint 文件会被写入在本地和远程的硬盘里。</p>
<p>Master服务器恢复只需要最新的Checkpoint文件和后续的日志文件。旧的Checkpoint文件和日志文件可以被删除，但是为了应对灾难性的故障<strong>（alex注：catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件）</strong>，我们通常会多保存一些历史文件。Checkpoint失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的Checkpoint文件。</p>
<h4 id="2-7-一致性模型"><a href="#2-7-一致性模型" class="headerlink" title="2.7 一致性模型"></a>2.7 一致性模型</h4><p>GFS支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论GFS的一致 性的保障机制，以及对应用程序的意义。我们也着重描述了GFS如何管理这些一致性保障机制，但是实现的细节将在本论文的其它部分讨论。</p>
<h5 id="2-7-1-GFS一致性保障机制"><a href="#2-7-1-GFS一致性保障机制" class="headerlink" title="2.7.1 GFS一致性保障机制"></a>2.7.1 GFS一致性保障机制</h5><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由Master节点的控制：命名空间锁提供了原子性和正确性（4.1章）的保障；Master节点的操作日志定义了这些操作在全局的顺序（2.6.3章）。</p>
<p><img src="/images/GFS2-7.jpg"></p>
<p>数据修改后文件region<strong>（alex注：region这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）</strong>的状态取决于操作的类型、成功与否、以及是否同步修改。表1总结了各种操作的结果。如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文 件region是“一致的”；如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“已定义 的”。当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的region就是已定义的（隐含了一致性）：所有的客户端都可 以看到写入的内容。并行修改操作成功完成之后，region处于一致的、未定义的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的 数据。通常情况下，文件region内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个region处于不一致状态（同时也是未定义 的）：不同的客户在不同的时间会看到不同的数据。后面我们将描述应用如何区分已定义和未定义的region。应用程序没有必要再去细分未定义region 的不同类型。</p>
<p>数据修改操作分为写入或者记录追加两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由GFS选择的（3.3章） <strong>（alex注：这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由GFS自己计算）。</strong> （相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS返回给客户端一个偏移量，表示了包含了写入记录的、已定义的region的起点。另 外，GFS可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件region被认定是不一致的，这些数据通常比用户数据小的多。</p>
<p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保 上述行为：</p>
<ul>
<li>（a） 对Chunk的所有副本的修改操作顺序一致（3.1章）</li>
<li>（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机（4.5章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系 统尽快回收。</li>
</ul>
<p>由于Chunk位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。在缓存的超时时间和文件下一次被打开的时 间之间存在一个时间窗，文件再次被打开后会清除缓存中与该文件有关的所有Chunk位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一 个失效的副本通常返回一个提前结束的Chunk而不是过期的数据。当一个Reader <strong>（alex注：本文中将用到两个专有名词，Reader和Writer，分别表示执行GFS读取和写入操作的程序）</strong>重新尝试并联络Master服务器时，它就会立刻得到最新的Chunk位置信息。</p>
<p>即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS通过Master服务器和所有Chunk服务器的定期“握手” 来找到失效的Chunk服务器，并且使用Checksum来校验数据是否损坏（5.2章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3 章）。只有当一个Chunk的所有副本在GFS检测到错误并采取应对措施之前全部丢失，这个Chunk才会不可逆转的丢失。在一般情况下GFS的反应时间 <strong>（alex注：指Master节点检测到错误并采取应对措施）</strong>是几分钟。即使在这种情况下，Chunk也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p>
<h5 id="2-7-2-程序的实现"><a href="#2-7-2-程序的实现" class="headerlink" title="2.7.2 程序的实现"></a>2.7.2 程序的实现</h5><p>使用GFS的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。</p>
<p>在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生 成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作Checkpoint，记录成功写入了多少数据。 Checkpoint文件可以包含程序级别的校验和。Readers仅校验并处理上个Checkpoint之后产生的文件region，这些文件 region的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。 Checkpoint可以让Writer以渐进的方式重新开始，并且可以防止Reader处理已经被成功写入，但是从应用程序的角度来看还并未完成的数 据。</p>
<p>我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的 “至少一次追加”的特性保证了Writer的输出。Readers使用下面的方法来处理偶然性的填充数据和重复内容。Writers在每条写入的记录中都 包含了额外的信息，例如Checksum，用来验证它的有效性。Reader可以利用Checksum识别和抛弃额外的填充数据和记录片段。如果应用不能 容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象， 例如web文档。这些记录I/O功能 <strong>（alex注：These functionalities for record I/O）</strong>（除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于Google内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到Reader了。</p>
<h3 id="3-系统交互"><a href="#3-系统交互" class="headerlink" title="3. 系统交互"></a>3. 系统交互</h3><p>我们在设计这个系统时，一个重要的原则是最小化所有操作和Master节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master服务器和Chunk服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。</p>
<h4 id="3-1-租约（lease）和变更顺序"><a href="#3-1-租约（lease）和变更顺序" class="headerlink" title="3.1 租约（lease）和变更顺序"></a>3.1 租约（lease）和变更顺序</h4><p><strong>（alex注：lease是数据库中的一个术语）</strong></p>
<p>变更是一个会改变Chunk内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在Chunk的所有副本上执行。我们使用租约 （lease）机制来保持多个副本间变更顺序的一致性。Master节点为Chunk的一个副本建立一个租约，我们把这个副本叫做主Chunk。主 Chunk对Chunk的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由Master节点选择的租约的 顺序决定，然后由租约中主Chunk分配的序列号决定。</p>
<p>设计租约机制的目的是为了最小化Master节点的管理负担。租约的初始超时设置为60秒。不过，只要Chunk被修改了，主Chunk就可以 申请更长的租期，通常会得到Master节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在Master节点和Chunk服务 器之间的心跳消息中来传递。有时Master节点会试图提前取消租约（例如，Master节点想取消在一个已经被改名的文件上的修改操作）。即使 Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。</p>
<p><img src="/images/GFS3-1.jpg"></p>
<ul>
<li><p>1.客户机向Master节点询问哪一个Chunk服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</p>
</li>
<li><p>2.Master节点将主Chunk的标识符以及其它副本（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便 后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</p>
</li>
<li><p>3.客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的内部LRU缓存中，一直到数据被使 用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会 哪个Chunk服务器保存了主Chunk。3.2章节会进一步讨论这点。</p>
</li>
<li><p>4.当所有的副本都确认接收到了数据，客户机发送写请求到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所 有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中 <strong>（alex注：也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”）。</strong></p>
</li>
<li><p>5.主Chunk把写请求传递到所有的二级副本。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</p>
</li>
<li><p>6.所有的二级副本回复主Chunk，它们已经完成了操作。</p>
</li>
<li><p>7.主Chunk服务器 <strong>（alex注：即主Chunk所在的Chunk服务器）</strong>回 复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk 上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失 败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</p>
</li>
</ul>
<p>如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流 程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分 解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状 态。</p>
<h4 id="3-2-数据流"><a href="#3-2-数据流" class="headerlink" title="3.2 数据流"></a>3.2 数据流</h4><p>为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主Chunk、然后再到所有二级副本的同时，数据以管道的方式， 顺序的沿着一个精心选择的Chunk服务器链推送。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p>
<p>为了充分利用每台机器的带宽，数据沿着一个Chunk服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽。</p>
<p>为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch最有可能出现类似问题），每台机器都尽量的在网络拓扑中选择一台 还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把数据从Chunk服务器S1推送到S4。它把数据推送到最近的Chunk服务器 S1。S1把数据推送到S2，因为S2和S4中最接近的机器是S2。同样的，S2把数据传递给S3和S4之间更近的机器，依次类推推送下去。我们的网络拓 扑非常简单，通过IP地址就可以计算出节点的“距离”。</p>
<p>最后，我们利用基于TCP连接的、管道式数据推送方式来最小化延迟。Chunk服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我 们帮助很大，因为我们采用全双工的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送B字节的数据到R个副本的理想时 间是 B/T+RL ，T是网络的吞吐量，L是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是100Mbps（T），L将远小于1ms。因此，1MB的数据在理 想情况下80ms左右就能分发出去。</p>
<h4 id="3-3-原子的记录追加"><a href="#3-3-原子的记录追加" class="headerlink" title="3.3 原子的记录追加"></a>3.3 原子的记录追加</h4><p>GFS提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个region的并行写入操作不 是串行的：region尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。GFS保证至少有一次原子的写入操作 成功执行（即写入一个顺序的byte流），写入的数据追加到GFS指定的偏移位置上，之后GFS返回这个偏移量给客户机。这类似于在Unix操作系统编程 环境中，对以O_APPEND模式打开的文件，多个并发写操作在没有竞态条件时的行为。</p>
<p>记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的 文件写入操作，客户机需要额外的复杂、昂贵的同步机制，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列 系统，或者是合并了来自多个客户机的数据的结果文件。</p>
<p>记录追加是一种修改操作，它也遵循3.1节描述的控制流程，除了在主Chunk有些额外的控制逻辑。客户机把数据推送给文件最后一个Chunk 的所有副本，之后发送请求给主Chunk。主Chunk会检查这次记录追加操作是否会使Chunk超过最大尺寸（64MB）。如果超过了最大尺寸，主 Chunk首先将当前Chunk填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个Chunk重新进行记录追加操作。（记 录追加的数据大小严格控制在Chunk最大尺寸的1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）通常情况下追加的记录不超过 Chunk的最大尺寸，主Chunk把数据追加到自己的副本内，然后通知二级副本把数据写在跟主Chunk一样的位置上，最后回复客户机操作成功。</p>
<p>如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个Chunk的不同副本可能包含不同的数 据–重复包含一个记录全部或者部分的数据。GFS并不保证Chunk的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。 这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到Chunk的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部 的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的Chunk上，即使其它的Chunk副本被Master节点选为了主Chunk。就我们的 一致性保障模型而言，记录追加操作成功写入数据的region是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在 2.7.2节讨论的，我们的程序可以处理不一致的区域。</p>
<h4 id="3-4-快照"><a href="#3-4-快照" class="headerlink" title="3.4 快照"></a>3.4 快照</h4><p><strong>(alex注：这一节非常难以理解，总的来说依次讲述了什么是快照、快照使用的COW技术、快照如何不干扰当前操作)</strong></p>
<p>快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照 迅速的创建一个巨大的数据集的分支拷贝（而且经常是递归的拷贝拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的 提交或者回滚到备份时的状态。</p>
<p>就像AFS <strong>（alex注：AFS，即Andrew File System，一种分布式文件系统）</strong>，我 们用标准的copy-on-write技术实现快照。当Master节点收到一个快照请求，它首先取消作快照的文件的所有Chunk的租约。这个措施保证 了后续对这些Chunk的写操作都必须与Master交互交互以找到租约持有者。这就给Master节点一个率先创建Chunk的新拷贝的机会。</p>
<p>租约取消或者过期之后，Master节点把这个操作以日志的方式记录到硬盘上。然后，Master节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的Chunk地址。</p>
<p>在快照操作之后，当客户机第一次想写入数据到Chunk C，它首先会发送一个请求到Master节点查询当前的租约持有者。Master节点注意到Chunke C的引用计数超过了1。 Master节点不会马上回复客户机的请求，而是选择一个新的Chunk句柄C’。之后，Master节点要求每个拥有Chunk C当前副本的Chunk服务器创建一个叫做C’的新Chunk。通过在源Chunk所在Chunk服务器上创建新的Chunk，我们确保数据在本地而不是 通过网络复制（我们的硬盘比我们的100Mb以太网大约快3倍）。从这点来讲，请求的处理方式和任何其它Chunk没什么不同：Master节点确保新 Chunk C’的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个Chunk，而不必理会它是从一个已存在的Chunk克隆出来的。</p>
<h3 id="4-Master节点的操作"><a href="#4-Master节点的操作" class="headerlink" title="4. Master节点的操作"></a>4. Master节点的操作</h3><p>Master节点执行所有的名称空间操作。此外，它还管理着整个系统里所有Chunk的副本：它决定Chunk的存储位置，创建新Chunk和 它的副本，协调各种各样的系统活动以保证Chunk被完全复制，在所有的Chunk服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述 的主题。</p>
<h4 id="4-1-名称空间管理和锁"><a href="#4-1-名称空间管理和锁" class="headerlink" title="4.1 名称空间管理和锁"></a>4.1 名称空间管理和锁</h4><p>Master节点的很多操作会花费很长的时间：比如，快照操作必须取消Chunk服务器上快照所涉及的所有的Chunk的租约。我们不希望在这 些操作的运行时，延缓了其它的Master节点的操作。因此，我们允许多个操作同时进行，使用名称空间的region上的锁来保证执行的正确顺序。</p>
<p>不同于许多传统文件系统，GFS没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS也不支持文件或者目录的链接（即Unix术语中 的硬链接或者符号链接）。在逻辑上，GFS的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称 空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的读写锁。</p>
<p>每个Master节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/…/dn/leaf，那么操作首先要获 得目录/d1，/d1/d2，…，/d1/d2/…/dn的读锁，以及/d1/d2/…/dn/leaf的读写锁。注意，根据操作的不同，leaf可以是 一个文件，也可以是一个目录。</p>
<p>现在，我们演示一下在/home/user被快照到/save/user的时候，锁机制如何防止创建文件/home/user/foo。快照操 作获取/home和/save的读取锁，以及/home/user和/save/user的写入锁。文件创建操作获得/home和/home/user的 读取锁，以及/home/user/foo的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突。文件创建操作不需要 获取父目录的写入锁，因为这里没有”目录”，或者类似inode等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p>采用这种锁方案的优点是支持对同一目录的并行操作。比如，可以再同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件 名上的写入锁。目录名的读取锁足以的防止目录被删除、改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。</p>
<p>因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p>
<h4 id="4-2-副本的位置"><a href="#4-2-副本的位置" class="headerlink" title="4.2 副本的位置"></a>4.2 副本的位置</h4><p>GFS集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个Chunk服务器安装在许多机架上。Chunk服务器被来自同 一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在 一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p>
<p>Chunk副本位置选择的策略服务两大目标：最大化数据可靠性和可用性，最大化网络带宽利用率。为了实现这两个目的，仅仅是在多台机器上分别存 储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存Chunk的副本。 这保证Chunk的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网 络流量方面，尤其是针对Chunk的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们 愿意付出的。</p>
<h4 id="4-3-创建，重新复制，重新负载均衡"><a href="#4-3-创建，重新复制，重新负载均衡" class="headerlink" title="4.3 创建，重新复制，重新负载均衡"></a>4.3 创建，重新复制，重新负载均衡</h4><p>Chunk的副本有三个用途：Chunk创建，重新复制和重新负载均衡。</p>
<p>当Master节点创建一个Chunk时，它会选择在哪里放置初始的空的副本。Master节点会考虑几个因素。</p>
<ul>
<li>(1) 我们希望在低于平均硬盘 使用率的Chunk服务器上存储新的副本。这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。</li>
<li>(2) 我们希望限制在每个Chunk服务器上”最 近”的Chunk创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为Chunk在Writer真正写入 数据的时候才被创建，而在我们的”追加一次，读取多次”的工作模式下，Chunk一旦写入成功之后就会变为只读的了。</li>
<li>(3) 如上所述，我们希望把 Chunk的副本分布在多个机架之间。</li>
</ul>
<p>当Chunk的有效副本数量少于用户指定的复制因数的时候，Master节点会重新复制它。这可能是由几个原因引起的：一个Chunk服务器不 可用了，Chunk服务器报告它所存储的一个副本损坏了，Chunk服务器的一个磁盘因为错误不可用了，或者Chunk副本的复制因数提高了。每个需要被 重新复制的Chunk都会根据几个因素进行排序。一个因素是Chunk现有副本数量和复制因数相差多少。例如，丢失两个副本的Chunk比丢失一个副本的 Chunk有更高的优先级。另外，我们优先重新复制活跃（live）文件的Chunk而不是最近刚被删除的文件的Chunk（查看4.4节）。最后，为了 最小化失效的Chunk对正在运行的应用程序的影响，我们提高会阻塞客户机程序处理流程的Chunk的优先级。</p>
<p>Master节点选择优先级最高的Chunk，然后命令某个Chunk服务器直接从可用的副本”克隆”一个副本出来。选择新副本的位置的策略和 创建时类似：平衡硬盘使用率、限制同一台Chunk服务器上的正在进行的克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的 流量，Master节点对整个集群和每个Chunk服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk服务器通过调节它对源Chunk服 务器读请求的频率来限制它用于克隆操作的带宽。</p>
<p>最后，Master服务器周期性地对副本进行重新负载均衡：它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载 均衡。而且在这个过程中，Master服务器逐渐的填满一个新的Chunk服务器，而不是在短时间内用新的Chunk填满它，以至于过载。新副本的存储位 置选择策略和上面讨论的相同。另外，Master节点必须选择哪个副本要被移走。通常情况，Master节点移走那些剩余空间低于平均值的Chunk服务 器上的副本，从而平衡系统整体的硬盘使用率。</p>
<h4 id="4-4-垃圾回收"><a href="#4-4-垃圾回收" class="headerlink" title="4.4 垃圾回收"></a>4.4 垃圾回收</h4><p>GFS在文件删除后不会立刻回收可用的物理空间。GFS空间回收采用惰性的策略，只在文件和Chunk级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p>
<h5 id="4-4-1-机制"><a href="#4-4-1-机制" class="headerlink" title="4.4.1 机制"></a>4.4.1 机制</h5><p>当一个文件被应用程序删除时，Master节点象对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master节点并不马上 回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当Master节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件 （这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。 当隐藏文件被从名称空间中删除，Master服务器内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有Chunk的连接 <strong>（alex注：原文是This effectively severs its links to all its chunks）。</strong></p>
<p>在对Chunk名字空间做类似的常规扫描时，Master节点找到孤儿Chunk（不被任何文件包含的Chunk）并删除它们的元数据。 Chunk服务器在和Master节点交互的心跳信息中，报告它拥有的Chunk子集的信息，Master节点回复Chunk服务器哪些Chunk在 Master节点保存的元数据中已经不存在了。Chunk服务器可以任意删除这些Chunk的副本。</p>
<h5 id="4-4-2-讨论"><a href="#4-4-2-讨论" class="headerlink" title="4.4.2 讨论"></a>4.4.2 讨论</h5><p>虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在GFS系统中是非常简单的。我们可以轻易的得到Chunk的所有 引用：它们都只存储在Master服务器上的文件到块的映射表中。我们也可以很轻易的得到所有Chunk的副本：它们都以Linux文件的形式存储在 Chunk服务器的指定目录下。所有Master节点不能识别的副本都是”垃圾”。</p>
<p>垃圾回收在空间回收方面相比直接删除有几个优势。</p>
<ul>
<li>首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。Chunk可能在某些 Chunk服务器创建成功，某些Chunk服务器上创建失败，失败的副本处于无法被Master节点识别的状态。副本删除消息可能丢失，Master节点 必须重新发送失败的删除消息，包括自身的和Chunk服务器的 <strong>（alex注：自身的指删除metadata的消息）。</strong> 垃圾回收提供了一致的、可靠的清除无用副本的方法。</li>
<li>第二，垃圾回收把存储空间的回收操作合并到Master节点规律性的后台活动中，比如，例行扫描和与 Chunk服务器握手等。因此，操作被批量的执行，开销会被分散。另外，垃圾回收在Master节点相对空闲的时候完成。这样Master节点就可以给那 些需要快速反应的客户机请求提供更快捷的响应。</li>
<li>第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</li>
</ul>
<p>根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建 和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部 分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p>
<h4 id="4-5-过期失效的副本检测"><a href="#4-5-过期失效的副本检测" class="headerlink" title="4.5 过期失效的副本检测"></a>4.5 过期失效的副本检测</h4><p>当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了每个Chunk的版本号，用来区分当前的副本和过期副本。</p>
<p>无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。Master节点和这些副本 都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的 Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。Master节点在这个Chunk服务器重新启动，并且向Master节点报告它拥有 的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk。如果Master节点看到一个比它记录的版本号更高的版本 号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择更高的版本号作为当前的版本号。</p>
<p>Master节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的 认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p>
<h3 id="5-容错和诊断"><a href="#5-容错和诊断" class="headerlink" title="5. 容错和诊断"></a>5. 容错和诊断</h3><p>我们在设计GFS时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率： 我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对 这些挑战，以及当组件失效不可避免的发生时，用GFS自带工具诊断系统故障。</p>
<h4 id="5-1-高可用性"><a href="#5-1-高可用性" class="headerlink" title="5.1 高可用性"></a>5.1 高可用性</h4><p>在GFS集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：快速恢复和复制。</p>
<h5 id="5-1-1-快速恢复"><a href="#5-1-1-快速恢复" class="headerlink" title="5.1.1 快速恢复"></a>5.1.1 快速恢复</h5><p>不管Master服务器和Chunk服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重新启动。事实上，我们并不区分正常关闭和异常关闭；通常，我们通过直接kill掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸<strong> (alex注：a minor hiccup)</strong>，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。6.6.2章节记录了实测的启动时间。</p>
<h5 id="5-1-2-Chunk复制"><a href="#5-1-2-Chunk复制" class="headerlink" title="5.1.2 Chunk复制"></a>5.1.2 Chunk复制</h5><p>正如之前讨论的，每个Chunk都被复制到不同机架上的不同的Chunk服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是 3。当有Chunk服务器离线了，或者通过Chksum校验（参考5.2节）发现了已经损坏的数据，Master节点通过克隆已有的副本保证每个 Chunk都被完整复制<strong>（alex注：即每个Chunk都有复制因子制定的个数个副本，缺省是3）</strong>。虽然Chunk复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或者Erasure codes<strong>（alex注：Erasure codes用来解决链接层中不相关的错误，以及网络拥塞和buffer限制造成的丢包错误）</strong>来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p>
<h5 id="5-1-3-Master服务器的复制"><a href="#5-1-3-Master服务器的复制" class="headerlink" title="5.1.3 Master服务器的复制"></a>5.1.3 Master服务器的复制</h5><p>为了保证Master服务器的可靠性，Master服务器的状态也要复制。Master服务器所有的操作日志和checkpoint文件都被复 制到多台机器上。对Master服务器状态的修改操作能够提交成功的前提是，操作日志写入到Master服务器的备节点和本机的磁盘。简单说来，一个 Master服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果Master 进程所在的机器或者磁盘失效了，处于GFS系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的Master进程。客户端使用规范的名字访 问Master（比如gfs-test）节点，这个名字类似DNS别名，因此也就可以在Master进程转到别的机器上执行时，通过更改别名的实际指向访 问新的Master节点。</p>
<p>此外，GFS中还有些“影子”Master服务器，这些“影子”服务器在“主”Master服务器宕机的时候提供文件系统的只读访问。它们是影子， 而不是镜像，所以它们的数据可能比“主”Master服务器更新要慢，通常是不到1秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应 用程序，“影子”Master服务器能够提高读取的效率。事实上，因为文件内容是从Chunk服务器上读取的，因此，应用程序不会发现过期的文件内容。在 这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p>
<p>“影子”Master服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主Master服务器完全相同的顺序 来更改内部的数据结构。和主Master服务器一样，“影子”Master服务器在启动的时候也会从Chunk服务器轮询数据（之后定期拉数据），数据中 包括了Chunk副本的位置信息；“影子”Master服务器也会定期和Chunk服务器“握手”来确定它们的状态。在主Master服务器因创建和删除 副本导致副本位置信息更新时，“影子”Master服务器才和主Master服务器通信来更新自身状态。</p>
<p>5.2 数据完整性<br>每个Chunk服务器都使用Checksum来检查保存的数据是否损坏。考虑到一个GFS集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据 在读写过程中损坏或者丢失是非常常见的（第7节讲了一个原因）。我们可以通过别的Chunk副本来解决数据损坏问题，但是跨越Chunk服务器比较副本来 检查数据是否损坏很不实际。另外，GFS允许有歧义的副本存在：GFS修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同<strong>(alex注：副本不是byte-wise完全一致的))</strong>。因此，每个Chunk服务器必须独立维护Checksum来校验自己的副本的完整性。</p>
<p>我们把每个Chunk都分成64KB大小的块。每个块都对应一个32位的Checksum。和其它元数据一样，Checksum与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>
<p>对于读操作来说，在把数据返回给客户端或者其它的Chunk服务器之前，Chunk服务器会校验读取操作涉及的范围内的块的Checksum。因此 Chunk服务器不会把错误数据传递到其它的机器上。如果发生某个块的Checksum不正确，Chunk服务器返回给请求者一个错误信息，并且通知 Master服务器这个错误。作为回应，请求者应当从其它副本读取数据，Master服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪 后，Master服务器通知副本错误的Chunk服务器删掉错误的副本。</p>
<p>Checksum对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相 关数据进行校验。GFS客户端代码通过每次把读取操作都对齐在Checksum block的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在Chunk服务器上，Chunksum的查找和比较不需要I/O操 作，Checksum的计算可以和I/O操作同时进行。</p>
<p>Checksum的计算针对在Chunk尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了 很大比例。我们只增量更新最后一个不完整的块的Checksum，并且用所有的追加来的新Checksum块来计算新的Checksum。即使是最后一个 不完整的Checksum块已经损坏了，而且我们不能够马上检查出来，由于新的Checksum和已有数据不吻合，在下次对这个块进行读取操作的时候，会 检查出数据已经损坏了。</p>
<p>相比之下，如果写操作覆盖已经存在的一个范围内的Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重 新计算和写入新的Checksum。如果我们不校验第一个和最后一个被写的块，那么新的Checksum可能会隐藏没有被覆盖区域内的数据错误。</p>
<p>在Chunk服务器空闲的时候，它会扫描和校验每个不活动的Chunk的内容。这使得我们能够发现很少被读取的Chunk是否完整。一旦发现有 Chunk的数据损坏，Master可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的Chunk欺骗 Master节点，使Master节点认为它们已经有了足够多的副本了。</p>
<h4 id="5-3-诊断工具"><a href="#5-3-诊断工具" class="headerlink" title="5.3 诊断工具"></a>5.3 诊断工具</h4><p>详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难 理解短暂的、不重复的机器之间的消息交互。GFS的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk服务器启动和关闭）以及所有的RPC 的请求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p>
<p>RPC日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求与回应，以及收集不同机器上的RPC日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪负载测试和性能分析。</p>
<p>日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p>
<h3 id="6-度量"><a href="#6-度量" class="headerlink" title="6. 度量"></a>6. 度量</h3><p>本节中，我们将使用一些小规模基准测试来展现GFS系统架构和实现上的一些固有瓶颈，还有些来自Google内部使用的真实的GFS集群的基准数据。</p>
<h4 id="6-1-小规模基准测试"><a href="#6-1-小规模基准测试" class="headerlink" title="6.1 小规模基准测试"></a>6.1 小规模基准测试</h4><p>我们在一个包含1台Master服务器，2台Master服务器复制节点，16台Chunk服务器和16个客户机组成的GFS集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的GFS集群有数百个Chunk服务器和数百个客户机。</p>
<p>所有机器的配置都一样：两个PIII 1.4GHz处理器，2GB内存，两个80G/5400rpm的硬盘，以及100Mbps全双工以太网连接到一个HP2524交换机。GFS集群中所有的 19台服务器都连接在一个交换机，所有16台客户机连接到另一个交换机上。两个交换机之间使用1Gbps的线路连接。</p>
<h5 id="6-1-1-读取"><a href="#6-1-1-读取" class="headerlink" title="6.1.1 读取"></a>6.1.1 读取</h5><p>N个客户机从GFS文件系统同步读取数据。每个客户机从320GB的文件集合中随机读取4MB region的内容。读取操作重复执行256次，因此，每个客户机最终都读取1GB的数据。所有的Chunk服务器加起来总共只有32GB的内存，因此， 我们预期只有最多10%的读取请求命中Linux的文件系统缓冲。我们的测试结果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。</p>
<p><img src="/images/GFS6-1-1.jpg"></p>
<p>图三：合计吞吐量：上边的曲线显示了我们网络拓扑下的合计理论吞吐量上限。下边的曲线显示了观测到的吞吐量。这个曲线有着95%的可靠性，因为有时候测量会不够精确。</p>
<p>图3（a）显示了N个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的1Gbps的链路饱和时，整体读取速度达到理论的极限值 是125MB/S，或者说每个客户机配置的100Mbps网卡达到饱和时，每个客户机读取速度的理论极限值是12.5MB/s。实测结果是，当一个客户机 读取的时候，读取的速度是10MB/s，也就是说达到客户机理论读取速度极限值的80%。对于16个客户机，整体的读取速度达到了94MB/s，大约是理 论整体读取速度极限值的75%，也就是说每个客户机的读取速度是6MB/s。读取效率从80%降低到了75%，主要的原因是当读取的客户机增加时，多个客 户机同时读取一个Chunk服务器的几率也增加了，导致整体的读取效率下降。</p>
<h5 id="6-1-2-写入"><a href="#6-1-2-写入" class="headerlink" title="6.1.2 写入"></a>6.1.2 写入</h5><p>N个客户机同时向N个不同的文件中写入数据。每个客户机以每次1MB的速度连续写入1GB的数据。图3（b）显示了整体的写入速度和它们理论上 的极限值。理论上的极限值是67MB/s，因为我们需要把每一byte写入到16个Chunk服务器中的3个上，而每个Chunk服务器的输入连接速度是 12.5MB/s。</p>
<p>一个客户机的写入速度是6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协议栈。它与我们推送数据到Chunk服务器时采用的管道模式不相适应。从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。</p>
<p>16个客户机整体的写入速度达到了35MB/s（即每个客户机2.2MB/s），大约只是理论极限值的一半。和多个客户机读取的情形很类型，随 着客户机数量的增加，多个客户机同时写入同一个Chunk服务器的几率也增加了。而且，16个客户机并行写入可能引起的冲突比16个客户机并行读取要大得 多，因为每个写入都会涉及三个不同的副本。</p>
<p>写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响。</p>
<h5 id="6-1-3-记录追加"><a href="#6-1-3-记录追加" class="headerlink" title="6.1.3 记录追加"></a>6.1.3 记录追加</h5><p>图3（c）显示了记录追加操作的性能。N个客户机同时追加数据到一个文件。记录追加操作的性能受限于保存文件最后一个Chunk的Chunk服务器 的带宽，而与客户机的数量无关。记录追加的速度由一个客户机的6.0MB/s开始，下降到16个客户机的4.8MB/s为止，速度的下降主要是由于不同客 户端的网络拥塞以及网络传输速度的不同而导致的。</p>
<p>我们的程序倾向于同时处理多个这样的文件。换句话说，即N个客户机同时追加数据到M个共享文件中，这里N和M都是数十或者数百以上。所以，在我们的 实际应用中，Chunk服务器的网络拥塞并没有成为一个严重问题，如果Chunk服务器的某个文件正在写入，客户机会去写另外一个文件。</p>
<h4 id="6-2-实际应用中的集群"><a href="#6-2-实际应用中的集群" class="headerlink" title="6.2 实际应用中的集群"></a>6.2 实际应用中的集群</h4><p>我们现在来仔细评估一下Google内部正在使用的两个集群，它们具有一定的代表性。集群A通常被上百个工程师用于研究和开发。典型的任务是被 人工初始化后连续运行数个小时。它通常读取数MB到数TB的数据，之后进行转化或者分析，最后把结果写回到集群中。集群B主要用于处理当前的生产数据。集 群B的任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数TB的数据集。在这两个案例中，一个单独的”任务”都是指运行在多个机器上的多个 进程，它们同时读取和写入多个文件。</p>
<p><img src="/images/GFS6-2.jpg"></p>
<h5 id="6-2-1-存储"><a href="#6-2-1-存储" class="headerlink" title="6.2.1 存储"></a>6.2.1 存储</h5><p>如上表前五行所描述的，两个集群都由上百台Chunk服务器组成，支持数TB的硬盘空间；两个集群虽然都存储了大量的数据，但是还有剩余的空间。 “已用空间”包含了所有的Chunk副本。实际上所有的文件都复制了三份。因此，集群实际上各存储了18TB和52TB的文件数据。</p>
<p>两个集群存储的文件数量都差不多，但是集群B上有大量的死文件。所谓“死文件”是指文件被删除了或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群B存储的文件较大，因此它的Chunk数量也比较多。</p>
<h5 id="6-2-2-元数据"><a href="#6-2-2-元数据" class="headerlink" title="6.2.2 元数据"></a>6.2.2 元数据</h5><p>Chunk服务器总共保存了十几GB的元数据，大多数是来自用户数据的、64KB大小的块的Checksum。保存在Chunk服务器上其它的元数据是Chunk的版本号信息，我们在4.5节描述过。</p>
<p>在Master服务器上保存的元数据就小的多了，大约只有数十MB，或者说平均每个文件100字节的元数据。这和我们设想的是一样的，Master 服务器的内存大小在实际应用中并不会成为GFS系统容量的瓶颈。大多数文件的元数据都是以前缀压缩模式存放的文件名。Master服务器上存放的其它元数 据包括了文件的所有者和权限、文件到Chunk的映射关系，以及每一个Chunk的当前版本号。此外，针对每一个Chunk，我们都保存了当前的副本位置 以及对它的引用计数，这个引用计数用于实现写时拷贝<strong>（alex注：即COW，copy-on-write）。</strong></p>
<p>对于每一个单独的服务器，无论是Chunk服务器还是Master服务器，都只保存了50MB到100MB的元数据。因此，恢复服务器是非常快速 的：在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这些数据就可以了。不过，Master服务器会持续颠簸一段时间–通常是30到60秒–直 到它完成轮询所有的Chunk服务器，并获取到所有Chunk的位置信息。</p>
<h5 id="6-2-3-读写速率"><a href="#6-2-3-读写速率" class="headerlink" title="6.2.3 读写速率"></a>6.2.3 读写速率</h5><p><img src="/images/GFS6-2-3.jpg"> </p>
<p>表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。（这两个集群最近都因为升级新版本的GFS重新启动过了）。</p>
<p>集群重新启动后，平均写入速率小于30MB/s。当我们提取性能数据的时候，集群B正进行大量的写入操作，写入速度达到了100MB/s，并且因为每个Chunk都有三个副本的原因，网络负载达到了300MB/s。<br>读取速率要比写入速率高的多。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比例。两个集群都进行着繁重的读取操作。特别是， 集群A在一周时间内都维持了580MB/s的读取速度。集群A的网络配置可以支持750MB/s的速度，显然，它有效的利用了资源。集群B支持的峰值读取 速度是1300MB/s，但是它的应用只用到了380MB/s。 </p>
<h5 id="6-2-4-Master服务器的负载"><a href="#6-2-4-Master服务器的负载" class="headerlink" title="6.2.4 Master服务器的负载"></a>6.2.4 Master服务器的负载</h5><p>表3的数据显示了发送到Master服务器的操作请求大概是每秒钟200到500个。Master服务器可以轻松的应付这个请求速度，所以Master服务器的处理能力不是系统的瓶颈。</p>
<p>在早期版本的GFS中，Master服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录（包含数万个文件）去查找某个特定的文 件。因此我们修改了Master服务器的数据结构，通过对名字空间进行二分查找来提高效率。现在Master服务器可以轻松的每秒钟进行数千次文件访问。 如果有需要的话，我们可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。</p>
<h5 id="6-2-5-恢复时间"><a href="#6-2-5-恢复时间" class="headerlink" title="6.2.5 恢复时间"></a>6.2.5 恢复时间</h5><p>当某个Chunk服务器失效了，一些Chunk副本的数量可能会低于复制因子指定的数量，我们必须通过克隆副本使Chunk副本数量达到复制因 子指定的数量。恢复所有Chunk副本所花费的时间取决于资源的数量。在我们的试验中，我们把集群B上的一个Chunk服务器Kill掉。这个Chunk 服务器上大约有15000个Chunk，共计600GB的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为GFS调度决策提供修正空间，我们缺 省的把集群中并发克隆操作的数量设置为91个（Chunk服务器的数量的40%），每个克隆操作最多允许使用的带宽是6.25MB/s（50mbps）。 所有的Chunk在23.2分钟内恢复了，复制的速度高达440MB/s。</p>
<p>在另外一个测试中，我们Kill掉了两个Chunk服务器，每个Chunk服务器大约有16000个Chunk，共计660GB的数据。这两个 故障导致了266个Chunk只有单个副本。这266个Chunk被GFS优先调度进行复制，在2分钟内恢复到至少有两个副本；现在集群被带入到另外一个 状态，在这个状态下，系统可以容忍另外一个Chunk服务器失效而不丢失数据。</p>
<h4 id="6-3-工作负荷分析-Workload-Breakdown"><a href="#6-3-工作负荷分析-Workload-Breakdown" class="headerlink" title="6.3 工作负荷分析(Workload Breakdown)"></a>6.3 工作负荷分析(Workload Breakdown)</h4><p>本节中，我们展示了对两个GFS集群工作负载情况的详细分析，这两个集群和6.2节中的类似，但是不完全相同。集群X用于研究和开发，集群Y用于生产数据处理。 </p>
<h5 id="6-3-1-方法论和注意事项"><a href="#6-3-1-方法论和注意事项" class="headerlink" title="6.3.1 方法论和注意事项"></a>6.3.1 方法论和注意事项</h5><p>本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对GFS文件系统产生的全部工作负载。它们不包含 那些为了实现客户端请求而在服务器间交互的请求，也不包含GFS内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。</p>
<p>我们从GFS服务器记录的真实的RPC请求日志中推导重建出关于IO操作的统计信息。例如，GFS客户程序可能会把一个读操作分成几个RPC请 求来提高并行度，我们可以通过这些RPC请求推导出原始的读操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差<strong> (alex注：Since our access patterns are highly stylized, we expect any error to be in the noise)</strong>。应用程序如果能够记录更详尽的日志，就有可能提供更准确的诊断数据；但是为了这个目的去重新编译和重新启动数千个正在运行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。</p>
<p>应该避免从我们的工作负荷数据中过度的归纳出普遍的结论<strong> (alex注：即不要把本节的数据作为基础的指导性数据)</strong>。因为Google完全控制着GFS和使用GFS的应用程序，所以，应用程序都针对GFS做了优化，同时，GFS也是为了这些应用程序而设计的。这样的相互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。</p>
<h5 id="6-3-2-Chunk服务器工作负荷"><a href="#6-3-2-Chunk服务器工作负荷" class="headerlink" title="6.3.2 Chunk服务器工作负荷"></a>6.3.2 Chunk服务器工作负荷</h5><p><img src="/images/GFS6-3-2.jpg"></p>
<p>表4显示了操作按涉及的数据量大小的分布情况。读取操作按操作涉及的数据量大小呈现了双峰分布。小的读取操作（小于64KB）一般是由查找操作的客户端发起的，目的在于从巨大的文件中查找小块的数据。大的读取操作（大于512KB）一般是从头到尾顺序的读取整个文件。</p>
<p>在集群Y上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常使用文件作为生产者-消费者队列。生产者并行的向文 件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群X通常 用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群X很少出现这种情况。</p>
<p>写操作按数据量大小也同样呈现为双峰分布。大的写操作（超过256KB）通常是由于Writer使用了缓存机制导致的。Writer缓存较小的数据，通过频繁的Checkpoint或者同步操作，或者只是简单的统计小的写入（小于64KB）的数据量<strong>(alex注：即汇集多次小的写入操作，当数据量达到一个阈值，一次写入)</strong>，之后批量写入。</p>
<p>再来观察一下记录追加操作。我们可以看到集群Y中大的记录追加操作所占比例比集群X多的多，这是因为集群Y用于我们的生产系统，针对GFS做了更全面的调优。</p>
<p><img src="/images/GFS6-3-2-2.jpg"></p>
<p>表5显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作（超过256KB）占据了主要的传输量。小的读取（小于64KB）虽然传输的数据量比较少，但是在读取的数据量中仍占了相当的比例，这是因为在文件中随机Seek的工作负荷而导致的。</p>
<h5 id="6-3-3-记录追加-vs-写操作"><a href="#6-3-3-记录追加-vs-写操作" class="headerlink" title="6.3.3 记录追加 vs. 写操作"></a>6.3.3 记录追加 vs. 写操作</h5><p>记录追加操作在我们的生产系统中大量使用。对于集群X，记录追加操作和普通写操作的比例按照字节比是108:1，按照操作次数比是8:1。对于 作为我们的生产系统的集群Y来说，这两个比例分别是3.7:1和2.5:1。更进一步，这一组数据说明在我们的两个集群上，记录追加操作所占比例都要比写 操作要大。对于集群X，在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的buffer的应用程序的影响。</p>
<p>如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第一个副本的数据覆盖写的情况。这近似于一个客户机故 意覆盖刚刚写入的数据，而不是增加新的数据。对于集群X，覆盖写操作在写操作所占据字节上的比例小于0.0001%，在所占据操作数量上的比例小于 0.0003%。对于集群Y，这两个比率都是0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。这是由于这些覆盖写的操作，大部分是由于客 户端在发生错误或者超时以后重试的情况。这在本质上应该不算作工作负荷的一部分，而是重试机制产生的结果。</p>
<h5 id="6-3-4-Master的工作负荷"><a href="#6-3-4-Master的工作负荷" class="headerlink" title="6.3.4 Master的工作负荷"></a>6.3.4 Master的工作负荷</h5><p><img src="/images/GFS6-3-4.jpg"></p>
<p>表6显示了Master服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询Chunk位置信息（FindLocation）、以及修改操作查询lease持有者的信息（FindLease-Locker）。</p>
<p>集群X和Y在删除请求的数量上有着明显的不同，因为集群Y存储了生产数据，一般会重新生成数据以及用新版本的数据替换旧有的数据。数量上的差异 也被隐藏在了Open请求中，因为旧版本的文件可能在以重新写入的模式打开时，隐式的被删除了（类似UNIX的open函数中的“w”模式）。</p>
<p>FindMatchingFiles是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于Master服务器的其它请求，它可 能会检索namespace的大部分内容，因此是非常昂贵的操作。集群Y的这类请求要多一些，因为自动化数据处理的任务进程需要检查文件系统的各个部分， 以便从全局上了解应用程序的状态。与之不同的是，集群X的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的名称。</p>
<h3 id="7-经验"><a href="#7-经验" class="headerlink" title="7. 经验"></a>7. 经验</h3><p>在建造和部署GFS的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。</p>
<p>起初，GFS被设想为我们的生产系统的后端文件系统。随着时间推移，在GFS的使用中逐步的增加了对研究和开发任务的支持。我们开始增加一些小 的功能，比如权限和配额，到了现在，GFS已经初步支持了这些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止 用户间的相互干扰。</p>
<p>我们最大的问题是磁盘以及和Linux相关的问题。很多磁盘都声称它们支持某个范围内的Linux IDE硬盘驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所以大部分磁盘都可以用，但是偶尔也会有由于 协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用Checksum来校验数据， 同时我们也修改内核来处理这些因为协议不匹配带来的问题。</p>
<p>较早的时候，我们在使用Linux 2.2内核时遇到了些问题，主要是fsync()的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难 题，尤其是在我们尚未实现Checkpoint的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了Linux2.4内核上。</p>
<p>另一个和Linux相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须在从磁盘page in（读锁）的时候先hold住，或者在mmap()调用（写锁）的时候改写地址空间。我们发现即使我们的系统负载很轻的情况下也会有偶尔的超时，我们花 费了很多的精力去查找资源的瓶颈或者硬件的问题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程，阻止它把 新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存copy的带宽，因此，我们用pread()替代mmap()，用了一个额外的copy 动作来解决这个问题。</p>
<p>尽管偶尔还是有其它的问题，Linux的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的时候，我们会改进内核并且和公开源码组织共享这些改动。</p>
<h3 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8. 相关工作"></a>8. 相关工作</h3><p>和其它的大型分布式文件系统，比如AFS[5]类似，GFS提供了一个与位置无关的名字空间，这使得数据可以为了负载均衡或者灾难冗余等目的在 不同位置透明的迁移。不同于AFS的是，GFS把文件分布存储到不同的服务器上，这种方式更类似Xfs[1]和Swift[3]，这是为了提高整体性能以 及灾难冗余的能力。</p>
<p>由于磁盘相对来说比较便宜，并且复制的方式比RAID[9]方法简单的多，GFS目前只使用复制的方式来进行冗余，因此要比xFS或者Swift占用更多的裸存储空间 <strong>(alex注：Raw storage，裸盘的空间)</strong>。</p>
<p>与AFS、xFS、Frangipani[12]以及Intermezzo[6]等文件系统不同的是，GFS并没有在文件系统层面提供任何 Cache机制。我们主要的工作在单个应用程序执行的时候几乎不会重复读取数据，因为它们的工作方式要么是流式的读取一个大型的数据集，要么是在大型的数 据集中随机Seek到某个位置，之后每次读取少量的数据。</p>
<p>某些分布式文件系统，比如Frangipani、xFS、Minnesota’s GFS[11]、GPFS[10]，去掉了中心服务器，只依赖于分布式算法来保证一致性和可管理性。我们选择了中心服务器的方法，目的是为了简化设计，增 加可靠性，能够灵活扩展。特别值得一提的是，由于处于中心位置的Master服务器保存有几乎所有的Chunk相关信息，并且控制着Chunk的所有变 更，因此，它极大地简化了原本非常复杂的Chunk分配和复制策略的实现方法。我们通过减少Master服务器保存的状态信息的数量，以及将Master 服务器的状态复制到其它节点来保证系统的灾难冗余能力。扩展能力和高可用性（对于读取）目前是通过我们的影子Master服务器机制来保证的。对 Master服务器状态更改是通过预写日志的方式实现持久化。为此，我们可以调整为使用类似Harp[7]中的primary-copy方案，从而提供比 我们现在的方案更严格的一致性保证。</p>
<p>我们解决了一个难题，这个难题类似Lustre[8]在如何在有大量客户端时保障系统整体性能遇到的问题。不过，我们通过只关注我们的应用程序 的需求，而不是提供一个兼容POSIX的文件系统，从而达到了简化问题的目的。此外，GFS设计预期是使用大量的不可靠节点组建集群，因此，灾难冗余方案 是我们设计的核心。</p>
<p>GFS很类似NASD架构[4]。NASD架构是基于网络磁盘的，而GFS使用的是普通计算机作为Chunk服务器，就像NASD原形中方案一 样。所不同的是，我们的Chunk服务器采用惰性分配固定大小的Chunk的方式，而不是分配变长的对象存储空间。此外，GFS实现了诸如重新负载均衡、 复制、恢复机制等等在生产环境中需要的特性。</p>
<p>不同于与Minnesota’s GFS和NASD，我们并不改变存储设备的Model <strong>(alex注：对这两个文件系统不了解，因为不太明白改变存储设备的Model用来做什么，这不明白这个model是模型、还是型号)</strong>。我们只关注用普通的设备来解决非常复杂的分布式系统日常的数据处理。</p>
<p>我们通过原子的记录追加操作实现了生产者-消费者队列，这个问题类似River[2]中的分布式队列。River使用的是跨主机的、基于内存的 分布式队列，为了实现这个队列，必须仔细控制数据流；而GFS采用可以被生产者并发追加记录的持久化的文件的方式实现。River模式支持m-到-n的分 布式队列，但是缺少由持久化存储提供的容错机制，GFS只支持m-到-1的队列。多个消费者可以同时读取一个文件，但是它们输入流的区间必须是对齐的。</p>
<h3 id="9-结束语"><a href="#9-结束语" class="headerlink" title="9. 结束语"></a>9. 结束语</h3><p>Google文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p>
<p>首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的 文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效是常态而不是异常，针对采用追加 方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p>
<p>我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。 Chunk复制使得我们可以对Chunk服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够 第一时间重新建立丢失的副本。此外，我们使用Checksum在磁盘或者IDE子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高 的。</p>
<p>我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据流来实现这个目标，控制流在Master服务器处理，而数据流在Chunk服务器和客户端处理。当一般的操作涉及到Master服务器时，由于GFS选择的Chunk尺寸较大<strong>(alex注：从而减小了元数据的大小)</strong>，以及通过Chunk Lease将控制权限移交给主副本，这些措施将Master服务器的负担降到最低。这使得一个简单、中心的Master不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p>
<p>GFS成功的实现了我们对存储的需求，在Google内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个WEB范围内的难题的一个重要工具。<br>致谢<br>We wish to thankt he following people for their contributions to the system or the paper. Brain Bershad (our shepherd) and the anonymous reviewers gave us valuable comments and suggestions. Anurag Acharya, Jeff Dean, and David des-Jardins contributed to the early design. Fay Chang worked on comparison of replicas across chunkservers. Guy Edjlali worked on storage quota. Markus Gutschke worked on a testing frameworkan d security enhancements. David<br>Kramer worked on performance enhancements. Fay Chang, Urs Hoelzle, Max Ibel, Sharon Perl, Rob Pike, and Debby Wallach commented on earlier drafts of the paper. Many of our colleagues at Google bravely trusted their data to a new file system and gave us useful feedback. Yoshka helped with early testing.<br>参考<br>[1] Thomas Anderson, Michael Dahlin, Jeanna Neefe, David Patterson, Drew Roselli, and Randolph Wang. Serverless networkfil e systems. In Proceedings of the 15th ACM Symposium on Operating System Principles, pages 109–126, Copper Mountain Resort, Colorado, December 1995.<br>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10–22, Atlanta, Georgia, May 1999.<br>[3] Luis-Felipe Cabrera and Darrell D. E. Long. Swift: Using distributed disks triping to provide high I/O data rates. Computer Systems, 4(4):405–436, 1991.</p>
<p>[4] Garth A. Gibson, David F. Nagle, Khalil Amiri, Jeff Butler, Fay W. Chang, Howard Gobioff, Charles Hardin, ErikR iedel, David Rochberg, and Jim Zelenka. A cost-effective, high-bandwidth storage architecture. In Proceedings of the 8th Architectural Support for Programming Languages and Operating Systems, pages 92–103, San Jose, California, October 1998.</p>
<p>[5] John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanarayanan, Robert Sidebotham, and Michael West. Scale and performance in a distributed file system. ACM Transactions on Computer Systems, 6(1):51–81, February 1988.<br>[6] InterMezzo. <a href="http://www.inter-mezzo.org" target="_blank" rel="external">http://www.inter-mezzo.org</a> , 2003.</p>
<p>[7] Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. Replication in the Harp file system. In 13th Symposium on Operating System Principles, pages 226–238, Pacific Grove, CA, October 1991.<br>[8] Lustre. <a href="http://www.lustreorg" target="_blank" rel="external">http://www.lustreorg</a> , 2003.</p>
<p>[9] David A. Patterson, Garth A. Gibson, and Randy H. Katz. A case for redundant arrays of inexpensive disks (RAID). In Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, pages 109–116, Chicago, Illinois, September 1988.<br>[10] FrankS chmuck and Roger Haskin. GPFS: A shared-diskfi le system for large computing clusters. In Proceedings of the First USENIX Conference on File and Storage Technologies, pages 231–244, Monterey, California, January 2002.</p>
<p>[11] Steven R. Soltis, Thomas M. Ruwart, and Matthew T.O’Keefe. The Gobal File System. In Proceedings of the Fifth NASA Goddard Space Flight Center Conference on Mass Storage Systems and Technologies, College Park, Maryland, September 1996.<br>[12] Chandramohan A. Thekkath, Timothy Mann, and Edward K. Lee. Frangipani: A scalable distributed file system. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 224–237, Saint-Malo, France, October 1997</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp js压缩]]></title>
      <url>http://zsr.github.io/2016/08/19/gulp-js%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<h4 id="安装nodejs、gulp"><a href="#安装nodejs、gulp" class="headerlink" title="安装nodejs、gulp"></a>安装nodejs、gulp</h4><ul>
<li>安装 nodejs</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure>
<ul>
<li>安装 gulp</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g gulp</div></pre></td></tr></table></figure>
<h4 id="安装gulp插件"><a href="#安装gulp插件" class="headerlink" title="安装gulp插件"></a>安装gulp插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp-htmlmin gulp-imagemin imagemin-pngcrush gulp-minify-css gulp-jshint gulp-uglify gulp-concat gulp-rename gulp-notify --save-dev</div></pre></td></tr></table></figure>
<h4 id="gulp配置文件"><a href="#gulp配置文件" class="headerlink" title="gulp配置文件"></a>gulp配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//在你的项目根目录下创建gulpfile.js，代码如下：</div><div class="line"> </div><div class="line">// 引入 gulp</div><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line"> </div><div class="line">// 引入组件</div><div class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;), //html压缩</div><div class="line">    imagemin = require(&apos;gulp-imagemin&apos;),//图片压缩</div><div class="line">    pngcrush = require(&apos;imagemin-pngcrush&apos;),</div><div class="line">    minifycss = require(&apos;gulp-minify-css&apos;),//css压缩</div><div class="line">    jshint = require(&apos;gulp-jshint&apos;),//js检测</div><div class="line">    uglify = require(&apos;gulp-uglify&apos;),//js压缩</div><div class="line">    concat = require(&apos;gulp-concat&apos;),//文件合并</div><div class="line">    rename = require(&apos;gulp-rename&apos;),//文件更名</div><div class="line">    notify = require(&apos;gulp-notify&apos;);//提示信息</div><div class="line"> </div><div class="line">// 压缩html</div><div class="line">gulp.task(&apos;html&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/*.html&apos;)</div><div class="line">    .pipe(htmlmin(&#123;collapseWhitespace: true&#125;))</div><div class="line">    .pipe(gulp.dest(&apos;./dest&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;html task ok&apos; &#125;));</div><div class="line"> </div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 压缩图片</div><div class="line">gulp.task(&apos;img&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/images/*&apos;)</div><div class="line">    .pipe(imagemin(&#123;</div><div class="line">        progressive: true,</div><div class="line">        svgoPlugins: [&#123;removeViewBox: false&#125;],</div><div class="line">        use: [pngcrush()]</div><div class="line">    &#125;))</div><div class="line">    .pipe(gulp.dest(&apos;./dest/images/&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;img task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 合并、压缩、重命名css</div><div class="line">gulp.task(&apos;css&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/css/*.css&apos;)</div><div class="line">    .pipe(concat(&apos;main.css&apos;))</div><div class="line">    .pipe(gulp.dest(&apos;dest/css&apos;))</div><div class="line">    .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;))</div><div class="line">    .pipe(minifycss())</div><div class="line">    .pipe(gulp.dest(&apos;dest/css&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;css task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 检查js</div><div class="line">gulp.task(&apos;lint&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/js/*.js&apos;)</div><div class="line">    .pipe(jshint())</div><div class="line">    .pipe(jshint.reporter(&apos;default&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;lint task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 合并、压缩js文件</div><div class="line">gulp.task(&apos;js&apos;, function() &#123;</div><div class="line">  return gulp.src(&apos;src/js/*.js&apos;)</div><div class="line">    .pipe(concat(&apos;all.js&apos;))</div><div class="line">    .pipe(gulp.dest(&apos;dest/js&apos;))</div><div class="line">    .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;))</div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(gulp.dest(&apos;dest/js&apos;))</div><div class="line">    .pipe(notify(&#123; message: &apos;js task ok&apos; &#125;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 默认任务</div><div class="line">gulp.task(&apos;default&apos;, function()&#123;</div><div class="line">  gulp.run(&apos;img&apos;, &apos;css&apos;, &apos;lint&apos;, &apos;js&apos;, &apos;html&apos;);</div><div class="line"> </div><div class="line">  // 监听html文件变化</div><div class="line">  gulp.watch(&apos;src/*.html&apos;, function()&#123;</div><div class="line">    gulp.run(&apos;html&apos;);</div><div class="line">  &#125;);</div><div class="line"> </div><div class="line">  // Watch .css files</div><div class="line">  gulp.watch(&apos;src/css/*.css&apos;, [&apos;css&apos;]);</div><div class="line"> </div><div class="line">  // Watch .js files</div><div class="line">  gulp.watch(&apos;src/js/*.js&apos;, [&apos;lint&apos;, &apos;js&apos;]);</div><div class="line"> </div><div class="line">  // Watch image files</div><div class="line">  gulp.watch(&apos;src/images/*&apos;, [&apos;img&apos;]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[B+树索引]]></title>
      <url>http://zsr.github.io/2016/08/18/B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h2 id="Mysql-索引原理"><a href="#Mysql-索引原理" class="headerlink" title="Mysql 索引原理"></a>Mysql 索引原理</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p>
<p><img src="/images/B-树.jpg"></p>
<p>B-树有如下特点:</p>
<ul>
<li>所有键值分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，也是一种多路搜索树, 它与B-树的不同之处在于:</p>
<p>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的data)<br>为所有叶子结点增加了一个链指针</p>
<p>简化 B+树 如下图</p>
<p><img src="/images/B+树.jpg"></p>
<h3 id="为什么使用B-B-Tree"><a href="#为什么使用B-B-Tree" class="headerlink" title="为什么使用B-/B+ Tree"></a>为什么使用B-/B+ Tree</h3><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。MySQL 是基于磁盘的数据库系统,索引往往以索引文件的形式存储的磁盘上,索引查找过程中就要产生磁盘I/O消耗,相对于内存存取，I/O存取的消耗要高几个数量级,索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为什么使用B-/+Tree，还跟磁盘存取原理有关。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p>
<p>由于磁盘的存取速度与内存之间鸿沟(访问磁盘的成本大概是访问内存的十万倍左右),为了提高效率,要尽量减少磁盘I/O.磁盘往往不是严格按需读取，而是每次都会预读,磁盘读取完需要的数据,会顺序向后读一定长度的数据放入内存。而这样做的理论依据是计算机科学中著名的局部性原理：</p>
<ul>
<li>当一个数据被用到时，其附近的数据也通常会马上被使用</li>
<li>程序运行期间所需要的数据通常比较集中</li>
</ul>
<p>由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。</p>
<p><strong>MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改).linux 默认页大小为4K(每一次IO读取的数据称之为一页)</strong></p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>实际实现B-Tree还需要使用如下技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。</div><div class="line">假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</div><div class="line">而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</div></pre></td></tr></table></figure>
<h3 id="为什么使用-B-树"><a href="#为什么使用-B-树" class="headerlink" title="为什么使用 B+树"></a>为什么使用 B+树</h3><ul>
<li>B+树更适合外部存储,由于内节点无<code>data</code>域,一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。</li>
<li>Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="external">MySQL索引结构</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql 锁]]></title>
      <url>http://zsr.github.io/2016/08/18/mysql-%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h2><p>数据库为了维护事务的性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><p>悲观锁</p>
<p>  正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>  在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
</li>
<li><p>乐观锁</p>
<p>  相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
</li>
</ul>
<p>乐观锁，大多是基于数据版本（ Version ）记录机制实现。数据版本:即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h3 id="多版本的并发控制协议-以乐观锁为理论基础"><a href="#多版本的并发控制协议-以乐观锁为理论基础" class="headerlink" title="多版本的并发控制协议(以乐观锁为理论基础)"></a>多版本的并发控制协议(以乐观锁为理论基础)</h3><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p>
<p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<p>以MySQL InnoDB为例：</p>
<ul>
<li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)<ul>
<li>select * from table where ?;</li>
</ul>
</li>
<li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li><p>delete from table where ?;</p>
<p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>
</li>
</ul>
</li>
</ul>
<p>插入/更新/删除 操作，都归为当前读.如更新 操作，在数据库中的执行流程：</p>
<p><img src="/images/mysql锁机制1-1.jpg"></p>
<p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>
<p><strong>注：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作(数据操纵语言DML:insert, update, delete)；然后在读取下一条加锁，直至读取完毕。</strong></p>
<h4 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h4><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号(<strong>分别表示该行创建的版本和删除的版本</strong>)，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p>
<ul>
<li>SELECT时:满足以下两个条件innodb会返回该行数据：1)读取创建版本号&lt;=当前事务版本号,2)删除版本号为空或&gt;当前事务版本号。</li>
<li>INSERT时:将新插入的行的创建版本号设置为当前系统的版本号。</li>
<li>DELETE时:将要删除的行的删除版本号设置为当前系统的版本号。</li>
<li>UPDATE时:不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li>
</ul>
<p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。<br>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<h3 id="两段锁"><a href="#两段锁" class="headerlink" title="两段锁"></a>两段锁</h3><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段</p>
<p>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</p>
<p>以mysql为例：</p>
<p><img src="/images/mysql锁机制1-2.jpg"></p>
<p>两段锁协议可以保证事务的并发调度是串行化，加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p>
<h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><p>事务隔离级别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读（Dirty Read)</th>
<th style="text-align:center">不可重复读（NonRepeatable Read)</th>
<th style="text-align:center">幻读（Phantom Read)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读（Read uncommitted）</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">已提交读（Read committed）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">可重复读（Repeatable read）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">可串行化（Serializable ）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
</tr>
</tbody>
</table>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读);针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，<strong>InnoDB默认级别</strong>。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读;mysql RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对<strong>读取的范围加锁(GAP间隙锁)</strong>，新的满足查询条件的记录不能够插入,不存在幻读现象。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><p>不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<h3 id="一条简单SQL的加锁实现分析"><a href="#一条简单SQL的加锁实现分析" class="headerlink" title="一条简单SQL的加锁实现分析"></a>一条简单SQL的加锁实现分析</h3><p>例子：</p>
<p>当id列是二级非唯一索引，RR隔离级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL1：select * from t1 where id = 10;</div><div class="line">SQL2：delete from t1 where id = 10;</div></pre></td></tr></table></figure>
<p>SQL1为简单的select语句，快照读不用加锁。</p>
<p>Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="/images/mysql锁机制1-3.jpg"></p>
<p>GAP锁，就是RR隔离级别相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p>
<p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p>
<p><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jstack命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jstack%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jstack命令使用"><a href="#jstack命令使用" class="headerlink" title="jstack命令使用"></a>jstack命令使用</h2><p>jstack可用于导出java运用程序的线程堆栈，其基本使用语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack [<span class="_">-l</span>] pid</div></pre></td></tr></table></figure>
<p>-l 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.</p>
<h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><p>下面这段代码运行之后会出现死锁现象(因为线程1持有lock1，在等待lock2，线程2持有lock2在等待lock1，造成了循环等待，形成死锁)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zsr.test.lock;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * Created by david.zhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程1执行...."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (lock1) &#123;</div><div class="line">                        System.out.println(<span class="string">"线程2执行..."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行这段代码，然后使用jstack命令导出这个程序的线程堆栈信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:public nali$ jstack <span class="_">-l</span> 35072 &gt; /Users/nali/deadlock.txt</div></pre></td></tr></table></figure>
<p>打开导出的线程堆栈信息文件，文件末尾如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Found one Java-level deadlock:</div><div class="line"></div><div class="line">=============================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d48432b8 (object 0x00000007d558e9d8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-0&quot;</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">  waiting to lock monitor 0x00007fe6d4844758 (object 0x00000007d558e9e8, a java.lang.Object),</div><div class="line">  which is held by &quot;Thread-1&quot;</div><div class="line"></div><div class="line">Java stack information for the threads listed above:</div><div class="line"></div><div class="line">===================================================</div><div class="line">&quot;Thread-1&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$2.run(TestDeadLock.java:39)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line">&quot;Thread-0&quot;:</div><div class="line">	at com.zsr.test.lock.TestDeadLock$1.run(TestDeadLock.java:23)</div><div class="line">	- waiting to lock &lt;0x00000007d558e9e8&gt; (a java.lang.Object)</div><div class="line">	- locked &lt;0x00000007d558e9d8&gt; (a java.lang.Object)</div><div class="line">	at java.lang.Thread.run(Thread.java:745)</div><div class="line"></div><div class="line">Found 1 deadlock.</div></pre></td></tr></table></figure>
<p>导出的线程堆栈文件中明确提示发现死锁，并且指明了死锁的原因。</p>
<p>jstack不仅能够导出线程堆栈，还能自动进行死锁检测，输出线程死锁原因。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jmap命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jmap%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jmap命令使用"><a href="#jmap命令使用" class="headerlink" title="jmap命令使用"></a>jmap命令使用</h2><p>jmap是一个多功能的命令。它可以生成java程序的堆dump文件，也可以查看堆内对象实例的统计信息，查看ClassLoader的信息以及Finalizer队列。</p>
<h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><ul>
<li>导出对象统计信息</li>
</ul>
<p>下面的命令生成PID为24205的java成粗的对象的统计信息，并输出到out.txt文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -histo 24205 &gt; /Users/nali/out.txt</div></pre></td></tr></table></figure>
<p>生成的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> num     #instances         #bytes  class name</div><div class="line">----------------------------------------------</div><div class="line">   1:        962520       23100480  java.lang.Long</div><div class="line">   2:        481260       19250400  com.ximalaya.test.Ip</div><div class="line">   3:        962779       15404464  java.lang.Integer</div><div class="line">   4:        481300       15401600  java.util.HashMap$Entry</div><div class="line">   5:          6362        9556232  [I</div><div class="line">   6:            19        7341744  [Ljava.util.HashMap$Entry;</div><div class="line">   7:           319        2174856  [Ljava.lang.Object;</div><div class="line">   8:          6060         781024  &lt;methodKlass&gt;</div><div class="line">   9:          6060         692032  &lt;constMethodKlass&gt;</div><div class="line">  10:           415         486208  &lt;constantPoolKlass&gt;</div><div class="line">  11:           378         296288  &lt;constantPoolCacheKlass&gt;</div><div class="line">  12:           415         285880  &lt;instanceKlassKlass&gt;</div><div class="line">  13:          1358         156272  [C</div><div class="line">  14:           573          94240  [B</div><div class="line">  15:           125          52928  &lt;methodDataKlass&gt;</div><div class="line">  16:           478          46680  java.lang.Class</div><div class="line">  17:           704          45152  [[I</div><div class="line">  18:           631          38168  [S</div><div class="line">  19:          1334          32016  java.lang.String</div><div class="line">  20:            46          25024  &lt;objArrayKlassKlass&gt;</div><div class="line">  21:           101           6464  java.net.URL</div><div class="line">  22:            79           5688  java.lang.reflect.Field</div><div class="line">  23:             8           4352  &lt;typeArrayKlassKlass&gt;</div><div class="line">  24:            96           3840  java.util.LinkedHashMap$Entry</div><div class="line">  25:           119           3808  java.util.Hashtable$Entry</div><div class="line">  26:            94           3760  java.lang.ref.SoftReference</div><div class="line">  27:            91           2912  java.util.concurrent.ConcurrentHashMap$HashEntry</div><div class="line">  28:            61           2432  [Ljava.lang.String;</div></pre></td></tr></table></figure>
<p>从文件中可以看到，统计信息显示了内存中实例的数量和合计。</p>
<ul>
<li>导出程序堆快照</li>
</ul>
<p>下面的命令导出PID为24205的java程序当前的堆快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -dump:format=b,file=dump.bin 24205</div><div class="line">Dumping heap to /Users/nali/dump.bin ...</div><div class="line">Heap dump file created</div></pre></td></tr></table></figure>
<p>该命令成功地将运用程序的当前的堆快照导出到了dump.bin文件，之后可以使用Visual VM，MAT等工具分析对快照文件。</p>
<ul>
<li>查看java 堆（heap）使用情况</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jmap -heap 30192</div><div class="line">Attaching to process ID 30192, please wait...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 24.79-b02</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC with 4 thread(s)</div><div class="line"></div><div class="line">Heap Configuration: //堆内存初始化配置</div><div class="line">   //对应jvm启动参数-XX:M<span class="keyword">in</span>HeapFreeRatio设置JVM堆最小空闲比率</div><div class="line">   M<span class="keyword">in</span>HeapFreeRatio = 0 </div><div class="line">   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率</div><div class="line">   MaxHeapFreeRatio = 100 </div><div class="line">   //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</div><div class="line">   MaxHeapSize      = 2147483648 (2048.0MB)</div><div class="line">   //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</div><div class="line">   NewSize          = 1310720 (1.25MB)</div><div class="line">   //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</div><div class="line">   MaxNewSize       = 17592186044415 MB</div><div class="line">   //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</div><div class="line">   OldSize          = 5439488 (5.1875MB)</div><div class="line">   //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</div><div class="line">   NewRatio         = 2</div><div class="line">   //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </div><div class="line">   SurvivorRatio    = 8</div><div class="line">   //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</div><div class="line">   PermSize         = 21757952 (20.75MB)</div><div class="line">   //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</div><div class="line">   MaxPermSize      = 85983232 (82.0MB)</div><div class="line">   G1HeapRegionSize = 0 (0.0MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space: //Eden区内存分布</div><div class="line">   //Eden区总容量</div><div class="line">   capacity = 136839168 (130.5MB)</div><div class="line">   //Eden区已使用</div><div class="line">   used     = 62349088 (59.460723876953125MB)</div><div class="line">   //Eden区剩余容量</div><div class="line">   free     = 74490080 (71.03927612304688MB)</div><div class="line">   //Eden区使用比率</div><div class="line">   45.56377308578784% used</div><div class="line">From Space: //其中一个Survivor区的内存分布</div><div class="line">   capacity = 17301504 (16.5MB)</div><div class="line">   used     = 17299704 (16.49828338623047MB)</div><div class="line">   free     = 1800 (0.00171661376953125MB)</div><div class="line">   99.98959628018466% used</div><div class="line">To Space: //另一个Survivor区的内存分布</div><div class="line">   capacity = 27262976 (26.0MB)</div><div class="line">   used     = 0 (0.0MB)</div><div class="line">   free     = 27262976 (26.0MB)</div><div class="line">   0.0% used</div><div class="line">PS Old Generation //当前的Old区内存分布</div><div class="line">   capacity = 89128960 (85.0MB)</div><div class="line">   used     = 35824408 (34.164817810058594MB)</div><div class="line">   free     = 53304552 (50.835182189941406MB)</div><div class="line">   40.19390330595129% used</div><div class="line">PS Perm Generation //当前的 “永生代” 内存分布</div><div class="line">   capacity = 22020096 (21.0MB)</div><div class="line">   used     = 2801672 (2.6718826293945312MB)</div><div class="line">   free     = 19218424 (18.32811737060547MB)</div><div class="line">   12.723250616164435% used</div><div class="line"></div><div class="line">734 interned Strings occupying 47744 bytes.</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jstat命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jstat%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jstat命令使用"><a href="#jstat命令使用" class="headerlink" title="jstat命令使用"></a>jstat命令使用</h2><p>jstat是一个可以用于观察java应用程序运行时相关信息的工具，功能非常强大，可以通过它<strong>查看堆信息的详细情况。</strong></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>jstat命令的基本使用语法如下：</p>
<p><strong>jstat -option [-t] [-h] pid [interval] [count]</strong></p>
<ul>
<li>选项option可以由以下值构成。<ul>
<li>-class：显示ClassLoader的相关信息。</li>
<li>-compiler：显示JIT编译的相关信息。</li>
<li><strong>-gc：显示与gc相关的堆信息。</strong></li>
<li>-gccapacity：显示各个代的容量及使用情况。</li>
<li>-gccause：显示垃圾回收的相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因。</li>
<li>-gcnew：显示新生代信息。</li>
<li>-gcnewcapacity：显示新生代大小与使用情况。</li>
<li>-gcold：显示老生代和永久代的信息。</li>
<li>-gcoldcapacity：显示老年代的大小。</li>
<li>-gcpermcapacity：显示永久代的大小。</li>
<li>-gcutil：显示垃圾收集信息。</li>
<li>-printcompilation：输出JIT编译的方法信息。</li>
</ul>
</li>
<li>-t参数可以在输出信息前面加上一个Timestamp列，显示程序运行的时间。</li>
<li>-h参数可以在周期性的数据输出时，输出多少行数据后，跟着输出一个表头信息。</li>
<li>interval参数用于指定输出统计数据的周期，单位为毫秒(ms)。</li>
<li>count参数用于指定一共输出多少次数据。</li>
</ul>
<h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><h5 id="class使用"><a href="#class使用" class="headerlink" title="-class使用"></a>-class使用</h5><p>下面命令输出pid为2500这个进程的ClassLoader相关信息，每秒统计一次信息，一共输出3次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -class -t 13640 1000 3</div><div class="line">Timestamp       Loaded  Bytes  Unloaded  Bytes     Time</div><div class="line">1522.7          414     827.5      0     0.0       0.13</div><div class="line">1523.7          414     827.5      0     0.0       0.13</div><div class="line">1524.7          414     827.5      0     0.0       0.13</div></pre></td></tr></table></figure>
<p>Loaded表示载入的类的数量，第一个Bytes表示载入的类的合计大小，Unloaded表示卸载的类数量，第二个Bytes表示卸载的类的合计大小，Time表示加载和卸载类花的总的时间。</p>
<h5 id="compiler使用"><a href="#compiler使用" class="headerlink" title="-compiler使用"></a>-compiler使用</h5><p>下面的命令查看JIT编译的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -compiler -t 13640</div><div class="line">Timestamp       Compiled Failed Invalid   Time   FailedType FailedMethod</div><div class="line">         1814.8       99      0       0     0.51          0</div></pre></td></tr></table></figure>
<p>Compiled表示编译任务执行的次数，Failed表示编译失败的次数，Invalid表示编译不可用的次数，Time表示编译的总耗时，FailedType表示最后一次编译的类型，FailedMethod表示最后一次编译失败的类名和方法名。</p>
<h5 id="gc使用"><a href="#gc使用" class="headerlink" title="-gc使用"></a>-gc使用</h5><p>下面的命令显示与gc相关的堆信息的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gc 16309</div><div class="line">S0C     S1C     S0U      S1U   EC       EU        OC         OU          MC     MU </div><div class="line">45056.0 55296.0 44588.0  0.0   336896.0 222238.4  171520.0   86902.0     -      - </div><div class="line">CCSC CCSU YGC YGCT   FGC     FGCT      GCT</div><div class="line">-     -    8  0.312   1      1.328    1.640</div></pre></td></tr></table></figure>
<ul>
<li>S0C：s0(from)的大小(KB)</li>
<li>S1C：s1(from)的大小(KB)</li>
<li>S0U：s0(from)已使用的空间(KB)</li>
<li>S1U：s1(from)已经使用的空间(KB)</li>
<li>EC：eden区的大小(KB)</li>
<li>EU：eden区已经使用的空间(KB)</li>
<li>OC：老年代大小(KB)</li>
<li>OU：老年代已经使用的空间(KB)</li>
<li>MC：方法区大小(KB)</li>
<li>MU：方法区使用大小(KB)</li>
<li>CCSC:压缩类空间大小(KB)</li>
<li>CCSU:压缩类空间使用大小(KB)</li>
<li>YGC：新生代gc次数</li>
<li>YGCT：新生代gc耗时</li>
<li>FGC：Full gc次数</li>
<li>FGCT：Full gc耗时</li>
<li>GCT：gc总耗时</li>
</ul>
<h5 id="gccapacity使用"><a href="#gccapacity使用" class="headerlink" title="-gccapacity使用"></a>-gccapacity使用</h5><p>下面的命令显示了各个代的信息，与-gc相比，它不仅输出了各个代的当前大小，还输出了各个代的最大值与最小值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccapacity 16309</div><div class="line"> NGCMN    NGCMX     NGC     S0C     S1C       EC        OGCMN      OGCMX   </div><div class="line">44032.0 699392.0 626176.0 45056.0 55296.0 336896.0    87040.0    1397760.0    </div><div class="line"> OGC       OC       MCMN    MCMX     MC       CCSMN    CCSMX     CCSC    YGC    FGC</div><div class="line">171520.0  171520.0    -       -      -        -        -        -      8        1</div><div class="line">nalideMacBook-Pro-4:~ nali$</div></pre></td></tr></table></figure>
<ul>
<li>NGCMN：新生代最小值(KB)</li>
<li>NGCMX：新生代最大值(KB)</li>
<li>NGC：当前新生代大小(KB)</li>
<li>OGCMN：老年大最小值(KB)</li>
<li>OGCMX：老年代最大值(KB)</li>
<li>OGC：当前老年代大小(KB)</li>
<li>MCMN：方法区最小值(KB)</li>
<li>MCMX：方法区最大值(KB)</li>
<li>CCSMN：压缩类空间最小值(KB)</li>
<li>CCSMX：压缩类空间最大值(KB)</li>
</ul>
<h5 id="gccause使用"><a href="#gccause使用" class="headerlink" title="-gccause使用"></a>-gccause使用</h5><p>下面命令显示最近一次gc的原因，以及当前gc的原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gccause 16309</div><div class="line">S0     S1     E      O      M     CCS    YGC    YGCT    FGC    FGCT     GCT   </div><div class="line">98.96  0.00  65.97  50.67   -      -      8      0.312    1    1.328    1.640</div><div class="line">LGCC                  GCC        </div><div class="line">Allocation Failure   No GC</div></pre></td></tr></table></figure>
<ul>
<li>LGCC：上次gc的原因，可以看到上次gc的原因是Allocation Failure</li>
<li>GCC：当前gc的原因，当前没有gc</li>
</ul>
<h5 id="gcnew使用"><a href="#gcnew使用" class="headerlink" title="-gcnew使用"></a>-gcnew使用</h5><p>下面的命令显示新生代的详细信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnew 16309</div><div class="line"> S0C    S1C     S0U        S1U  TT MTT  DSS      EC       EU        YGC   YGCT</div><div class="line">45056.0 55296.0 44588.0    0.0  5  15   55296.0  336896.0 222238.4  8     0.312</div></pre></td></tr></table></figure>
<ul>
<li>TT：新生代对象晋升到老年代对象的年龄。</li>
<li>MTT：新生代对象晋升到老年代对象的年龄的最大值。</li>
<li>DSS：所需的Survivor区的大小。</li>
</ul>
<h5 id="gcnewcapacity使用"><a href="#gcnewcapacity使用" class="headerlink" title="-gcnewcapacity使用"></a>-gcnewcapacity使用</h5><p>下面的命令详细输出了新生代各个区的大小信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcnewcapacity 16309</div><div class="line">NGCMN    NGCMX    NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      </div><div class="line">44032.0  699392.0 626176.0 232960.0  45056.0 232960.0  55296.0   698368.0  336896.0     </div><div class="line">YGC   FGC</div><div class="line">8     1</div><div class="line">```   </div><div class="line"></div><div class="line">- S0CMX：s0区的最大值(KB)</div><div class="line">- S1CMX：s1区的最大值(KB)</div><div class="line">- ECMX：eden区的最大值(KB)</div><div class="line"></div><div class="line"><span class="comment">##### -gcold使用</span></div><div class="line"></div><div class="line">下面的命令显示老年代gc概况：</div><div class="line"></div><div class="line"></div><div class="line">``` bash</div><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcold 16309</div><div class="line">MC   MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</div><div class="line">-    -        -        -     171520.0      86902.0     8     1      1.328    1.640</div></pre></td></tr></table></figure>
<h5 id="gcoldcapacity使用"><a href="#gcoldcapacity使用" class="headerlink" title="-gcoldcapacity使用"></a>-gcoldcapacity使用</h5><p>下面的命令用于显示老年代的容量信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jstat -gcoldcapacity 16309</div><div class="line">OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</div><div class="line">87040.0   1397760.0    171520.0    171520.0     8     1    1.328    1.640</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java调试-jps命令]]></title>
      <url>http://zsr.github.io/2016/08/18/java%E8%B0%83%E8%AF%95-jps%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="jps命令使用"><a href="#jps命令使用" class="headerlink" title="jps命令使用"></a>jps命令使用</h2><p>jps命令类似于linux下的ps命令，用于列出当前正在运行的所有java进程。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>直接运行不加任何参数就能列出所有java进程的pid和类的短名称。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps</div><div class="line">13698 Jps</div><div class="line">13640 TestJava</div><div class="line">50360</div></pre></td></tr></table></figure>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-q参数</li>
</ul>
<p>-q可以指定jps只列出pid,而不输出类的短名称，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -q</div><div class="line">13959</div><div class="line">13640</div><div class="line">50360</div></pre></td></tr></table></figure>
<ul>
<li>-m参数</li>
</ul>
<p>-m参数可以用于列出传递给java进程主函数的参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -m</div><div class="line">13640 TestJava</div><div class="line">50360</div><div class="line">14029 Jps -m</div></pre></td></tr></table></figure>
<p>可以看到传递给jps（jps本身也是java进程）进程的参数就是-m</p>
<ul>
<li>-l参数</li>
</ul>
<p>-l参数用于输出主类的完整路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -l</div><div class="line">14198 sun.tools.jps.Jps</div><div class="line">13640 com.david.test.TestJava</div><div class="line">50360</div></pre></td></tr></table></figure>
<ul>
<li>-v参数</li>
</ul>
<p>-v参数可以列出传递给java虚拟机的参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nalideMacBook-Pro-4:~ nali$ jps -v</div><div class="line">14290 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home -Xms8m</div><div class="line">13640 TestJava -agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:56353 -Dfile.encoding=UTF-8</div><div class="line">50360  -Dosgi.requiredJavaVersion=1.7 -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts -XX:MaxPermSize=256m -Xms256m -Xmx2048m -Xdock:icon=../Resources/Eclipse.icns -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hashtable]]></title>
      <url>http://zsr.github.io/2016/08/17/HashTable/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-Hashtable"><a href="#OpenJDK-源代码阅读之-Hashtable" class="headerlink" title="OpenJDK 源代码阅读之 Hashtable"></a>OpenJDK 源代码阅读之 Hashtable</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.Dictionary&lt;K,V&gt;</div><div class="line">        java.util.Hashtable&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Hashtable&lt;K,V&gt;</div><div class="line">    extends Dictionary&lt;K,V&gt;</div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</div></pre></td></tr></table></figure>
<ul>
<li>hashtable put()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="comment">//在此处计算key的hash值，如果此处key为null，则直接抛出空指针异常。</span></div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>hashtable get()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>get()和put()都使用了<code>synchronized</code>加锁，容易阻塞，效率低。<strong>hashtable不允许value为null</strong></p>
<ul>
<li>hashMap put()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">            inflateTable(threshold);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>hashMap get()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> getForNullKey();</div><div class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>hashMap多线程环境不安全。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap]]></title>
      <url>http://zsr.github.io/2016/08/17/ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-ConcurrentHashMap"><a href="#OpenJDK-源代码阅读之-ConcurrentHashMap" class="headerlink" title="OpenJDK 源代码阅读之 ConcurrentHashMap"></a>OpenJDK 源代码阅读之 ConcurrentHashMap</h1><hr>
<h3 id="ConcurrentHashMap-作用"><a href="#ConcurrentHashMap-作用" class="headerlink" title="ConcurrentHashMap 作用"></a>ConcurrentHashMap 作用</h3><p>多线程环境下，使用<code>Hashmap</code>进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。虽然已经有一个线程安全的<code>HashTable</code>，但是HashTable容器使用synchronized（他的get和put方法的实现代码如下）来保证线程安全，在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，访问其他同步方法的线程就可能会进入阻塞或者轮训状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<p>Hashtable get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">            <span class="keyword">return</span> (V)e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hashtable put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p>
<p><img src="/images/ConcurrentHashMap.png"></p>
<p>从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承ReentrantLock）下面包含很多个HashEntry列表数组。对于一个key，需要经过三次（为什么要hash三次下文会详细讲解）hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p>
<ul>
<li>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；</li>
<li>将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；</li>
<li>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</li>
</ul>
<a id="more"></a>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>构造函数的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</div><div class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">            concurrencyLevel = MAX_SEGMENTS;</div><div class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></div><div class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">            ++sshift;</div><div class="line">            ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">            ++c;</div><div class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">        <span class="keyword">while</span> (cap &lt; c)</div><div class="line">            cap &lt;&lt;= <span class="number">1</span>;</div><div class="line">        <span class="comment">// create segments and segments[0]</span></div><div class="line">        Segment&lt;K,V&gt; s0 =</div><div class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">        <span class="keyword">this</span>.segments = ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。</strong></p>
<ul>
<li>initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为static final int DEFAULT_INITIAL_CAPACITY = 16;</li>
<li>loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于loadFactor * 最大容量时就需要rehash，扩容。默认值为static final float DEFAULT_LOAD_FACTOR = 0.75f;</li>
<li>concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。</li>
</ul>
<p><strong>初始化的一些动作：</strong></p>
<ul>
<li>验证参数的合法性，如果不合法，直接抛出异常。</li>
<li>concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为static final int MAX_SEGMENTS = 1 &lt;&lt; 16;，如果超过这个值，设置为这个值。</li>
<li>然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令segmentShift = 32 - sshift，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做&amp;运算确定Segment的索引。</li>
<li>检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;。</li>
<li>然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。</li>
<li>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</li>
</ul>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>put操作的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">      Segment&lt;K,V&gt; s;</div><div class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">      <span class="keyword">int</span> hash = hash(key);</div><div class="line">      <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">      <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></div><div class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></div><div class="line">          s = ensureSegment(j);</div><div class="line">      <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>操作步骤如下：</strong></p>
<ul>
<li>判断value是否为null，如果为null，直接抛出异常。</li>
<li>key通过一次hash运算得到一个hash值。(这个hash运算下文详说)</li>
<li>将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。<br>在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：<br>0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&amp;运算，也就是取最后四位的值。这个值确定Segment的索引。</li>
<li>使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。</li>
<li>向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</li>
</ul>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>get操作的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        <span class="keyword">int</span> h = hash(key);</div><div class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>操作步骤为：</strong></p>
<ul>
<li>和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。</li>
<li>使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</li>
</ul>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：<strong>先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。</strong>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">        <span class="keyword">int</span> size;</div><div class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></div><div class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></div><div class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></div><div class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></div><div class="line">                &#125;</div><div class="line">                sum = <span class="number">0L</span>;</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">                overflow = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</div><div class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</div><div class="line">                        sum += seg.modCount;</div><div class="line">                        <span class="keyword">int</span> c = seg.count;</div><div class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</div><div class="line">                            overflow = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum == last)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                last = sum;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                    segmentAt(segments, j).unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p><code>一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。</code></p>
<h3 id="关于hash"><a href="#关于hash" class="headerlink" title="关于hash"></a>关于hash</h3><table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">哈希算法</td>
<td style="text-align:center">hash algorithm</td>
<td style="text-align:center">是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。</td>
</tr>
<tr>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">hash table</td>
<td style="text-align:center">根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</td>
</tr>
</tbody>
</table>
<p>hash的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = hashSeed;</div><div class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h ^= k.hashCode();</div><div class="line">        <span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line">        <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">        h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">        h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">        h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">        h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里用到了Wang/Jenkins hash算法的变种，主要的目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(Integer.parseInt(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div><div class="line">System.out.println(Integer.parseInt(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</div></pre></td></tr></table></figure>
<p>这些数字得到的hash值都是一样的，全是15，所以如果不进行第一次预hash，发生冲突的几率还是很大的，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</div><div class="line">1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000</div><div class="line">0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</div><div class="line">1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</div></pre></td></tr></table></figure>
<p>可以看到每一位的数据都散开了，并且ConcurrentHashMap中是使用预hash值的高位参与运算的。比如之前说的先将hash值向右按位移动28位，再与15做&amp;运算，得到的结果都别为：4，15，7，8，没有冲突！</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>ConcurrentHashMap中的key和value值都不能为null。<br>ConcurrentHashMap的整个操作过程中大量使用了Unsafe类来获取Segment/HashEntry，这里Unsafe的主要作用是提供原子操作。Unsafe这个类比较恐怖，破坏力极强，一般场景不建议使用，如果有兴趣可以到这里做详细的了解Java中鲜为人知的特性<br>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap/" target="_blank" rel="external">深入分析ConcurrentHashMap</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BlockingQueue]]></title>
      <url>http://zsr.github.io/2016/08/16/BlockingQueue/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-BlockingQueue"><a href="#OpenJDK-源码阅读之-BlockingQueue" class="headerlink" title="OpenJDK 源码阅读之 BlockingQueue"></a>OpenJDK 源码阅读之 BlockingQueue</h1><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在java.util.Concurrent包中，BlockingQueue很好的解决了在多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。同时，BlockingQueue也用于java自带线程池的缓冲队列中，了解BlockingQueue也有助于理解线程池的工作模型。</p>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h4><p>该接口属于队列，所以继承了Queue接口，该接口最重要的五个方法分别是offer方法，poll方法，put方法，take方法和drainTo方法。</p>
<p>offer方法和poll方法分别有一个静态重载方法，分别是offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)方法。其意义是在限定时间内存入或取出对象，如果不能存入取出则返回false。</p>
<p>put方法会在当队列存储对象达到限定值时阻塞线程，而在队列不为空时唤醒被take方法所阻塞的线程。take方法是相反的。</p>
<p>drainTo方法可批量获取队列中的元素。</p>
<h4 id="常见的BlockingQueue实现"><a href="#常见的BlockingQueue实现" class="headerlink" title="常见的BlockingQueue实现"></a>常见的BlockingQueue实现</h4><ul>
<li>LinkedBlockingQueue</li>
</ul>
<p>LinkedBlockingQueue是比较常见的BlockingQueue的实现，他是基于链表的阻塞队列。在创建该对象时如果不指定可存储对象个数大小时，默认为Integer.MAX_VALUE。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p>LinkedBlockingQueue内部使用了独立的两把锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p>put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        try &#123;</div><div class="line">            while (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            if (c + 1 &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>offer方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    public boolean offer(E e) &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        if (count.get() == capacity)</div><div class="line">            return false;</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        putLock.lock();</div><div class="line">        try &#123;</div><div class="line">            if (count.get() &lt; capacity) &#123;</div><div class="line">                enqueue(node);</div><div class="line">                c = count.getAndIncrement();</div><div class="line">                if (c + 1 &lt; capacity)</div><div class="line">                    notFull.signal();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">        return c &gt;= 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法的区别是put方法在容量达到上限时会阻塞，而offer方法则会直接返回false。</p>
<ul>
<li>ArrayBlockingQueue</li>
</ul>
<p>ArrayBlockingQueue是基于数组的阻塞队列，除了有一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。<br>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p>是一种没有缓冲的阻塞队列，在生产者put的同时必须要有一个消费者进行take，否则就会阻塞。声明一个SynchronousQueue有两种不同的方式。公平模式和非公平模式的区别:如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<ul>
<li>PriorityBlockingQueue和DelayQueue</li>
</ul>
<p>PriorityBlockingQueue是基于优先级的阻塞队列，该队列不会阻塞生产者，只会阻塞消费者。<br>DelayQueue队列存储的对象只有指定的延迟时间到了才能被取出，该队列也不会阻塞生产者。</p>
<h4 id="BlockingQueue的使用"><a href="#BlockingQueue的使用" class="headerlink" title="BlockingQueue的使用"></a>BlockingQueue的使用</h4><p>在处理多线程生产者消费者问题时的演示代码：</p>
<p>main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line"> </div><div class="line">public class BlockingQueueTest &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1000);</div><div class="line">        Thread p1 = new Thread(new Producer(queue),&quot;producer1&quot;);</div><div class="line">        Thread p2 = new Thread(new Producer(queue),&quot;producer2&quot;);</div><div class="line">        Thread c1 = new Thread(new Consumer(queue),&quot;consumer1&quot;);</div><div class="line">        Thread c2 = new Thread(new Consumer(queue),&quot;consumer2&quot;);</div><div class="line"> </div><div class="line">        p1.start();</div><div class="line">        p2.start();</div><div class="line">        c1.start();</div><div class="line">        c2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Producer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Producer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                queue.put(Thread.currentThread().getName()+&quot; product &quot;+i);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                System.err.println(Thread.currentThread().getName() + &quot; error&quot;);</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Consumer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                String str = queue.take();</div><div class="line">                System.out.println(str);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BlockingQueue在并发编程中扮演着重要的角色，既可以自己用来解决生产者消费者问题，也用于java自带线程池的缓冲队列。</p>
<p>参考：</p>
<p><a href="http://wsmajunfeng.iteye.com/blog/1629354" target="_blank" rel="external">BlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashSet]]></title>
      <url>http://zsr.github.io/2016/08/16/HashSet/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashSet"><a href="#OpenJDK-源代码阅读之-HashSet" class="headerlink" title="OpenJDK 源代码阅读之 HashSet"></a>OpenJDK 源代码阅读之 HashSet</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractSet&lt;E&gt;</div><div class="line">            java.util.HashSet&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;</div><div class="line">extends AbstractSet&lt;E&gt;</div><div class="line">implements Set&lt;E&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<ol>
<li>不保证元素次序，甚至不保证次序不随时间变化</li>
<li>基本操作(add, remove, contains, size)常量时间</li>
<li>迭代操作与当前元素个数加底层容量大小成正比</li>
<li>不保证同步</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>总体实现</li>
</ul>
<p>底层是用 <code>HashMap</code> 实现的，<code>Set</code> 中的数据是 <code>HashMap</code> 的 <code>key</code>，所有的 <code>key</code> 指向同一个 <code>value</code>, 此 <code>value</code> 定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>再看一下 <code>add</code>，大概就能明白了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds the specified element to this set if it is not already present.</div><div class="line"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</div><div class="line"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</div><div class="line"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</div><div class="line"> * If this set already contains the element, the call leaves the set</div><div class="line"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be added to this set</div><div class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</div><div class="line"> * element</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>load factor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化中，注意使用的 <code>HashMap</code> 的 load factor 设置为 0.75，如果太小，就设置成 16. </p>
<p><code>HashSet</code> 并没有什么特别之处，几乎没有自己特有的实现，都是调用 <code>HashMap</code> 的方法实现相应的功能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC ApplicationContext]]></title>
      <url>http://zsr.github.io/2016/08/16/ApplicationContext/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以只有1个Servlet的简单情况为例，一般涉及到3个配置文件：web.xml，applicationContext.xml，xxx-servlet.xml。</p>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;  </div><div class="line">         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </div><div class="line">         &lt;param-value&gt;classpath:/applicationContext.xml&lt;/param-value&gt;  </div><div class="line">&lt;/context-param&gt;  </div><div class="line">&lt;listener&gt;  </div><div class="line">         &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </div><div class="line">&lt;/listener&gt;  </div><div class="line">&lt;servlet&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </div><div class="line">         &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </div><div class="line">&lt;/servlet&gt;  </div><div class="line">&lt;servlet-mapping&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;  </div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，系统会生成2个ApplicationContext，确切的说是2个WebApplicationContext.</p>
<h3 id="ROOT-ApplicationContext"><a href="#ROOT-ApplicationContext" class="headerlink" title="ROOT ApplicationContext"></a>ROOT ApplicationContext</h3><p>在Tomcat启动时，通过注册的监听器ContextLoaderListener，Spring初始化WebApplicationContext并保存到ServletContext中，初始化使用的配置文件位置由contextConfigLocation参数确定。该Context为整个框架中的ROOT Context，其他的Context都会作为其子节点或子孙节点进行关联。</p>
<p>WebApplicationContext和ServletContext互相保存对方的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存到ServletContext中  </div><div class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,this.context);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存ServletContext  </div><div class="line">wac.setServletContext(sc);</div></pre></td></tr></table></figure>
<h3 id="xxx-ApplicationContext"><a href="#xxx-ApplicationContext" class="headerlink" title="xxx ApplicationContext"></a>xxx ApplicationContext</h3><p>Tomcat生成xxx Servlet时，DispatcherServlet会使用xxx-servlet.xml（除非显示指定其他文件）初始化WebApplicationContext，将其父节点设为ROOT Context，并保存到ServletContext中。</p>
<p>在createWebApplicationContext()方法中，设置父节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wac.setParent(parent);</div></pre></td></tr></table></figure>
<p>在configureAndRefreshWebApplicationContext()方法中保存ServletContext：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wac.setServletContext(getServletContext());  </div><div class="line">wac.setServletConfig(getServletConfig());</div></pre></td></tr></table></figure>
<p>在initWebApplicationContext()方法中将自己保存到ServletContext中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Publish the context as a servlet context attribute.  </div><div class="line">String attrName = getServletContextAttributeName();  </div><div class="line">getServletContext().setAttribute(attrName, wac);</div></pre></td></tr></table></figure>
<p>ServletContext、ROOT Context和xxx Context三者引用之间的关系如下：</p>
<p><img src="/images/Application关系.jpg"></p>
<p>获取的方法：</p>
<ul>
<li>ServletContext：</li>
</ul>
<p>无论是在ROOT还是xxx Context中，可以通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContext. getServletContext();</div></pre></td></tr></table></figure>
<ul>
<li>ROOT Context：</li>
</ul>
<p>该Context是” org.springframework.web.context. WebApplicationContext. ROOT”为Key保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc)</div></pre></td></tr></table></figure>
<p>在xxx Context中可以通过getParent得到ROOT Context。</p>
<ul>
<li>xxx Context：</li>
</ul>
<p>该Context是以” org.springframework.web.servlet.FrameworkServlet.CONTEXT.xxx”为KEY(xxx为web.xml中定义的Servlet名称)，保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc, String attrName)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 持久化]]></title>
      <url>http://zsr.github.io/2016/08/16/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：</p>
<ul>
<li><p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</p>
</li>
<li><p>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</p>
</li>
<li><p>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</p>
</li>
<li><p>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p>
</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><p>Redis调用fork()，产生一个子进程。</p>
</li>
<li><p>子进程把数据写到一个临时的RDB文件。</p>
</li>
<li><p>当子进程写完新的RDB文件后，把旧的RDB文件替换掉。</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。</p>
</li>
<li><p>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上。</p>
</li>
<li><p>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。</p>
</li>
<li><p>比起AOF，在数据量比较大的情况下，RDB的启动速度更快。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。</p>
</li>
<li><p>RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。</p>
</li>
</ul>
<h4 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><p>默认Redis会把快照文件存储为当前目录下一个名为dump.rdb的文件。要修改文件的存储路径和名称，可以通过修改配置文件redis.conf实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RDB文件名，默认为dump.rdb。</div><div class="line">dbfilename dump.rdb</div><div class="line"></div><div class="line">文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</div><div class="line">dir ./</div></pre></td></tr></table></figure>
<h4 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h4><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save 60 1000</div></pre></td></tr></table></figure>
<p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式为：save &lt;seconds&gt; &lt;changes&gt;</div><div class="line"># 可以设置多个。</div><div class="line">save 900 1 #900秒后至少1个key有变动</div><div class="line">save 300 10 #300秒后至少10个key有变动</div><div class="line">save 60 10000 #60秒后至少10000个key有变动</div></pre></td></tr></table></figure>
<p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop-writes-on-bgsave-error yes</div></pre></td></tr></table></figure>
<h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>默认Redis会采用LZF对数据进行压缩。如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbcompression yes</div></pre></td></tr></table></figure>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>从版本5的RDB的开始，一个CRC64的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用0替代，加载的时候看到0就会直接跳过校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbchecksum yes</div></pre></td></tr></table></figure>
<h4 id="手动生成快照"><a href="#手动生成快照" class="headerlink" title="手动生成快照"></a>手动生成快照</h4><p>Redis提供了两个命令用于手动生成快照:SAVE, BGSAVE。</p>
<h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。因此不建议在生产环境使用这个命令，除非因为某种原因需要去阻止Redis使用子进程进行后台生成快照（例如调用fork(2)出错）。</p>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，会立刻返回OK返回码。Redis会产生一个子进程进行处理并立刻恢复对客户端的服务。在客户端我们可以使用LASTSAVE命令查看操作是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; BGSAVE</div><div class="line">Background saving started</div><div class="line">127.0.0.1:6379&gt; LASTSAVE</div><div class="line">(integer) 1433936394</div></pre></td></tr></table></figure>
<p><strong>注意：配置文件里禁用了快照生成功能不影响SAVE和BGSAVE命令的效果。</strong></p>
<a id="more"></a>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。<strong>默认是每秒fsync一次。</strong>这意味着你最多丢失一秒钟的数据。</p>
</li>
<li><p>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复。</p>
</li>
<li><p>当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上。</p>
</li>
<li><p>AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用FLUSHALL命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来。</p>
</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>在相同的数据集下，AOF文件的大小一般会比RDB文件大。</p>
</li>
<li><p>在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。</p>
</li>
<li><p>在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题。</p>
</li>
</ul>
<h4 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h4><p>把配置项appendonly设为yes：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<h4 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">文件存放目录，与RDB共用。默认为当前工作目录。</div><div class="line">dir ./</div><div class="line"></div><div class="line">默认文件名为appendonly.aof</div><div class="line">appendfilename &quot;appendonly.aof&quot;</div></pre></td></tr></table></figure>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>你可以配置Redis调用fsync的频率，有三个选项：</p>
<ul>
<li><p>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全。</p>
</li>
<li><p>每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。</p>
</li>
<li><p>从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。</p>
</li>
</ul>
<p><strong>推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。</strong>相关配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># appendfsync always</div><div class="line">appendfsync everysec</div><div class="line"># appendfsync no</div></pre></td></tr></table></figure>
<h4 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h4><p>随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件。</p>
<p>工作原理如下：</p>
<ul>
<li><p>Redis调用fork()，产生一个子进程。</p>
</li>
<li><p>子进程把新的AOF写到一个临时文件里。</p>
</li>
<li><p>主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全。</p>
</li>
<li><p>当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里。</p>
</li>
</ul>
<p>我们可以通过配置设置日志重写的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</div><div class="line">如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</div><div class="line">同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</div><div class="line"></div><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure>
<p>要禁用自动的日志重写功能，我们可以把百分比设置为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 0</div></pre></td></tr></table></figure>
<p><strong>注意：Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令。</strong></p>
<h4 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h4><p>如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复：</p>
<ul>
<li><p>备份AOF文件。</p>
</li>
<li><p>使用redis-check-aof命令修复原始的AOF文件：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-check-aof --fix</div></pre></td></tr></table></figure>
<ul>
<li><p>可以使用diff -u命令看下两个文件的差异。</p>
</li>
<li><p>使用修复过的文件重启Redis服务。</p>
</li>
</ul>
<h4 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h4><p>这里只说Redis &gt;= 2.2版本的方式：</p>
<ul>
<li><p>备份一个最新的dump.rdb的文件，并把备份文件放在一个安全的地方。</p>
</li>
<li><p>运行以下两条命令：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli config set appendonly yes</div><div class="line">$ redis-cli config set save &quot;&quot;</div></pre></td></tr></table></figure>
<ul>
<li><p>确保数据跟切换前一致。</p>
</li>
<li><p>确保数据正确的写到AOF文件里。</p>
</li>
</ul>
<p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong><br><strong>记得对配置文件redis.conf进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>建议的备份方法：</p>
<ul>
<li><p>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</p>
</li>
<li><p>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</p>
</li>
<li><p>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://redis.io/topics/persistence" target="_blank" rel="external">redis</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC controller与请求映射]]></title>
      <url>http://zsr.github.io/2016/08/15/SpringMVC-controller%E4%B8%8E%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[DispatchServlet 初始化]]></title>
      <url>http://zsr.github.io/2016/08/15/DispatchServlet-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul>
<li>Servlet:</li>
</ul>
<p>所有的Servlet都是实现了Servlet接口，该接口提供了servlet生命周期的一些方法，如: init(), destroy(),service()&lt;每次接收到请求都由该方法来处理&gt;等，没有具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException;</div></pre></td></tr></table></figure>
<ul>
<li>GenericServlet:<br>该类实现了Servlet的init()方法以及提供了获取初始化参数的方法。init方法的实现最后需要由子类实现</li>
</ul>
<p>获取初始化参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ServletConfig sc = getServletConfig();</div><div class="line">        if (sc == null) &#123;</div><div class="line">            throw new IllegalStateException(</div><div class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return sc.getInitParameter(name);</div></pre></td></tr></table></figure>
<p>init()初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">this.config = config;</div><div class="line">this.init();//调用下面的init()方法（没有具体实现）</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void init() throws ServletException &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>HttpServlet<br>实现了servlet的service()方法，所有的请求都由该方法来处理，判断走doGet()还是doPost()等等。<br>该方法是有Tomcat容器来调用的(init()方法也是)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req, ServletResponse res)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        HttpServletRequest  request;</div><div class="line">        HttpServletResponse response;</div><div class="line">        </div><div class="line">        if (!(req instanceof HttpServletRequest &amp;&amp;</div><div class="line">                res instanceof HttpServletResponse)) &#123;</div><div class="line">            throw new ServletException(&quot;non-HTTP request or response&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        request = (HttpServletRequest) req;</div><div class="line">        response = (HttpServletResponse) res;</div><div class="line"></div><div class="line">        service(request, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        String method = req.getMethod();</div><div class="line"></div><div class="line">        if (method.equals(METHOD_GET)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            if (lastModified == -1) &#123;</div><div class="line">                // servlet doesn&apos;t support if-modified-since, no reason</div><div class="line">                // to go through further expensive logic</div><div class="line">                doGet(req, resp);</div><div class="line">            &#125; else &#123;</div><div class="line">                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</div><div class="line">                if (ifModifiedSince &lt; lastModified) &#123;</div><div class="line">                    // If the servlet mod time is later, call doGet()</div><div class="line">                    // Round down to the nearest second for a proper compare</div><div class="line">                    // A ifModifiedSince of -1 will always be less</div><div class="line">                    maybeSetLastModified(resp, lastModified);</div><div class="line">                    doGet(req, resp);</div><div class="line">                &#125; else &#123;</div><div class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_HEAD)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            maybeSetLastModified(resp, lastModified);</div><div class="line">            doHead(req, resp);</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_POST)) &#123;</div><div class="line">            doPost(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_PUT)) &#123;</div><div class="line">            doPut(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_DELETE)) &#123;</div><div class="line">            doDelete(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</div><div class="line">            doOptions(req,resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_TRACE)) &#123;</div><div class="line">            doTrace(req,resp);</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            //</div><div class="line">            // Note that this means NO servlet supports whatever</div><div class="line">            // method was requested, anywhere on this server.</div><div class="line">            //</div><div class="line"></div><div class="line">            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class="line">            Object[] errArgs = new Object[1];</div><div class="line">            errArgs[0] = method;</div><div class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</div><div class="line">            </div><div class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>以上几个类都是不需要Spring框架的参与。</p>
<a id="more"></a>
<ul>
<li>HttpServletBean</li>
</ul>
<p>该类最终重载实现了GenericServlet类的init()方法。注意: 方法是final类型，不可以被继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public final void init() throws ServletException &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Set bean properties from init parameters.</div><div class="line">		try &#123;</div><div class="line">			PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</div><div class="line">			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class="line">			ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</div><div class="line">			bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">			initBeanWrapper(bw);</div><div class="line">			bw.setPropertyValues(pvs, true);</div><div class="line">		&#125;</div><div class="line">		catch (BeansException ex) &#123;</div><div class="line">			logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Let subclasses do whatever initialization they like.</div><div class="line">		initServletBean();</div><div class="line"></div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的类需要调用initServletBean()方法，该方法在HttpServletBean类中没有具体实现，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void initServletBean() throws ServletException &#123;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FrameworkServlet<br>实现了HttpServletBean类的initServletBean()方法，初始化WebApplicationContext。并且重载了HttpServlet类的service()方法，以及所有的doGet(),doPost()方法, 这些方法最后都调用了doService()方法(该类没有实现doService(),由DispatchServlet类具体实现)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	protected final void initServletBean() throws ServletException &#123;</div><div class="line">		getServletContext().log(&quot;Initializing Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization started&quot;);</div><div class="line">		&#125;</div><div class="line">		long startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">		    //初始化WebApplicationContext</div><div class="line">			this.webApplicationContext = initWebApplicationContext();</div><div class="line">			initFrameworkServlet();</div><div class="line">		&#125;</div><div class="line">		catch (ServletException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line">		catch (RuntimeException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			long elapsedTime = System.currentTimeMillis() - startTime;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization completed in &quot; +</div><div class="line">					elapsedTime + &quot; ms&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class="line">		WebApplicationContext rootContext =</div><div class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">		WebApplicationContext wac = null;</div><div class="line"></div><div class="line">		if (this.webApplicationContext != null) &#123;</div><div class="line">			// A context instance was injected at construction time -&gt; use it</div><div class="line">			wac = this.webApplicationContext;</div><div class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">				if (!cwac.isActive()) &#123;</div><div class="line">					// The context has not yet been refreshed -&gt; provide services such as</div><div class="line">					// setting the parent context, setting the application context id, etc</div><div class="line">					if (cwac.getParent() == null) &#123;</div><div class="line">						// The context instance was injected without an explicit parent -&gt; set</div><div class="line">						// the root application context (if any; may be null) as the parent</div><div class="line">						cwac.setParent(rootContext);</div><div class="line">					&#125;</div><div class="line">					configureAndRefreshWebApplicationContext(cwac);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance was injected at construction time -&gt; see if one</div><div class="line">			// has been registered in the servlet context. If one exists, it is assumed</div><div class="line">			// that the parent context (if any) has already been set and that the</div><div class="line">			// user has performed any initialization such as setting the context id</div><div class="line">			wac = findWebApplicationContext();</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance is defined for this servlet -&gt; create a local one</div><div class="line">			wac = createWebApplicationContext(rootContext);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!this.refreshEventReceived) &#123;</div><div class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</div><div class="line">			// support or the context injected at construction time had already been</div><div class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</div><div class="line">			onRefresh(wac);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.publishContext) &#123;</div><div class="line">			// Publish the context as a servlet context attribute.</div><div class="line">			String attrName = getServletContextAttributeName();</div><div class="line">			getServletContext().setAttribute(attrName, wac);</div><div class="line">			if (this.logger.isDebugEnabled()) &#123;</div><div class="line">				this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() +</div><div class="line">						&quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return wac;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的方法初始化一个WebApplicationContext.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		// For subclasses: do nothing by default.</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>DispatcherServlet</li>
</ul>
<p>实现FrameworkServlet类的onRefresh()方法，在该方法中具体初始化Spring MVC需要的一些策略对象。如HandlerMappings，HandlerAdapters等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * This implementation calls &#123;@link #initStrategies&#125;.</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		initStrategies(context);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * Initialize the strategy objects that this servlet uses.</div><div class="line">	 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</div><div class="line">	 */</div><div class="line">	protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">		initMultipartResolver(context);</div><div class="line">		initLocaleResolver(context);</div><div class="line">		initThemeResolver(context);</div><div class="line">		initHandlerMappings(context);</div><div class="line">		initHandlerAdapters(context);</div><div class="line">		initHandlerExceptionResolvers(context);</div><div class="line">		initRequestToViewNameTranslator(context);</div><div class="line">		initViewResolvers(context);</div><div class="line">		initFlashMapManager(context);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，DispatchServlet对象的初始化完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[servlet 生命周期]]></title>
      <url>http://zsr.github.io/2016/08/15/servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="Servlet生命周期与工作原理"><a href="#Servlet生命周期与工作原理" class="headerlink" title="Servlet生命周期与工作原理"></a>Servlet生命周期与工作原理</h1><p><strong>Servlet生命周期分为三个阶段：</strong></p>
<p>　　1. 初始化阶段  : 调用init()方法</p>
<p>　　2. 响应客户请求阶段　:　调用service()方法</p>
<p>　　3. 终止阶段　:　调用destroy()方法
　　</p>
<h3 id="Servlet初始化阶段："><a href="#Servlet初始化阶段：" class="headerlink" title="Servlet初始化阶段："></a>Servlet初始化阶段：</h3><p>在下列时刻Servlet容器装载Servlet:</p>
<ul>
<li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<servlet></servlet>之间添加如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在Servlet容器启动后，客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后，重新装载Servlet</li>
</ul>
<p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p>
<h3 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h3><p>   首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p>
<p>   每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p>
<p>　　Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req,ServletResponse res) </div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">      HttpRequest request;</div><div class="line">      HttpResponse response;</div><div class="line"> </div><div class="line">     try</div><div class="line">     &#123;</div><div class="line">         req = (HttpRequest)request;</div><div class="line">         res = (HttpResponse)response;</div><div class="line">      &#125;catch(ClassCastException e)</div><div class="line">      &#123;</div><div class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </div><div class="line">      &#125;</div><div class="line">      service(request,response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">   String protocol = req.getProtocol();</div><div class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</div><div class="line">   if(protocol.equals(&quot;1.1&quot;))</div><div class="line">   &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</div><div class="line">    &#125;</div><div class="line">   esle</div><div class="line">    &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以需要我们在自定义的Servlet中override这些方法！</p>
<h3 id="Servlet响应请求阶段："><a href="#Servlet响应请求阶段：" class="headerlink" title="Servlet响应请求阶段："></a>Servlet响应请求阶段：</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p>
<p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</div></pre></td></tr></table></figure>
<p>这是一个String–&gt;String[]的键值映射。<br>HashMap线程不安全的，Hashtable线程安全。</p>
<h3 id="Servlet终止阶段："><a href="#Servlet终止阶段：" class="headerlink" title="Servlet终止阶段："></a>Servlet终止阶段：</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p>
<h3 id="Servlet何时被创建："><a href="#Servlet何时被创建：" class="headerlink" title="Servlet何时被创建："></a>Servlet何时被创建：</h3><ul>
<li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p>
</li>
<li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p>
</li>
</ul>
<p><strong>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 参数解析原理]]></title>
      <url>http://zsr.github.io/2016/08/15/Spring-MVC-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq exchange模式]]></title>
      <url>http://zsr.github.io/2016/08/12/rabbitmq-exchange%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="rabbitmq-exchange"><a href="#rabbitmq-exchange" class="headerlink" title="rabbitmq exchange"></a>rabbitmq exchange</h1><p><strong>主要介绍rabbitmq常用的三种exchange模式：direct, fanout, topic.</strong></p>
<h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念,<strong>默认的virtual host为 “/“.</strong></p>
<h3 id="Default-exchange-默认交换机"><a href="#Default-exchange-默认交换机" class="headerlink" title="Default exchange (默认交换机)"></a>Default exchange (默认交换机)</h3><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，<strong>绑定的路由键（routing key）名称与队列名称相同。</strong></p>
<h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p><img src="/images/rabbitmq-exchange-1.png"></p>
<p><strong>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</strong></p>
<ul>
<li><p>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p>
</li>
<li><p>这种模式下不需要将Exchange进行任何绑定(binding)操作</p>
</li>
<li><p>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p>
</li>
<li><p>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//需要绑定路由键  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p><img src="/images/rabbitmq-exchange-2.png"></p>
<p><strong>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</strong></p>
<ul>
<li><p>可以理解为路由表的模式</p>
</li>
<li><p>这种模式不需要RouteKey</p>
</li>
<li><p>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</p>
</li>
<li><p>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;fanout&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">channel.queueDeclare(&quot;queueName1&quot;);  </div><div class="line">channel.queueBind(&quot;queueName1&quot;, &quot;exchangeName&quot;, &quot;routingKey1&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//路由键需要设置为空  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p><img src="/images/rabbitmq-exchange-3.png"></p>
<p><strong>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上.</strong></p>
<ul>
<li><p>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。</p>
</li>
<li><p>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</p>
</li>
<li><p>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</p>
</li>
<li><p>“#”表示0个或若干个关键字，“<em>”表示一个关键字。如“log.</em>”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。</p>
</li>
<li><p>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;topic&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey.*&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey.one&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC 参数校验]]></title>
      <url>http://zsr.github.io/2016/08/11/SpringMVC-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>需要对Post请求的表单数据进行简单校验。</p>
<h3 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h3><ul>
<li>Bean Validation API 1.1: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Hibernate Validator 5.0.1.Final: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.0.1.Final&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在application-context.xml文件中加入下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;mvc:annotation-driven /&gt;</div></pre></td></tr></table></figure>
<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><ol>
<li>在需要校验的model对象前面加上@Valid注解(javax.validation.Valid):</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(</div><div class="line">      value = &quot;/v1/live/send/gift&quot;, method = RequestMethod.POST)</div><div class="line">  @Response</div><div class="line">public WebResult requestSendGift(HttpServletRequest request, @Valid @ModelAttribute SendGiftForm sendGiftForm, BindingResult bindingResult) &#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>在controller方法里面加上参数判断：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (bindingResult.hasErrors()) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;request params must be not null.&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Validator-Model"><a href="#Validator-Model" class="headerlink" title="Validator Model"></a>Validator Model</h5><p>在需要校验的model字段前面加上注解(hibernate validator):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SendGiftForm &#123;</div><div class="line">  @NotNull</div><div class="line">  private Long roomId; </div><div class="line">  @NotNull</div><div class="line">  private Long liveId; </div><div class="line">  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://www.codejava.net/frameworks/spring/spring-mvc-form-validation-example-with-bean-validation-api" target="_blank" rel="external">Spring Form Validation</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq延时队列]]></title>
      <url>http://zsr.github.io/2016/08/10/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>rabbitmq 是目前使用最为普及的消息队列组件，基于 AMQP 的 rabbitmq 在各方面设计都比较完善，同时，它具有非常丰富的功能与特性，可以支持各种实际的适用场景。</p>
<p>但是<strong>rabbitmq并不直接支持延时队列</strong>的功能，本文我们就来介绍一下，如何使用 rabbitmq 实现一个延时队列。</p>
<h1 id="延时队列的简易实现"><a href="#延时队列的简易实现" class="headerlink" title="延时队列的简易实现"></a>延时队列的简易实现</h1><p>使用redis集群来实现了这个功能，redis中存储了下单时间，以分钟为粒度扫描相应的key，即可扫出所有下单时间超过指定时间间隔的数据.</p>
<h1 id="rabbitmq-与消息过期时间-–-TTL"><a href="#rabbitmq-与消息过期时间-–-TTL" class="headerlink" title="rabbitmq 与消息过期时间 – TTL"></a>rabbitmq 与消息过期时间 – TTL</h1><h3 id="为队列设置消息过期时间"><a href="#为队列设置消息过期时间" class="headerlink" title="为队列设置消息过期时间"></a>为队列设置消息过期时间</h3><p>rabbitmq 支持在创建队列时对队列设置消息过期时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-message-ttl&quot;, 60000);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<h1 id="失效消息转发队列-–-DLX"><a href="#失效消息转发队列-–-DLX" class="headerlink" title="失效消息转发队列 – DLX"></a>失效消息转发队列 – DLX</h1><p>一旦上述消息过期时间设置生效，某条消息达到消息过期时间，那么他将会成为一条“dead-lettered”，此外，被拒绝的消息如果requeue属性为 false，或者消息所在队列已达到最大长度，那么他也将成为“dead-lettered”.</p>
<p>如果设置了DLX规则，即失效消息转发规则，那么失效的消息就会被转发到相应的exchange和queue.</p>
<h3 id="通过代码设置失效消息转发队列"><a href="#通过代码设置失效消息转发队列" class="headerlink" title="通过代码设置失效消息转发队列"></a>通过代码设置失效消息转发队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">channel.exchangeDeclare(&quot;some.exchange.name&quot;, &quot;direct&quot;);</div><div class="line"></div><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-dead-letter-exchange&quot;, &quot;some.exchange.name&quot;);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<p>这样，一旦消息失效，则消息会被自动转发到你设置的x-dead-letter-exchange上的同名队列.</p>
<p>也可以通过下面的代码指定具体转发的目标 routing-key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;some-routing-key&quot;);</div></pre></td></tr></table></figure>
<h3 id="spring-rabbit-配置"><a href="#spring-rabbit-配置" class="headerlink" title="spring-rabbit 配置"></a>spring-rabbit 配置</h3><p>可以使用spring-rabbit配置替代代码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:queue name=&quot;q.with.dlx&quot;&gt;</div><div class="line">    &lt;rabbit:queue-arguments&gt; </div><div class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</div><div class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Long&quot;/&gt;</div><div class="line">    &lt;/rabbit:queue-arguments&gt;</div><div class="line">&lt;/rabbit:queue&gt;</div><div class="line"></div><div class="line">&lt;rabbit:queue name=&quot;dlq&quot;/&gt;</div><div class="line"></div><div class="line">&lt;rabbit:direct-exchange name=&quot;dlx&quot;&gt;</div><div class="line">    &lt;rabbit:bindings&gt;</div><div class="line">        &lt;rabbit:binding key=&quot;q.with.dlx&quot; queue=&quot;dlq&quot;/&gt;</div><div class="line">    &lt;/rabbit:bindings&gt;</div><div class="line">&lt;/rabbit:direct-exchange&gt;</div></pre></td></tr></table></figure>
<p>This assumes you routed the original message using the default direct exchange (routing by queue name). Hence the dead letter routing uses the same routing key (queue name). If you route using an explicit routing key, you would use that.</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.rabbitmq.com/ttl.html" target="_blank" rel="external">RabbitMQ TTL</a></p>
<p><a href="http://www.rabbitmq.com/dlx.html" target="_blank" rel="external">RabbitMQ DLX</a></p>
<p><a href="http://docs.spring.io/spring-amqp/docs/1.3.9.RELEASE/reference/html/amqp.html" target="_blank" rel="external">Spring AMQP</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型]]></title>
      <url>http://zsr.github.io/2016/08/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="深入理解Java内存模型（一）"><a href="#深入理解Java内存模型（一）" class="headerlink" title="深入理解Java内存模型（一）"></a>深入理解Java内存模型（一）</h1><p>原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-memory-model-1</a></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><strong>Java的并发采用的是共享内存模型</strong>，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</strong>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="/images/java虚拟机1-1.png"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<p><img src="/images/java虚拟机1-2.png"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<a id="more"></a> 
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="/images/java虚拟机1-3.png"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Processor A</div><div class="line"></div><div class="line">a = 1; //A1</div><div class="line">x = b; //A2</div><div class="line"></div><div class="line">Processor B</div><div class="line"></div><div class="line">b = 2; //B1</div><div class="line">y = a; //B2</div><div class="line"></div><div class="line">初始状态：a = b = 0</div><div class="line">处理器允许执行后得到结果：x = y = 0</div></pre></td></tr></table></figure>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p>
<p><img src="/images/Java虚拟机1-4.png"></p>
<p>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p>
<p><strong>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">屏障类型</th>
<th style="text-align:center">指令示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LoadLoad Barriers</td>
<td style="text-align:center">Load1; LoadLoad; Load2</td>
<td style="text-align:center">确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:center">StoreStore Barriers</td>
<td style="text-align:center">Store1; StoreStore; Store2</td>
<td style="text-align:center">确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:center">LoadStore Barriers</td>
<td style="text-align:center">Load1; LoadStore; Store2</td>
<td style="text-align:center">确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:center">StoreLoad Barriers</td>
<td style="text-align:center">Store1; StoreLoad; Load2</td>
<td style="text-align:center">确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。<strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before规则如下：</p>
<ul>
<li><p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>
</li>
<li><p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>
</li>
<li><p>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</p>
</li>
<li><p>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
</li>
</ul>
<p><strong>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</strong></p>
<p>happens-before与JMM的关系如下图所示：</p>
<p><img src="/images/Java虚拟机1-5.png"></p>
<p>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ClassLoader]]></title>
      <url>http://zsr.github.io/2016/08/05/ClassLoader/</url>
      <content type="html"><![CDATA[<h1 id="Java-类加载器"><a href="#Java-类加载器" class="headerlink" title="Java 类加载器"></a>Java 类加载器</h1><hr>
<h3 id="类加载器基本概念"><a href="#类加载器基本概念" class="headerlink" title="类加载器基本概念"></a>类加载器基本概念</h3><p><strong>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</strong></p>
<h3 id="java-lang-ClassLoader类介绍"><a href="#java-lang-ClassLoader类介绍" class="headerlink" title="java.lang.ClassLoader类介绍"></a>java.lang.ClassLoader类介绍</h3><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。为了完成加载类的这个职责，ClassLoader提供了一系列的方法，比较重要的方法如表 1所示。</p>
<h5 id="表-1-ClassLoader-中与加载类相关的方法"><a href="#表-1-ClassLoader-中与加载类相关的方法" class="headerlink" title="表 1. ClassLoader 中与加载类相关的方法"></a>表 1. ClassLoader 中与加载类相关的方法</h5><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getParent()</td>
<td style="text-align:center">返回该类加载器的父类加载器</td>
</tr>
<tr>
<td style="text-align:center">loadClass(String name)</td>
<td style="text-align:center">加载名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findClass(String name)</td>
<td style="text-align:center">查找名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findLoadedClass(String name)</td>
<td style="text-align:center">查找名称为 name的已经被加载过的类，返回的结果是java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:center">defineClass(String name, byte[] b, int off, int len)</td>
<td style="text-align:center">把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的</td>
</tr>
<tr>
<td style="text-align:center">resolveClass(Class&lt;?&gt; c)</td>
<td style="text-align:center">链接指定的 Java 类</td>
</tr>
</tbody>
</table>
<p>类加载器的树状组织结构<br>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li><p>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</p>
</li>
<li><p>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p>
</li>
<li><p>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
</li>
</ul>
<p>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求(如tomcat)。<br>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。图 1中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。</p>
<a id="more"></a>
<h5 id="图-1-类加载器树状组织结构示意图"><a href="#图-1-类加载器树状组织结构示意图" class="headerlink" title="图 1. 类加载器树状组织结构示意图"></a>图 1. 类加载器树状组织结构示意图</h5><p><img src="/images/ClassLoader_1.jpg"></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTree &#123; </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        ClassLoader loader = ClassLoaderTree.class.getClassLoader(); </div><div class="line">        while (loader != null) &#123; </div><div class="line">            System.out.println(loader.toString()); </div><div class="line">            loader = loader.getParent(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@9304b1</div><div class="line"></div><div class="line">sun.misc.Launcher$ExtClassLoader@190d11</div></pre></td></tr></table></figure>
<p>第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是 sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。需要注意的是这里并没有输出引导类加载器，这是由于有些 JDK 的实现对于父类加载器是引导类加载器的情况，getParent()方法返回 null。</p>
<h3 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h3><p><strong>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.example; </div><div class="line"></div><div class="line"> public class Sample &#123; </div><div class="line">    private Sample instance; </div><div class="line"></div><div class="line">    public void setSample(Object instance) &#123; </div><div class="line">        this.instance = (Sample) instance; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>com.example.Sample类的方法 setSample接受一个 java.lang.Object类型的参数，并且会把该参数强制转换成 com.example.Sample类型。</p>
<p><strong>测试java类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void testClassIdentity() &#123; </div><div class="line">    String classDataRootPath = &quot;C:\\workspace\\Classloader\\classData&quot;; </div><div class="line">    FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    String className = &quot;com.example.Sample&quot;; 	</div><div class="line">    try &#123; </div><div class="line">        Class&lt;?&gt; class1 = fscl1.loadClass(className); </div><div class="line">        Object obj1 = class1.newInstance(); </div><div class="line">        Class&lt;?&gt; class2 = fscl2.loadClass(className); </div><div class="line">        Object obj2 = class2.newInstance(); </div><div class="line">        Method setSampleMethod = class1.getMethod(&quot;setSample&quot;, java.lang.Object.class); </div><div class="line">        setSampleMethod.invoke(obj1, obj2); </div><div class="line">    &#125; catch (Exception e) &#123; </div><div class="line">        e.printStackTrace(); </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>用了类 FileSystemClassLoader的两个不同实例来分别加载类 com.example.Sample，得到了两个不同的 java.lang.Class的实例，接着通过 newInstance()方法分别生成了两个类的对象obj1和obj2，最后通过 Java的反射API在对象obj1上调用方法setSample，试图把对象obj2赋值给obj1内部的instance对象。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">java.lang.reflect.InvocationTargetException </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) </div><div class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</div><div class="line">at java.lang.reflect.Method.invoke(Method.java:597) </div><div class="line">at classloader.ClassIdentity.testClassIdentity(ClassIdentity.java:26) </div><div class="line">at classloader.ClassIdentity.main(ClassIdentity.java:9) </div><div class="line">Caused by: java.lang.ClassCastException: com.example.Sample </div><div class="line">cannot be cast to com.example.Sample </div><div class="line">at com.example.Sample.setSample(Sample.java:7) </div><div class="line">... 6 more</div></pre></td></tr></table></figure>
<p>从运行结果可以看到，运行时抛出了 java.lang.ClassCastException异常。虽然两个对象 obj1和 obj2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。</p>
<p>了解了这一点之后，就可以理解代理模式的设计动机了。代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。<br>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>
<p>下面具体介绍类加载器加载类的详细过程。</p>
<h3 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h3><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。<br>方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。<br>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</p>
<p>下面讨论另外一种类加载器：线程上下文类加载器。</p>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。<br>前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。<br>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<p>下面介绍另外一种加载类的方法：Class.forName。</p>
<h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h4><p>Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。</p>
<h3 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h3><p>用来加载存储在文件系统上的 Java 字节代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class FileSystemClassLoader extends ClassLoader &#123; </div><div class="line"></div><div class="line">    private String rootDir; </div><div class="line"></div><div class="line">    public FileSystemClassLoader(String rootDir) &#123; </div><div class="line">        this.rootDir = rootDir; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; </div><div class="line">        byte[] classData = getClassData(name); </div><div class="line">        if (classData == null) &#123; </div><div class="line">            throw new ClassNotFoundException(); </div><div class="line">        &#125; </div><div class="line">        else &#123; </div><div class="line">            return defineClass(name, classData, 0, classData.length); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private byte[] getClassData(String className) &#123; </div><div class="line">        String path = classNameToPath(className); </div><div class="line">        try &#123; </div><div class="line">            InputStream ins = new FileInputStream(path); </div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream(); </div><div class="line">            int bufferSize = 4096; </div><div class="line">            byte[] buffer = new byte[bufferSize]; </div><div class="line">            int bytesNumRead = 0; </div><div class="line">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123; </div><div class="line">                baos.write(buffer, 0, bytesNumRead); </div><div class="line">            &#125; </div><div class="line">            return baos.toByteArray(); </div><div class="line">        &#125; catch (IOException e) &#123; </div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">        return null; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private String classNameToPath(String className) &#123; </div><div class="line">        return rootDir + File.separatorChar </div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>类 FileSystemClassLoader继承自类 java.lang.ClassLoader。在 表 1中列出的 java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</p>
<p>类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。</p>
<h3 id="类加载器与-Web-容器"><a href="#类加载器与-Web-容器" class="headerlink" title="类加载器与 Web 容器"></a>类加载器与 Web 容器</h3><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。<br>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<ul>
<li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li>
<li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li>
<li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[String]]></title>
      <url>http://zsr.github.io/2016/08/03/String/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-String"><a href="#OpenJDK-源代码阅读之-String" class="headerlink" title="OpenJDK 源代码阅读之 String"></a>OpenJDK 源代码阅读之 String</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.lang.String</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">Object</span></div><div class="line"><span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>一旦创建就不可改变</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>storage</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The value is used for character storage. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div></pre></td></tr></table></figure>
<p>可以看出 <code>String</code> 中的数据是如何存储的。</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = original.value;</div><div class="line">    <span class="keyword">this</span>.hash = original.hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出使用 <code>String</code> 类型初始化，新 <code>String</code> 实际上与原来的 <code>String</code> 指向同一块内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 <code>char[]</code> 初始化，可以看出，新分配了内存，并复制，保证了两者相互独立，只是内容相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</div><div class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意用 <code>StringBuffer</code> 初始化时，对同一 <code>buffer</code> 是线程安全的，即初始化 <code>String</code> 的过程中，其它线程不会改变 <code>buffer</code> 的内容。</p>
<p>另外，能告诉我下面这段代码是怎么回事么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>为啥这次不同步了呢？</p>
<ul>
<li>equals </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</div><div class="line">        String anotherString = (String) anObject;</div><div class="line">        <span class="keyword">int</span> n = value.length;</div><div class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</div><div class="line">            <span class="keyword">char</span> v1[] = value;</div><div class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<p>1) 检查类型<br>2) <code>value</code> 直接通过点访问了，<code>value</code> 是 <code>private</code> 的啊，怎么能这样？</p>
<ul>
<li>hashCode </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hash;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">            h = <span class="number">31</span> * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>String</code> 的 <code>hashCode</code> 公式：</p>
<blockquote>
<p>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</p>
</blockquote>
<ul>
<li>replace</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</div><div class="line">        <span class="keyword">int</span> len = value.length;</div><div class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</div><div class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                buf[j] = val[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">                <span class="keyword">char</span> c = val[i];</div><div class="line">                buf[i] = (c == oldChar) ? newChar : c;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，虽然说是 <code>replace</code>，但是实际上还是新生成了 <code>buf</code> ，然后再生成新的 <code>String</code>，而不是在原来的 <code>value</code> 上修改。如果有大量的替换，还是自己实现比较好诶～</p>
<ul>
<li>indexOf</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Code shared by String and StringBuffer to do searches. The</div><div class="line"> * source is the character array being searched, and the target</div><div class="line"> * is the string being searched for.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>   source       the characters being searched.</div><div class="line"> * <span class="doctag">@param</span>   sourceOffset offset of the source string.</div><div class="line"> * <span class="doctag">@param</span>   sourceCount  count of the source string.</div><div class="line"> * <span class="doctag">@param</span>   target       the characters being searched for.</div><div class="line"> * <span class="doctag">@param</span>   targetOffset offset of the target string.</div><div class="line"> * <span class="doctag">@param</span>   targetCount  count of the target string.</div><div class="line"> * <span class="doctag">@param</span>   fromIndex    the index to begin searching from.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</div><div class="line">        <span class="keyword">int</span> fromIndex) &#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</div><div class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        fromIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> first = target[targetOffset];</div><div class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        <span class="comment">/* Look for first character. */</span></div><div class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</div><div class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></div><div class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</div><div class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</div><div class="line">                    == target[k]; j++, k++);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == end) &#123;</div><div class="line">                <span class="comment">/* Found whole string. */</span></div><div class="line">                <span class="keyword">return</span> i - sourceOffset;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码从 <code>source</code> 中寻找 <code>target</code> 第一次出现的位置，<code>for</code> 循环每次都先让 <code>i</code> 停留在一个位置，此位置上内容与 <code>target</code> 首字符相同，然后开始遍历。可以看出这是一个 <code>O(n^2)</code> 的算法，所以，标准库也不一定是最高效的，要是要高效，还是需要自己实现，或者找其它库的。</p>
<ul>
<li>matches</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正则表达式匹配函数。可以看出，是直接调用了 <code>Pattern</code> 中的相应函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</div><div class="line">    <span class="comment">/* fastpath if the regex is a</span></div><div class="line">     (1)one-char String and this character is not one of the</div><div class="line">        RegEx's meta characters ".$|()[&#123;^?*+\\", or</div><div class="line">     (2)two-char String and the first char is the backslash and</div><div class="line">        the second is not the ascii digit or ascii letter.</div><div class="line">     */</div><div class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</div><div class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</div><div class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</div><div class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</div><div class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</div><div class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</div><div class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</div><div class="line">                list.add(substring(off, next));</div><div class="line">                off = next + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></div><div class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></div><div class="line">                list.add(substring(off, value.length));</div><div class="line">                off = value.length;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// If no match was found, return this</span></div><div class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Add remaining segment</span></div><div class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</div><div class="line">            list.add(substring(off, value.length));</div><div class="line"></div><div class="line">        <span class="comment">// Construct result</span></div><div class="line">        <span class="keyword">int</span> resultSize = list.size();</div><div class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>)</div><div class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>)</div><div class="line">                resultSize--;</div><div class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</div><div class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按 <code>regex</code> 将字符串分割，思路是如果是单个字符，或者转义字符，就手工分割，否则就直接调用 <code>Pattern.comile(regex).split</code> 函数。手工分割时每次都将 <code>[off, next]</code> 之间的内容加入 <code>list</code>，最后将 剩余的 <code>[off, ]</code>  加入。另外注意 <code>limit</code> 对分割次数的限制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Nio]]></title>
      <url>http://zsr.github.io/2016/08/02/Java-Nio/</url>
      <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><hr>
<h3 id="Nio-服务端"><a href="#Nio-服务端" class="headerlink" title="Nio 服务端"></a>Nio 服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.ServerSocketChannel;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 服务端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOServer &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个ServerSocket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param port 绑定的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initServer(int port) throws IOException &#123;</div><div class="line">    // 获得一个ServerSocket通道</div><div class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    serverChannel.configureBlocking(false);</div><div class="line">    // 将该通道对应的ServerSocket绑定到指定端口</div><div class="line">    serverChannel.socket().bind(new InetSocketAddress(port));</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，</div><div class="line">    // 当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。</div><div class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio server listen start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 客户端请求连接事件</div><div class="line">        if (key.isAcceptable()) &#123;</div><div class="line">          ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">          // 获得和客户端连接的通道</div><div class="line">          SocketChannel channel = server.accept();</div><div class="line">          // 设置成非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 在这里可以给客户端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;服务器收到客户端连接请求.&quot;).getBytes()));</div><div class="line"></div><div class="line">          // 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line">          // 获得了可读事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取客户端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line"></div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;服务器端收到客户端信息:&quot; + msg);</div><div class="line">    // 将消息回送给客户端</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;服务器端发送客户端消息: world.&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 服务器端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOServer nioServer = new NIOServer();</div><div class="line">    nioServer.initServer(8000);</div><div class="line">    nioServer.listen();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Nio-客户端"><a href="#Nio-客户端" class="headerlink" title="Nio 客户端"></a>Nio 客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 客户端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOClient &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个Socket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param ip 连接的服务器的ip</div><div class="line">   * @param port 连接的服务器的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initClient(String ip, int port) throws IOException &#123;</div><div class="line">    // 获得一个Socket通道</div><div class="line">    SocketChannel channel = SocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    channel.configureBlocking(false);</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line"></div><div class="line">    // 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调</div><div class="line">    // 用channel.finishConnect();才能完成连接</div><div class="line">    channel.connect(new InetSocketAddress(ip, port));</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</div><div class="line">    channel.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio client liesten start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 连接事件发生</div><div class="line">        if (key.isConnectable()) &#123;</div><div class="line">          SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">          // 如果正在连接，则完成连接</div><div class="line">          if (channel.isConnectionPending()) &#123;</div><div class="line">            channel.finishConnect();</div><div class="line">          &#125;</div><div class="line">          // 设置非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 向服务器端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;客户端请求连接服务器端.&quot;).getBytes()));</div><div class="line">          // 在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">          // 获得了可读的事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取服务器端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;客户端收到服务器信息:&quot; + msg);</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;客户端发送服务器消息: hello&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 客户端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOClient nioClient = new NIOClient();</div><div class="line">    nioClient.initClient(&quot;127.0.0.1&quot;, 8000);</div><div class="line">    nioClient.listen();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReducer]]></title>
      <url>http://zsr.github.io/2016/08/02/MapReducer/</url>
      <content type="html"><![CDATA[<h1 id="MapReducer笔记"><a href="#MapReducer笔记" class="headerlink" title="MapReducer笔记"></a>MapReducer笔记</h1><h3 id="参入mapreduce作业执行涉及4个独立的实体："><a href="#参入mapreduce作业执行涉及4个独立的实体：" class="headerlink" title="参入mapreduce作业执行涉及4个独立的实体："></a>参入mapreduce作业执行涉及4个独立的实体：</h3><ul>
<li><p>客户端（client）：编写mapreduce程序，配置作业，提交作业，这就是程序员完成的工作；</p>
</li>
<li><p>JobTracker：初始化作业，分配作业，与TaskTracker通信，协调整个作业的执行；</p>
</li>
<li><p>TaskTracker：保持与JobTracker的通信，在分配的数据片段上执行Map或Reduce任务，TaskTracker和JobTracker的不同有个很重要的方面，就是在执行任务时候TaskTracker可以有n多个，JobTracker则只会有一个</p>
</li>
<li><p>Hdfs：保存作业的数据、配置信息等等，最后的结果也是保存在hdfs上面</p>
</li>
</ul>
<p><img src="/images/MapReducer.jpg"></p>
<a id="more"></a>
<h3 id="mapreduce运行过程"><a href="#mapreduce运行过程" class="headerlink" title="mapreduce运行过程"></a>mapreduce运行过程</h3><ul>
<li><p>首先是客户端要编写好mapreduce程序，配置好mapreduce的作业也就是job，接下来就是提交job了，提交job是提交到JobTracker上的，这个时候JobTracker就会构建这个job，具体就是分配一个新的job任务的ID值，接下来它会做检查操作，这个检查就是确定输出目录是否存在，如果存在那么job就不能正常运行下去，JobTracker会抛出错误给客户端，接下来还要检查输入目录是否存在，如果不存在同样抛出错误，如果存在JobTracker会根据输入计算输入分片（Input Split），如果分片计算不出来也会抛出错误，至于输入分片我后面会做讲解的，这些都做好了JobTracker就会配置Job需要的资源了。分配好资源后，JobTracker就会初始化作业，初始化主要做的是将Job放入一个内部的队列，让配置好的作业调度器能调度到这个作业，作业调度器会初始化这个job，初始化就是创建一个正在运行的job对象（封装任务和记录信息），以便JobTracker跟踪job的状态和进程。</p>
</li>
<li><p>初始化完毕后，作业调度器会获取输入分片信息（input split），每个分片创建一个map任务。接下来就是任务分配了，这个时候tasktracker会运行一个简单的循环机制定期发送心跳给jobtracker，心跳间隔是5秒，程序员可以配置这个时间，心跳就是jobtracker和tasktracker沟通的桥梁，通过心跳，jobtracker可以监控tasktracker是否存活，也可以获取tasktracker处理的状态和问题，同时tasktracker也可以通过心跳里的返回值获取jobtracker给它的操作指令。任务分配好后就是执行任务了。在任务执行时候jobtracker可以通过心跳机制监控tasktracker的状态和进度，同时也能计算出整个job的状态和进度，而tasktracker也可以本地监控自己的状态和进度。当jobtracker获得了最后一个完成指定任务的tasktracker操作成功的通知时候，jobtracker会把整个job状态置为成功，然后当客户端查询job运行状态时候（注意：这个是异步操作），客户端会查到job完成的通知的。如果job中途失败，mapreduce也会有相应机制处理，一般而言如果不是程序员程序本身有bug，mapreduce错误处理机制都能保证提交的job能正常完成。</p>
</li>
</ul>
<h5 id="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"><a href="#从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。" class="headerlink" title="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"></a>从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。</h5><ol>
<li>输入分片（input split）：在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</li>
</ol>
<ol>
<li><p>map阶段：就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</p>
</li>
<li><p>combiner阶段：combiner阶段是程序员可以选择的，combiner其实也是一种reduce操作，因此我们看见WordCount类里是用reduce进行加载的。Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如我们对文件里的单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错。</p>
</li>
<li><p>shuffle阶段：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。这里我不讲怎么优化shuffle阶段，讲讲shuffle阶段的原理，因为大部分的书籍里都没讲清楚shuffle阶段。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。<br>每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。</p>
</li>
<li><p>reduce阶段：和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h1><hr>
<h6 id="Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"><a href="#Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。" class="headerlink" title="Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"></a>Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。</h6><h5 id="带有横切逻辑的实例"><a href="#带有横切逻辑的实例" class="headerlink" title="带有横切逻辑的实例"></a>带有横切逻辑的实例</h5><p>我们通过具体化代码实现上一节所介绍例子的性能监视横切逻辑，并通过动态代理技术对此进行改造。在调用每一个目标类方法时启动方法的性能监视，在目标类方法调用完成时记录方法的花费时间。 </p>
<p>代码清单6-2  ForumService：包含性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;          </div><div class="line">         //①-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">                            &quot;com.baobaotao.proxy.ForumServiceImpl. removeTopic&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //①-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">          //②-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">&quot;com.baobaotao.proxy.ForumServiceImpl. removeForum&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //②-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码清单6-2中粗体表示的代码就是具有横切逻辑特征的代码，每个Service类和每个业务方法体的前后都执行相同的代码逻辑：方法调用前启动PerformanceMonitor，方法调用后通知PerformanceMonitor结束性能监视并给记录性能监视结果。<br><a id="more"></a></p>
<p>PerformanceMonitor是性能监视的实现类，我们给出一个非常简单的实现版本，其代码如代码清单6-3所示： </p>
<p>代码清单6-3  PerformanceMonitor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class PerformanceMonitor &#123;  </div><div class="line">     //①通过一个ThreadLocal保存调用线程相关的性能监视信息  </div><div class="line">    private static ThreadLocal&lt;MethodPerformace&gt; performanceRecord =          </div><div class="line">                                new ThreadLocal&lt;MethodPerformance&gt;();  </div><div class="line">    //②启动对某一目标方法的性能监视  </div><div class="line">     public static void begin(String method) &#123;  </div><div class="line">        System.out.println(&quot;begin monitor...&quot;);  </div><div class="line">        MethodPerformance mp = new MethodPerformance(method);  </div><div class="line">        performanceRecord.set(mp);  </div><div class="line">    &#125;  </div><div class="line">    public static void end() &#123;  </div><div class="line">        System.out.println(&quot;end monitor...&quot;);  </div><div class="line">        MethodPerformance mp = performanceRecord.get();  </div><div class="line">         //③打印出方法性能监视的结果信息。  </div><div class="line">        mp.printPerformance();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal是将非线程安全类改造为线程安全类的法宝，在9.2节中我们将详细介绍这个Java基础知识。PerformanceMonitor提供了两个方法：通过调用begin(String method)方法开始对某个目标类方法的监视，method为目标类方法的全限定名；而end()方法结束对目标类方法的监视，并给出性能监视的信息。这两个方法必须配套使用。 </p>
<p>用于记录性能监视信息的MethodPerformance类的代码如所示： </p>
<p>代码清单6-4  MethodPerformance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class MethodPerformance &#123;  </div><div class="line">    private long begin;  </div><div class="line">    private long end;  </div><div class="line">    private String serviceMethod;  </div><div class="line">    public MethodPerformance(String serviceMethod)&#123;  </div><div class="line">       this.serviceMethod = serviceMethod;  </div><div class="line">       //①记录目标类方法开始执行点的系统时间    </div><div class="line">       this.begin = System.currentTimeMillis();    </div><div class="line">    &#125;  </div><div class="line">    public void printPerformance()&#123;  </div><div class="line">        //②获取目标类方法执行完成后的系统时间，并进而计算出目标类方法执行时间  </div><div class="line">        end = System.currentTimeMillis();   </div><div class="line">        long elapse = end - begin;  </div><div class="line">        //③报告目标类方法的执行时间  </div><div class="line">        System.out.println(serviceMethod+&quot;花费&quot;+elapse+&quot;毫秒。&quot;);    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过下面的代码测试拥有性能监视能力的ForumServiceImpl业务方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy; </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ForumService forumService = new ForumServiceImpl();  </div><div class="line">        forumService .removeForum(10);  </div><div class="line">       forumService .removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们得到以下输出信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... ①removeForum(10)方法的性能监视报告 </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... ①removeTopic(1012)方法的性能监视报告 </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>正如代码清单6 2实例所示，当某个方法需要进行性能监视，就必须调整方法代码，在方法体前后分别添加上开启性能监视和结束性能监视的代码。这些非业务逻辑的性能监视代码破坏了ForumServiceImpl业务逻辑的纯粹性。我们希望通过代理的方式，将业务类方法中开启和结束性能监视的这些横切代码从业务类中完全移除。并通过JDK动态代理技术或CGLib动态代理技术将横切代码动态织入到目标方法的相应位置。 </p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK 1.3以后，Java提供了动态代理的技术，允许开发者在运行期创建接口的代理实例。在Sun刚推出动态代理时，还很难想象它有多大的实际用途，现在我们终于发现动态代理是实现AOP的绝好底层技术。 </p>
<p>JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。 </p>
<p>而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。这样讲一定很抽象，我们马上着手使用Proxy和InvocationHandler这两个魔法戒对上一节中的性能监视代码进行革新。 </p>
<p>首先，我们从业务类ForumServiceImpl中删除性能监视的横切代码，使ForumServiceImpl只负责具体的业务逻辑，如代码清单6-5所示： </p>
<p>代码清单6-5  ForumServiceImpl：移除性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;   </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;                                </div><div class="line">                             ①  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                             ①  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">                          ②  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                          ②  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码清单6-5中的①和②处，原来的性能监视代码被移除了，我们只保留了真正的业务逻辑。 </p>
<p>从业务类中移除的性能监视横切代码当然不能漂浮在空气中，它还得找到一个安身之所，InvocationHandler就是横切代码的安家乐园，我们将性能监视的代码安置在PerformanceHandler中，如代码清单6-6所示： </p>
<p>代码清单6-6  PerformanceHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.InvocationHandler;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">public class PerformanceHandler implements InvocationHandler &#123;//①实现InvocationHandler  </div><div class="line">    private Object target;  </div><div class="line">    public PerformanceHandler(Object target)&#123; //②target为目标的业务类  </div><div class="line">        this.target = target;  </div><div class="line">    &#125;  </div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) ③  </div><div class="line">            throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(target.getClass().getName()+&quot;.&quot;+ method. getName());③-1  </div><div class="line">        Object obj = method.invoke(target, args);// ③-2通过反射方法调用业务类的目标方法  </div><div class="line">        PerformanceMonitor.end();③-1  </div><div class="line">        return obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>③处invoke()方法中粗体所示部分的代码为性能监视的横切代码，我们发现，横切代码只出现一次，而不是原来那样星洒各处。③-2处的method.invoke()语句通过Java反射机制间接调用目标对象的方法，这样InvocationHandler的invoke()方法就将横切逻辑代码（③-1）和业务类方法的业务逻辑代码（③-2）编织到一起了，所以我们可以将InvocationHandler看成是一个编织器。下面，我们对这段代码做进一步的说明。 </p>
<p>首先，我们实现InvocationHandler接口，该接口定义了一个 invoke(Object proxy, Method method, Object[] args)的方法，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是通过被代理实例某一个方法的入参，在方法反射调用时使用。 </p>
<p>此外，我们在构造函数里通过target传入希望被代理的目标对象，如②处所示，在InvocationHandler接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传给method.invoke()方法，调用目标实例的方法，如③所示。<br>下面，我们通过Proxy结合PerformanceHandler创建ForumService接口的代理实例，如代码清单6-7所示： </p>
<p>代码清单6-7  TestForumService：创建代理实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;                 </div><div class="line">               //①希望被代理的目标业务类  </div><div class="line">        ForumService target = new ForumServiceImpl();            </div><div class="line">               //②将目标业务类和横切代码编织到一起  </div><div class="line">        PerformanceHandler handler = new PerformanceHandler(target);  </div><div class="line">               //③根据编织了目标业务类逻辑和性能监视横切逻辑的InvocationHandler实例创建代理实例  </div><div class="line">        ForumService proxy = (ForumService) Proxy.newProxyInstance(    </div><div class="line">                target.getClass().getClassLoader(),  </div><div class="line">                target.getClass().getInterfaces(),  </div><div class="line">                handler);  </div><div class="line">               //④调用代理实例  </div><div class="line">        proxy.removeForum(10);     </div><div class="line">        proxy.removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码完成业务类代码和横切代码的编织工作并生成了代理实例。在②处，我们让PerformanceHandler将性能监视横切逻辑编织到ForumService实例中，然后在③处，通过Proxy的newProxyInstance()静态方法为编织了业务类逻辑和性能监视逻辑的handler创建一个符合ForumService接口的代理实例。该方法的第一个入参为类加载器；第二个入参为创建代理实例所需要实现的一组接口；第三个参数是整合了业务逻辑和横切逻辑的编织器对象。 </p>
<p>按照③处的设置方式，这个代理实例实现了目标业务类的所有接口，即Forum ServiceImpl的ForumService接口。这样，我们就可以按照调用ForumService接口实例相同的方式调用代理实例，如④所示。运行以上的代码，输出以下信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>我们发现，程序的运行效果和直接在业务类中编写性能监视逻辑的效果一致，但是在这里，原来分散的横切逻辑代码已经被我们抽取到PerformanceHandler中。当其他业务类（如UserService、SystemService等）的业务方法也需要使用性能监视时，我们只要按照代码清单6-7相似的方式，分别为它们创建代理对象就可以了。下面，我们通过时序图描述通过创建代理对象进行业务方法调用的整体逻辑，以进一步认识代理对象的本质，如图6-3所示。 </p>
<p><img src="/images/图6-3 动态代理.jpg"></p>
<p>我们在上图中使用虚线的方式对通过Proxy创建的ForumService代理实例加以凸显，ForumService代理实例内部利用PerformaceHandler整合横切逻辑和业务逻辑。调用者调用代理对象的removeForum()和removeTopic()方法时，上图的内部调用时序清晰地告诉我们实际上所发生的一切。 </p>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>使用JDK创建代理有一个限制，即它只能为接口创建代理实例，这一点我们可从Proxy的接口newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)的方法签名中就看得很清楚：第二个入参interfaces就是需要代理实例实现的接口列表。虽然面向接口编程的思想被很多大师级人物（包括Rod Johnson）推崇，但在实际开发中，许多开发者也对此深感困惑：难道对一个简单业务表的操作也需要老老实实地创建5个类（领域对象类、Dao接口，Dao实现类，Service接口和Service实现类）吗？难道不能直接通过实现类构建程序吗？对于这个问题，我们很难给出一个孰好孰劣的准确判断，但我们确实发现有很多不使用接口的项目也取得了非常好的效果（包括大家所熟悉的SpringSide开源项目）。 </p>
<p>对于没有通过接口定义业务方法的类，如何动态创建代理实例呢？JDK的代理技术显然已经黔驴技穷，CGLib作为一个替代者，填补了这个空缺。 </p>
<p>CGLib采用非常底层的字节码技术，可以为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，并顺势织入横切逻辑。下面，我们采用CGLib技术，编写一个可以为任何类创建织入性能监视横切逻辑代理对象的代理创建器，如代码清单 6-8所示： </p>
<p>代码清单6-8  CglibProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">import net.sf.cglib.proxy.Enhancer;  </div><div class="line">import net.sf.cglib.proxy.MethodInterceptor;  </div><div class="line">import net.sf.cglib.proxy.MethodProxy;  </div><div class="line">public class CglibProxy implements MethodInterceptor &#123;  </div><div class="line">    private Enhancer enhancer = new Enhancer();  </div><div class="line">    public Object getProxy(Class clazz) &#123;  </div><div class="line">        enhancer.setSuperclass(clazz); //① 设置需要创建子类的类  </div><div class="line">        enhancer.setCallback(this);   </div><div class="line">        return enhancer.create(); //②通过字节码技术动态创建子类实例  </div><div class="line">    &#125;  </div><div class="line">        //③拦截父类所有方法的调用  </div><div class="line">    public Object intercept(Object obj, Method method, Object[] args,   </div><div class="line">            MethodProxy proxy) throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(obj.getClass().getName()+&quot;.&quot;+method. getName());//③-1  </div><div class="line">        Object result=proxy.invokeSuper(obj, args); ③-2   </div><div class="line">        PerformanceMonitor.end();//③-1通过代理类调用父类中的方法  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码中，用户可以通过getProxy(Class clazz)为一个类创建动态代理对象，该代理对象通过扩展clazz创建代理对象。在这个代理对象中，我们织入性能监视的横切逻辑（③-1）。intercept(Object obj, Method method, Object[] args,MethodProxy proxy)是CGLib定义的Interceptor接口的方法，它拦截所有目标类方法的调用，obj表示目标类的实例；method为目标类方法的反射对象；args为方法的动态入参；而proxy为代理类实例。 </p>
<p>下面，我们通过CglibProxy为ForumServiceImpl类创建代理对象，并测试代理对象的方法，如代码清单6-9所示： </p>
<p>代码清单6-9  TestForumService：测试Cglib创建的代理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">      CglibProxy proxy = new CglibProxy();  </div><div class="line">      ForumServiceImpl forumService = ①   </div><div class="line">                (ForumServiceImpl )proxy.getProxy(ForumServiceImpl.class);  </div><div class="line">      forumService.removeForum(10);  </div><div class="line">      forumService.removeTopic(1023);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在①中，我们通过CglibProxy为ForumServiceImpl动态创建了一个织入性能监视逻辑的代理对象，并调用代理类的业务方法。运行上面的代码，输入以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1023 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeTopic花费16毫秒。</div></pre></td></tr></table></figure></p>
<p>观察以上的输出，除了发现两个业务方法中都织入了性能监控的逻辑外，我们还发现代理类的名字是com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0，这个特殊的类就是CGLib为ForumServiceImpl动态创建的子类。 </p>
<h3 id="代理知识小结"><a href="#代理知识小结" class="headerlink" title="代理知识小结"></a>代理知识小结</h3><p>Spring AOP的底层就是通过使用JDK动态代理或CGLib动态代理技术为目标Bean织入横切逻辑。在这里，我们对前面两节动态创建代理对象作一个小结。 </p>
<p>我们虽然通过PerformanceHandler或CglibProxy实现了性能监视横切逻辑的动态织入，但这种实现方式存在三个明显需要改进的地方： </p>
<ul>
<li>目标类的所有方法都添加了性能监视横切逻辑，而有时，这并不是我们所期望的，我们可能只希望对业务类中的某些特定方法添加横切逻辑； </li>
<li>我们通过硬编码的方式指定了织入横切逻辑的织入点，即在目标类业务方法的开始和结束前织入代码； </li>
<li>我们手工编写代理实例的创建过程，为不同类创建代理时，需要分别编写相应的创建代码，无法做到通用。 </li>
</ul>
<p>以上三个问题，在AOP中占用重要的地位，因为Spring AOP的主要工作就是围绕以上三点展开：Spring AOP通过Pointcut（切点）指定在哪些类的哪些方法上织入横切逻辑，通过Advice（增强）描述横切逻辑和方法的具体织入点（方法前、方法后、方法的两端等）。此外，Spring通过Advisor（切面）将Pointcut和Advice两者组装起来。有了Advisor的信息，Spring就可以利用JDK或CGLib的动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象了。 </p>
<p>JDK动态代理所创建的代理对象，在JDK 1.3下，性能强差人意。虽然在高版本的JDK中，动态代理对象的性能得到了很大的提高，但是有研究表明，CGLib所创建的动态代理对象的性能依旧比JDK的所创建的代理对象的性能高不少（大概10倍）。但CGLib在创建代理对象时所花费的时间却比JDK动态代理多（大概8倍），所以对于singleton的代理对象或者具有实例池的代理，因为无须频繁创建代理对象，所以比较适合用CGLib动态代理技术，反之适合用JDK动态代理技术。值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final方法进行代理。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java反射]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><hr>
<h6 id="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"><a href="#Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。" class="headerlink" title="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"></a>Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。</h6><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们将从一个简单例子开始探访Java反射机制的征程，下面的Car类拥有两个构造函数、两个方法以及三个属性，如代码清单3-9所示： </p>
<p>代码清单3-9  Car<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.reflect;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String brand;  </div><div class="line">    <span class="keyword">private</span> String color;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; </div><div class="line">    <span class="comment">//①默认构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">     <span class="comment">//②带参构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand,String color,<span class="keyword">int</span> maxSpeed)</span></span>&#123;   </div><div class="line">        <span class="keyword">this</span>.brand = brand;  </div><div class="line">        <span class="keyword">this</span>.color = color;  </div><div class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//③未带参的方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123;   </div><div class="line">       System.out.println(<span class="string">"brand:"</span>+brand+<span class="string">";color:"</span>+color+<span class="string">";maxSpeed:"</span> +maxSpeed);  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//省略参数的getter/Setter方法  </span></div><div class="line">     …  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，我们会使用如下的代码创建Car的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Car car = <span class="keyword">new</span> Car();  </div><div class="line">car.setBrand(<span class="string">"红旗CA72"</span>);</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car = new Car(&quot;红旗CA72&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure></p>
<p>以上两种方法都采用传统方式的直接调用目标类的方法，下面我们通过Java反射机制以一种更加通用的方式间接地操作目标类：<br><a id="more"></a></p>
<p>代码清单3-10  ReflectTest<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao. reflect;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car  <span class="title">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> Throwable  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//①通过类装载器获取Car类对象  </span></div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();   </div><div class="line">        Class clazz = loader.loadClass(<span class="string">"com.baobaotao.reflect.Car"</span>); </div><div class="line">        <span class="comment">//②获取类的默认构造器对象并通过它实例化Car  </span></div><div class="line">        Constructor cons = clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>);   </div><div class="line">        Car car = (Car)cons.newInstance();  </div><div class="line">        <span class="comment">//③通过反射方法设置属性  </span></div><div class="line">        Method setBrand = clazz.getMethod(<span class="string">"setBrand"</span>,String.class);          </div><div class="line">        setBrand.invoke(car,<span class="string">"红旗CA72"</span>);        </div><div class="line">        Method setColor = clazz.getMethod(<span class="string">"setColor"</span>,String.class);  </div><div class="line">        setColor.invoke(car,<span class="string">"黑色"</span>);        </div><div class="line">        Method setMaxSpeed = clazz.getMethod(<span class="string">"setMaxSpeed"</span>,<span class="keyword">int</span>.class);  </div><div class="line">        setMaxSpeed.invoke(car,<span class="number">200</span>);          </div><div class="line">        <span class="keyword">return</span> car;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">        Car car = initByDefaultConst();  </div><div class="line">        car.introduce();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上程序，在控制台上将打印出以下信息：<br>引用<br>brand:红旗CA72;color:黑色;maxSpeed:200</p>
<p>这说明我们完全可以通过编程方式调用Class的各项功能，这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。 </p>
<p>在ReflectTest中，使用了几个重要的反射类，分别是ClassLoader、Class、Constructor和Method，通过这些反射类就可以间接调用目标Class的各项功能了。在①处，我们获取当前线程的ClassLoader，然后通过指定的全限定类“com.baobaotao.beans.Car”装载Car类对应的反射实例。在②处，我们通过Car的反射类对象获取Car的构造函数对象cons，通过构造函数对象的newInstrance()方法实例化Car对象，其效果等同于new Car()。在③处，我们又通过Car的反射类对象的getMethod（String methodName,Class paramClass）获取属性的Setter方法对象，第一个参数是目标Class的方法名；第二个参数是方法入参的对象类型。获取方法反射对象后，即可通过invoke（Object obj,Object param）方法调用目标类的方法，该方法的第一个参数是操作的目标类对象实例；第二个参数是目标方法的入参。 </p>
<p>在代码清单3 10中，粗体所示部分的信息即是通过反射方法操控目标类的元信息，如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用的代码对类似于Car的类进行实例化及功能调用操作了。 </p>
<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3><h4 id="类装载器工作机制"><a href="#类装载器工作机制" class="headerlink" title="类装载器工作机制"></a>类装载器工作机制</h4><p>类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： </p>
<ul>
<li>装载：查找和导入Class文件； </li>
<li>链接：执行校验、准备和解析步骤，其中解析步骤是可以选择的： <ul>
<li>校验：检查载入Class文件数据的正确性； </li>
<li>准备：给类的静态变量分配存储空间； </li>
<li>解析：将符号引用转成直接引用； </li>
</ul>
</li>
<li>初始化：对类的静态变量、静态代码块执行初始化工作。 </li>
</ul>
<p>类装载工作由ClassLoader及其子类负责，ClassLoader是一个重要的Java运行时系统组件，它负责在运行时查找和装入Class字节码文件。JVM在运行时会产生三个ClassLoader：根装载器、ExtClassLoader（扩展类装载器）和AppClassLoader（系统类装载器）。其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在Java中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的rt.jar、charsets.jar等。ExtClassLoader和AppClassLoader都是ClassLoader的子类。其中ExtClassLoader负责装载JRE扩展目录ext中的JAR类包；AppClassLoader负责装载Classpath路径下的类包。 </p>
<p>这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下，使用AppClassLoader装载应用程序的类，我们可以做一个实验： </p>
<p>代码清单3-11  ClassLoaderTest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">        System.out.println(&quot;current loader:&quot;+loader);  </div><div class="line">        System.out.println(&quot;parent loader:&quot;+loader.getParent());  </div><div class="line">        System.out.println(&quot;grandparent loader:&quot;+loader.getParent(). getParent());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上代码，在控制台上将打出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">current loader:sun.misc.Launcher$AppClassLoader@131f71a </div><div class="line">parent loader:sun.misc.Launcher$ExtClassLoader@15601ea </div><div class="line"> //①根装载器在Java中访问不到，所以返回null </div><div class="line">grandparent loader:null</div></pre></td></tr></table></figure></p>
<p>通过以上的输出信息，我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在Java中无法获得它的句柄，所以仅返回null。 </p>
<p>JVM装载类时使用“全盘负责委托机制”，“全盘负责”是指当一个ClassLoader装载一个类的时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全角度考虑的，试想如果有人编写了一个恶意的基础类（如java.lang.String）并装载到JVM中将会引起多么可怕的后果。但是由于有了“全盘负责委托机制”，java.lang.String永远是由根装载器来装载的，这样就避免了上述事件的发生。 </p>
<h4 id="ClassLoader重要方法"><a href="#ClassLoader重要方法" class="headerlink" title="ClassLoader重要方法"></a>ClassLoader重要方法</h4><p>在Java中，ClassLoader是一个抽象类，位于java.lang包中。下面对该类的一些重要接口方法进行介绍： </p>
<ul>
<li><p>Class loadClass(String name)<br>  name参数指定类装载器需要装载类的名字，必须使用全限定类名，如com.baobaotao. beans.Car。该方法有一个重载方法loadClass(String name ,boolean resolve)，resolve参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进行类解析的工作，但并不是所有的类都需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。 </p>
</li>
<li><p>Class defineClass(String name, byte[] b, int off, int len)<br> 将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。</p>
</li>
<li><p>Class findSystemClass(String name)<br> 从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 </p>
</li>
<li><p>Class findLoadedClass(String name)<br>调用该方法来查看ClassLoader是否已装入某个类。如果已装入，那么返回java.lang.Class对象，否则返回null。如果强行装载已存在的类，将会抛出链接错误。 </p>
</li>
<li><p>ClassLoader getParent()<br> 获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 </p>
</li>
</ul>
<p>除JVM默认的三个ClassLoader以外，可以编写自己的第三方类装载器，以实现一些特殊的需求。类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用，如图3-4所示。 </p>
<p><img src="/images/图3-4 类加载.jpg"></p>
<p>每一个类在JVM中都拥有一个对应的java.lang.Class对象，它提供了类结构信息的描述。数组、枚举、注解以及基本Java类型（如int、double等），甚至void都拥有对应的Class对象。Class没有public的构造方法。Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 </p>
<h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p>Class反射对象描述类语义结构，可以从Class对象中获取构造函数、成员变量、方法类等类元素的反射对象，并以编程的方式通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类： </p>
<ul>
<li><p>Constructor：类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。在JDK5.0中，还可以通过getConstructor(Class… parameterTypes)获取拥有特定入参的构造函数反射对象。Constructor的一个主要方法是newInstance(Object[] initargs)，通过该方法可以创建一个对象类的实例，相当于new关键字。在JDK5.0中该方法演化为更为灵活的形式：newInstance (Object… initargs)。</p>
</li>
<li><p>Method：类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组Method[]。在JDK5.0中可以通过getDeclaredMethod(String name, Class… parameterTypes)获取特定签名的方法，name为方法名；Class…为方法入参类型列表。Method最主要的方法是invoke(Object obj, Object[] args)，obj表示操作的目标对象；args为方法入参，代码清单3 10③处演示了这个反射类的使用方法。在JDK 5.0中，该方法的形式调整为invoke(Object obj, Object… args)。此外，Method还有很多用于获取类方法更多信息的方法：</p>
<pre><code>- Class getReturnType()：获取方法的返回值类型； 
- Class[] getParameterTypes()：获取方法的入参类型数组； 
- Class[] getExceptionTypes()：获取方法的异常类型数组； 
- Annotation[][] getParameterAnnotations()：获取方法的注解信息，JDK 5.0中的新方法；
</code></pre></li>
<li><p>Field：类的成员变量的反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredField(String name)则可获取某个特定名称的成员变量反射对象。Field类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标对象的成员变量设置值。如果成员变量为基础类型，用户可以使用Field类中提供的带类型名的值设置方法，如setBoolean(Object obj, boolean value)、setInt(Object obj, int value)等。</p>
</li>
</ul>
<p>此外，Java还为包提供了Package反射类，在JDK 5.0中还为注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中所有的元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用，请看下面的例子： </p>
<p>代码清单3-12  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.reflect;  </div><div class="line">public class PrivateCar &#123;  </div><div class="line">   //①private成员变量：使用传统的类实例调用方式，只能在本类中访问  </div><div class="line">   private String color;   </div><div class="line">   //②protected方法：使用传统的类实例调用方式，只能在子类和本包中访问  </div><div class="line">   protected void drive()&#123;       </div><div class="line">		System.out.println(&quot;drive private car! the color is:&quot;+color);  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>color变量和drive()方法都是私有的，通过类实例变量无法在外部访问私有变量、调用私有方法的，但通过反射机制却可以绕过这个限制： </p>
<p>代码清单3-13  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">…  </div><div class="line">public class PrivateCarReflect &#123;  </div><div class="line">   public static void main(String[] args) throws Throwable&#123;  </div><div class="line">       ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">       Class clazz = loader.loadClass(&quot;com.baobaotao.reflect.PrivateCar&quot;);  </div><div class="line">       PrivateCar pcar = (PrivateCar)clazz.newInstance();   </div><div class="line">       Field colorFld = clazz.getDeclaredField(&quot;color&quot;);  </div><div class="line">        //①取消Java语言访问检查以访问private变量  </div><div class="line">       colorFld.setAccessible(true);   </div><div class="line">       colorFld.set(pcar,&quot;红色&quot;);  </div><div class="line">       Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;,(Class[])null);  </div><div class="line">        //Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;); JDK5.0下使用  </div><div class="line">        //②取消Java语言访问检查以访问protected方法  </div><div class="line">       driveMtd.setAccessible(true);   </div><div class="line">       driveMtd.invoke(pcar,(Object[])null);  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行该类，打印出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drive private car! the color is:红色</div></pre></td></tr></table></figure></p>
<p>在访问private、protected成员变量和方法时必须通过setAccessible(boolean access)方法取消Java语言检查，否则将抛出IllegalAccessException。如果JVM的安全管理器设置了相应的安全机制，调用该方法将抛出SecurityException。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap]]></title>
      <url>http://zsr.github.io/2016/08/01/HashMap/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashMap"><a href="#OpenJDK-源代码阅读之-HashMap" class="headerlink" title="OpenJDK 源代码阅读之 HashMap"></a>OpenJDK 源代码阅读之 HashMap</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractMap&lt;K,V&gt;</div><div class="line">        java.util.HashMap&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashMap&lt;K,V&gt;</div><div class="line">extends AbstractMap&lt;K,V&gt;</div><div class="line">implements Map&lt;K,V&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>1) 与 Hashtable 区别在于：非同步，允许 <code>null</code><br>2) 不保证次序，甚至不保证次序随时间不变<br>3) 基本操作 put, get 常量时间<br>4) 遍历操作 与 capacity+size 成正比<br>5) HashMap 性能与 <code>capacity</code> 和 <code>load factor</code> 相关，<code>load factor</code> 是当前元素个数与 <code>capacity</code> 的比值，通常设定为 <code>0.75</code>，如果此值过大，空间利用率高，但是冲突的可能性增加，因而可能导致查找时间增加，如果过小，反之。当元素个数大于 <code>capacity * load_factor</code> 时，<code>HashMap</code> 会重新安排 Hash 表。因此高效地使用 <code>HashMap</code> 需要预估元素个数，设置最佳的 <code>capacity</code> 和 <code>load factor</code> ，使得重新安排 Hash 表的次数下降。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>capacity</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，<code>HashMap</code> 并不会按照你指定的 <code>initialCapacity</code> 来确定 <code>capacity</code> 大小，而是会找到一个比它大的数，并且是 <code>2的n次方</code>（原因见末尾）。</p>
<ul>
<li>hash </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Retrieve object hash code and applies a supplemental hash function to the</div><div class="line"> * result hash, which defends against poor quality hash functions.  This is</div><div class="line"> * critical because HashMap uses power-of-two length hash tables, that</div><div class="line"> * otherwise encounter collisions for hashCodes that do not differ</div><div class="line"> * in lower bits. Note: Null keys always map to hash 0, thus index 0.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</div><div class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h = hashSeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 <code>k</code> 是 <code>String</code> 类型，使用了特别的 <code>hash</code> 函数，否则首先得到 <code>hashCode</code>，然后又对 <code>h</code> 作了移位，异或操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">at 22: </div><div class="line">h = abcdefgh</div><div class="line">h1 = h &gt;&gt;&gt; 20 = 00000abc</div><div class="line">h2 = h &gt;&gt;&gt; 12 = 000abcde</div><div class="line">h3 = h1 ^ h2 = [0][0][0][a][b][a^c][b^d][c^e]</div><div class="line">h4 = h ^ h3 = [a][b][c][a^d][b^e][a^c^f][b^d^g][c^e^h]</div><div class="line">h5 = h4 &gt;&gt;&gt; 4 = [0][a][b][c][a^d][b^e][a^c^f][b^d^g]</div><div class="line">h6 = h4 &gt;&gt;&gt; 7 = ([0][:3])[0][0][a][b][c][a^d][b^e][a^c^f]([a^c^f][0])</div></pre></td></tr></table></figure>
<ul>
<li>put</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</div><div class="line"> * <span class="doctag">@param</span> value value to be associated with the specified key</div><div class="line"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>put</code> 其实可以看出各个 <code>hash</code> 表是如何实现的，首先取得 <code>hash</code> 值，然后由 <code>indexFor</code> 找到链表头的 <code>index</code>，然后开始遍历链表，如果链表里的一个元素 <code>hash</code> 值与当前 <code>key</code> 的 <code>hash</code> 值相同，或者元素 <code>key</code> 的引用与当前 <code>key</code> 相同，或者 <code>equals</code> 相同，就说明当前 <code>key</code> 已经在 <code>hash</code> 表里了，那么修改它的值，返回旧值。</p>
<p>如果不在表里，会调用 <code>addEntry</code>，将这一 <code>(key, value)</code> 对添加进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds a new entry with the specified key, value and hash code to</div><div class="line"> * the specified bucket.  It is the responsibility of this</div><div class="line"> * method to resize the table if appropriate.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of put method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Like addEntry except that this version is used when creating entries</div><div class="line"> * as part of Map construction or "pseudo-construction" (cloning,</div><div class="line"> * deserialization).  This version needn't worry about resizing the table.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of HashMap(Map),</div><div class="line"> * clone, and readObject.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，新增加元素时，可能会调整 <code>hash</code> 表的大小，原因之前已经讨论过。直接的添加在 <code>createEntry</code> 中完成，但是这里并没有体现出如何处理冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里，将 <code>n</code> 赋值给了 <code>next</code>，这其实就是将新添加的项指向了当前链表头。这一操作在 <code>Entry</code> 的构造函数中完成。</p>
<p><code>put</code> 操作的基本思路在到这里已经很清楚了，有了这个思路，不难想象 <code>get</code> 是如何动作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 <code>put</code> 差不多，只是找到了就会返回相应的 <code>value</code> ，找不到就返回 <code>null</code>。</p>
<ul>
<li>HashMap的底层数组长度总是2的n次方 原因:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Returns index for hash code h.</div><div class="line">    */</div><div class="line">   static int indexFor(int h, int length) &#123;</div><div class="line">   // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class="line">      return h &amp; (length-1);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化</p>
<p>indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。</p>
<p>这里我们假设length为16(2^n)和15，h为5、6、7。</p>
<p><img src="/images/hashmap1-1.jpg"></p>
<p> 当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p>
<p><img src="/images/hashmap1-2.jpg"></p>
<p> 从上面的图表中看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git使用小记]]></title>
      <url>http://zsr.github.io/2016/08/01/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Git使用小记"><a href="#Git使用小记" class="headerlink" title="Git使用小记"></a>Git使用小记</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。</p>
<!--![git](git流程.png)-->
<p><img src="/images/git流程.png"></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><p>了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。</p>
<p>从时间先后来讲，工作目录的内容是你当前看到的，也是最新的；index区标记了你当前工作目录中，哪些内容是被git管理的；而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些；远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p>
<p>任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。<br><a id="more"></a></p>
<h3 id="远程仓库操作命令"><a href="#远程仓库操作命令" class="headerlink" title="远程仓库操作命令"></a>远程仓库操作命令</h3><ul>
<li><p>从远程仓库克隆仓库到本地：$ git clone git://github.com/**.git</p>
</li>
<li><p>查看远程仓库别名以及地址：$ git remote -v</p>
</li>
<li><p>添加远程仓库：$ git remote add [name] [url]</p>
</li>
<li><p>删除远程仓库：$ git remote rm [name]</p>
</li>
<li><p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
</li>
<li><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
</li>
<li><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
</li>
<li><p>提交本地test分支作为远程的master分支：$git push origin test:master</p>
</li>
<li><p>提交本地test分支作为远程的test分支：$git push origin test:test</p>
</li>
</ul>
<h3 id="分支操作命令–branch"><a href="#分支操作命令–branch" class="headerlink" title="分支操作命令–branch"></a>分支操作命令–branch</h3><ul>
<li><p>查看远程和本地所有分支：$ git branch -a</p>
</li>
<li><p>创建本地分支：$ git branch [name]</p>
</li>
<li><p>切换分支：$ git checkout [name]</p>
</li>
<li><p>创建新分支并且切换到新的分支：$ git check -b [name]</p>
</li>
<li><p>复制远程的分支并且以此来创建新分支：$ git check -t /remotes/origin/branch1 //这样就能在本地创建一个复制来自远程branch1分支</p>
</li>
<li><p>删除分支：$ git branch -d [name] //-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
</li>
<li><p>合并分支：$git merge [name] //将名称为[name]的分支与当前的分支合并</p>
</li>
<li><p>创建远程分支：(本地分支push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p>
</li>
</ul>
<h3 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h3><ul>
<li><p>查看版本：$ git tag</p>
</li>
<li><p>创建版本：$ git tag [name]</p>
</li>
<li><p>删除版本：$ git tag -d [name]</p>
</li>
<li><p>查看远程版本：$ git tag -r</p>
</li>
<li><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程版本：$ git push origin :refs/tags/[name]</p>
</li>
<li><p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
</li>
<li><p>上传本地tag到远程仓库：$ git push origin –tags</p>
</li>
<li><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
</li>
</ul>
<h3 id="子模块-submodule-相关操作命令"><a href="#子模块-submodule-相关操作命令" class="headerlink" title="子模块(submodule)相关操作命令"></a>子模块(submodule)相关操作命令</h3><ul>
<li><p>添加子模块：$ git submodule add [url] [path]</p>
</li>
<li><p>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</p>
</li>
<li><p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p>
</li>
<li><p>删除子模块：（分4步走哦）</p>
<ul>
<li><p>$ git rm –cached [path]</p>
</li>
<li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>编辑“ .git/config”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>手动删除子模块残留的目录</p>
</li>
</ul>
</li>
<li><p>忽略一些文件、文件夹不提交</p>
<ul>
<li>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target</div><div class="line">bin</div><div class="line">*.db</div></pre></td></tr></table></figure>
<ul>
<li><p>删除缓存区的文件</p>
<ul>
<li>不怎么进行删除操作，所以就常用这一个命令：$ git rm -r –cached .</li>
</ul>
</li>
</ul>
<h3 id="git撤销操作"><a href="#git撤销操作" class="headerlink" title="git撤销操作"></a>git撤销操作</h3><h5 id="撤销已暂存的操作"><a href="#撤销已暂存的操作" class="headerlink" title="撤销已暂存的操作"></a>撤销已暂存的操作</h5><p>对于一些已经被git add后的文件，如果想要撤销刚刚的操作，就要进行如下操作:</p>
<ul>
<li>首先查看一下本地有哪些已经被add但是还未commit的数据，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<ul>
<li>然后找到你要进行删掉的文件后，执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD filename</div></pre></td></tr></table></figure>
<h5 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h5><p>对于已经commit的数据，要回退的步骤为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm -r --cached</div></pre></td></tr></table></figure>
<h3 id="git-版本回退"><a href="#git-版本回退" class="headerlink" title="git 版本回退"></a>git 版本回退</h3><h5 id="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"><a href="#关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退" class="headerlink" title="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"></a>关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退</h5><p>1.先来说说本地的好了，本地的话就依次执行一下操作即可。</p>
<p>根据-soft,-mixed,-hard，会对working tree和index和HEAD进行重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.git reset -mixed：这种为默认方式，不带任何参数的git reset，它回退到某个版本，只保留源码，回退commit和index信息</div><div class="line">2.git reset -soft: 回退到某个版本，只回退了commit信息，不会恢复到index file一级。如果还要提交的话，直接commit即可。</div><div class="line">3.git reset -hard:彻底回退到某个版本，本地的源码也会变成上一个版本的内容，操作需要谨慎！！</div><div class="line">示例：</div><div class="line">* HEAD是指向最新的提交的，上一次的提交是HEAD^,上上次是HEAD^^,也可以写成HEAD~2,其中的--hard表示放弃所有本地改动</div><div class="line">git reset --hard HEAD^</div></pre></td></tr></table></figure></p>
<p>或者也可以回退倒指定的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;哈希值&gt;</div></pre></td></tr></table></figure>
<p>2.关于远程的话也得分情况了，如果远程仓库能够远程ssh上去的话那就比较简单了，方法和在本地一样了，但是如果ssh上不上去就不行了，这里我看到找到了两种方法：</p>
<ul>
<li>第一种就是比较暴力的方法，就是直接强制提交，git push -f,但是这个非常不推荐，除非你是自己一个人开发的小项目。</li>
<li>第二种就是先将远程分支备份好以后直接删除，然后再将本地的回滚后的版本的push到远程分支上，这样就等于回退了版本。</li>
</ul>
<h3 id="git-merge解冲突"><a href="#git-merge解冲突" class="headerlink" title="git merge解冲突"></a>git merge解冲突</h3><h5 id="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"><a href="#在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。" class="headerlink" title="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"></a>在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。</h5><p>这里假设有两个分支，一个是develop分支，一个是developby分支，develop分支是主要分支，这时候，我们可以 在developby分支里面运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge develop</div></pre></td></tr></table></figure>
<p>这样的话就将将develop中的内容merge到了developby分支中，如果没有冲突的话，merge完成，如果有冲突的话，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<p>这样的话git会列出有冲突的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">printf (“test1″);</div><div class="line">=======</div><div class="line">printf (“test2″);</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</div></pre></td></tr></table></figure>
<h5 id="接下来我们来讲解一下里面的符号各代表什么意思。"><a href="#接下来我们来讲解一下里面的符号各代表什么意思。" class="headerlink" title="接下来我们来讲解一下里面的符号各代表什么意思。"></a>接下来我们来讲解一下里面的符号各代表什么意思。</h5><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记冲突的开始，后面的内同是当前分支中的内容。</p>
<p>HEAD 指向当前分支末梢的提交。</p>
<p>=======之后，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之前 是从develop分支上面merge过来的代码。&gt;&gt;&gt;&gt;&gt;&gt;&gt;之后跟的是要合并过来的分支的名称。</p>
<h5 id="然后我们就开始手动解冲突了"><a href="#然后我们就开始手动解冲突了" class="headerlink" title="然后我们就开始手动解冲突了"></a>然后我们就开始手动解冲突了</h5><p>这时候根据你的需要选择你要保留的是哪个分支上的代码，你要删除哪个分支上的代码，想要删除的代码就直接删掉就可以了，最后将多余符号删掉保存就可以了。</p>
<h3 id="一般的代码管理流程："><a href="#一般的代码管理流程：" class="headerlink" title="一般的代码管理流程："></a>一般的代码管理流程：</h3><ul>
<li><p>远程已经建完仓库后直接克隆到本地： $ git clone [仓库地址]</p>
</li>
<li><p>查看本地和远程的branch：$ git branch -a</p>
</li>
<li><p>如果远程的branch更新了的话运行：$ git fetch -p //这样会将远程的分支列表重新拉取</p>
</li>
<li><p>将远程的branch复制到本地并且切换到这个分支下面：$ git checkout -t [远程分支名字]</p>
</li>
<li><p>这是看到自己已经在新建的branch下面了，然后看一下有没有文件。</p>
</li>
<li><p>若没有的话试一下：$ git pull</p>
</li>
<li><p>做完修改以后的话先add：$ git add . //这样会将除了在.gitignore中写入的文件都加入进要提交的文件内</p>
</li>
<li><p>然后进行提交到本地仓库：$ git commit - m “提交”</p>
</li>
<li><p>可以查看状态：$ git status 或者 $git diff</p>
</li>
<li><p>如果没什么问题的话就进行提交到远程库： $ git push //如果加入-f的话是强制提交。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList]]></title>
      <url>http://zsr.github.io/2016/07/29/ArrayList/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-ArrayList"><a href="#OpenJDK-源码阅读之-ArrayList" class="headerlink" title="OpenJDK 源码阅读之 ArrayList"></a>OpenJDK 源码阅读之 ArrayList</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractList&lt;E&gt;</div><div class="line">            java.util.ArrayList&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>transient</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>声明为 <code>transient</code>后，这个字段不会被序列化。</p>
<ul>
<li>toArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a list containing the elements of the specified</div><div class="line"> * collection, in the order they are returned by the collection's</div><div class="line"> * iterator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对 <code>elementData</code> 的检查，<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="external">Bug 6260652</a>中对此有详细描述。主要原因是 <code>c.toArray()</code> 不一定会返回　<code>Object[]</code> 类型的值。</p>
<a id="more"></a>
<ul>
<li>SuppressWarnings</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">               ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</div></pre></td></tr></table></figure>
<p>告诉编译器，对特定类型的 <code>warning</code> 保持静默。</p>
<ul>
<li>参数检查</li>
</ul>
<p>可以看出标准库中的程序，在很多地方都需要对参数进行检查，以保证程序的健壮性。</p>
<p>检查 <code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>检查参数上界，下界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>ArrayList 的 index 检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       rangeCheck(index);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> elementData(index);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意　<code>rangeCheck</code> 只检查了上界，但是如果将　<code>index</code> 设置成负数，也会抛出异常，异常是在 <code>elementData[index]</code> 中抛出的，猜想是在数组的实现中，对负数进行检查，因为任何一个数组，<code>index</code> 都不可能为负数，但是在实现数组时，不知道数组的元素个数，所以上界检查在此时发生。</p>
<ul>
<li>元素访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>专门写了一个函数用来访问元素，而不是直接使用 <code>elementData[index]</code>，只因为需要向上转型么？还是 <code>SuppressWarning</code>　会重复。</p>
<ul>
<li>private</li>
</ul>
<p>对于仅仅在类内部使用的函数，要声明为 <code>private</code>。</p>
<ul>
<li>add 参数检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">     rangeCheckForAdd(index);</div><div class="line"></div><div class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">     System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                      size - index);</div><div class="line">     elementData[index] = element;</div><div class="line">     size++;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出这里对　<code>index</code> 的上界和下界都检查了，虽然　<code>add</code> 的<code>7</code> 行会进行检查，但在 <code>add</code>　的 <code>4</code>, <code>5</code> 行中就已经可能出错。</p>
<ul>
<li>强制垃圾回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意第 <code>11</code>行把最后一个元素设置为<code>null</code>，这可以使得<code>gc</code>工作。好奇如何用实验验证这一点。</p>
<ul>
<li>remove(Object o)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个框架与 <code>indexOf</code> 函数是相似的，注意那个 <code>fastRemove</code> 函数，它与 <code>remove(index)</code> 的不同在于它：</p>
<ol>
<li>是 <code>private</code></li>
<li>无参数检查，因为传给它的参数一定是合法的</li>
<li>不返回值</li>
</ol>
<p>由此细节可见，标准库中函数的精益求精。(不知道是不是我过度揣测了，有经过性能测试么？)</p>
<ul>
<li>batchRemove</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</div><div class="line">     <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">     <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">             <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</div><div class="line">                 elementData[w++] = elementData[r];</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">         <span class="comment">// even if c.contains() throws.</span></div><div class="line">         <span class="keyword">if</span> (r != size) &#123;</div><div class="line">             System.arraycopy(elementData, r,</div><div class="line">                              elementData, w,</div><div class="line">                              size - r);</div><div class="line">             w += size - r;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (w != size) &#123;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</div><div class="line">                 elementData[i] = <span class="keyword">null</span>;</div><div class="line">             modCount += size - w;</div><div class="line">             size = w;</div><div class="line">             modified = <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> modified;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>注意 <code>finally</code> 里的代码，这段代码保证，即使 <code>try</code> 中的代码出了问题，也会最大程度上保证数据的一致性。如果 <code>r</code> 没有遍历完，那么后面没有检查过的数据都要保留下来。</p>
<ul>
<li>线程安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out array length</span></div><div class="line">    s.writeInt(elementData.length);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意那个　<code>modCount</code> 的检查，这是为了确定在 <code>5-12</code>　行代码执行过程中，<code>List</code> 没有改变。改变的原因可能是由于多线程并发执行，在这期间另一个线程执行，改变了 <code>List</code> 的状态。</p>
<ul>
<li>容量扩充</li>
</ul>
<p>容量扩充会在任何可能引起　<code>ArrayList</code> 大小改变的情况下发生，如何扩充呢，代码在 <code>grow</code> 函数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="comment">// overflow-conscious code</span></div><div class="line">     <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">         newCapacity = minCapacity;</div><div class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">         newCapacity = hugeCapacity(minCapacity);</div><div class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">     <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">         Integer.MAX_VALUE :</div><div class="line">         MAX_ARRAY_SIZE;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出，<code>oldCapacity</code> 新增的容量是它的一半。另外，还有一个 <code>hugeCapacity</code>，如果需要扩充的容量比　<code>MAX_ARRAY_SIZE</code> 还大，会调用这个函数，重新调整大小。但再大也大不过　<code>Integer.MAX_VALUE</code>。</p>
<ul>
<li>元素位置调整</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论是增加元素还是删除元素，都可能使得很多元素的位置发生改变，这里就是用 <code>System.arraycopy</code> 来把大量元素放在其它位置，如果元素很多，经常需要调整，是很浪费时间的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-coding-style]]></title>
      <url>http://zsr.github.io/2016/07/29/java-coding-style/</url>
      <content type="html"><![CDATA[<h1 id="Java编码风格"><a href="#Java编码风格" class="headerlink" title="Java编码风格"></a>Java编码风格</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这份文档源自Google Java编程风格规范，并根据我的想法，做了一些调整，当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Ximalaya直播team的Java编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是强制要求的，我们尽量不提供意见。</p>
<h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p>
<p>术语<code>class</code>可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语<code>comment</code>只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p>
<h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Ximalaya编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<a id="more"></a>
<h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h3 id="2-2-编码"><a href="#2-2-编码" class="headerlink" title="2.2 编码"></a>2.2 编码</h3><p>源文件编码格式为<code>UTF-8</code>。</p>
<h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><p>不要使用特殊字符。</p>
<h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p>
<ul>
<li>许可证或版权信息</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ul>
<blockquote>
<p>以上每个部分之间用一个空行隔开。</p>
</blockquote>
<h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。<br>公司版权信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 文件名称: $&#123;filename&#125; Copyright 2011-2014 Ximalaya All right reserved.</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，即package语句写在一行里。</p>
<h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>
<h4 id="3-3-2-不要import静态变量和方法"><a href="#3-3-2-不要import静态变量和方法" class="headerlink" title="3.3.2 不要import静态变量和方法"></a>3.3.2 不要import静态变量和方法</h4><p>即，不要出现类似这样的import语句：<code>import static org.junit.Assert.fail;</code></p>
<h4 id="3-3-3-不要换行"><a href="#3-3-3-不要换行" class="headerlink" title="3.3.3 不要换行"></a>3.3.3 不要换行</h4><p>import语句不换行，即每个import语句独立成行。</p>
<h4 id="3-3-4-顺序和间距"><a href="#3-3-4-顺序和间距" class="headerlink" title="3.3.4 顺序和间距"></a>3.3.4 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<p>每个顶级包为一组，字典序，组内不空行，按字典序排列。</p>
<h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p>
<p>例外：package-info.java，该文件中可没有package-info类。</p>
<h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<p>总的来说，按照<code>static</code>、<code>private</code>、<code>protected</code>等修饰符归类。</p>
<h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p>
<p>左大括号前不换行<br>左大括号后换行<br>右大括号前换行<br>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">return new MyClass() &#123;</div><div class="line">  @Override public void method() &#123;</div><div class="line">    if (condition()) &#123;</div><div class="line">      try &#123;</div><div class="line">        something();</div><div class="line">      &#125; catch (ProblemException e) &#123;</div><div class="line">        recover();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>4.8.1节给出了enum类的一些例外。</p>
</blockquote>
<h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void doNothing() &#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>不过理论上不应该出现这样什么都不做的方法或if/else等。</p>
</blockquote>
<h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p>
<h3 id="4-4-列限制：100"><a href="#4-4-列限制：100" class="headerlink" title="4.4 列限制：100"></a>4.4 列限制：100</h3><p>一个项目可以选择一行100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<p>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。<br>package和import语句(见3.2节和3.3节)。<br>注释中那些可能被剪切并粘贴到shell中的命令行。</p>
<h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行，我们通常通过使用统一的eclipse formatter来保证大家的换行格式统一，格式优美是首先要考虑的。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题，或者合理缩短命名长度。</p>
</blockquote>
<h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p>
<p>类内连续的成员之间：</p>
<ul>
<li>字段</li>
<li>构造函数</li>
<li>方法</li>
<li>嵌套类</li>
<li>静态初始化块</li>
<li>实例初始化块</li>
</ul>
<p>例外：</p>
<ul>
<li><code>两个连续字段之间的空行是可选的</code>，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句根据业务逻辑分组。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ul>
<h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ul>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li>@SomeAnnotation({a, b})(不使用空格)。</li>
<li>String[][] x = foo;(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<t extends="" foo="" &="" bar="">)。</t></li>
</ul>
</li>
<li>catch块中的管道符号(catch (FooException | BarException e)。</li>
<li>foreach语句中的分号。</li>
<li>在, : ;及右括号())后</li>
<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li>
</ul>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h4 id="4-6-3-水平对齐：不建议"><a href="#4-6-3-水平对齐：不建议" class="headerlink" title="4.6.3 水平对齐：不建议"></a>4.6.3 水平对齐：不建议</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private int x; // this is fine</div><div class="line">private Color color; // this too</div><div class="line"></div><div class="line">private int   x;      // 不建议</div><div class="line">private Color color;  // 不建议</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
</blockquote>
<h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如<code>int a, b;</code>。</p>
<h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1, 2, 3 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0,</div><div class="line">  1,</div><div class="line">  2,</div><div class="line">  3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1,</div><div class="line">  2, 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new int[]</div><div class="line">    &#123;0, 1, 2, 3&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：String[] args， 而非String args[]。</p>
<h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (input) &#123;</div><div class="line">  case 1:</div><div class="line">  case 2:</div><div class="line">    handleOneTwoOr();</div><div class="line">    break;</div><div class="line">  case 3:</div><div class="line">    handleThree();</div><div class="line">    break;</div><div class="line">  default:</div><div class="line">    handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>
<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h5 id="4-8-4-2-default的情况要写出来"><a href="#4-8-4-2-default的情况要写出来" class="headerlink" title="4.8.4.2 default的情况要写出来"></a>4.8.4.2 default的情况要写出来</h5><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p>
<h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">@Nullable</div><div class="line">public String getNameIfPresent() &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的多个注解不允许与字段出现在同一行，并且一个注解独占一行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Partial </div><div class="line">@Mock </div><div class="line">DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<p>例外：应用于方法参数的注解<code>不用换行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public String getNameIfPresent(@RequestParam String param) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * This is          // And so           /**  </div><div class="line"> * okay.            // is this.          * Or you can even do this.</div><div class="line"> */                                      */</div><div class="line">注释不要封闭在由星号或其它字符绘制的框架里。</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
</blockquote>
<h5 id="4-8-6-2-被注释的代码"><a href="#4-8-6-2-被注释的代码" class="headerlink" title="4.8.6.2 被注释的代码"></a>4.8.6.2 被注释的代码</h5><p>有时可能出于某种原因某段代码被注释，那么在之后的10个commit内，建议移除。</p>
<h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<ul>
<li>public </li>
<li>protected </li>
<li>private </li>
<li>abstract </li>
<li>static </li>
<li>final </li>
<li>transient </li>
<li>volatile </li>
<li>synchronized </li>
<li>native </li>
<li>strictfp</li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p>
<h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以UpperCamelCase风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p>
<h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以lowerCamelCase风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Constants</div><div class="line">static final int NUMBER = 5;</div><div class="line">static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</div><div class="line">static final Joiner COMMA_JOINER = Joiner.on(&apos;,&apos;);  // because Joiner is immutable</div><div class="line">static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line">// Not constants</div><div class="line">static String nonFinal = &quot;non-final&quot;;</div><div class="line">final String nonStatic = &quot;non-static&quot;;</div><div class="line">static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();</div><div class="line">static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line">static final Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line">static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以lowerCamelCase风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以lowerCamelCase风格编写。</p>
<p>参数应该避免用单个字符命名，并且要尽量容易理解。</p>
<h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p>
<p>单个或者多个的大写字母，后面可以跟一个数字(如：E, T, X, IN, OUT)。</p>
<h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ul>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Prose form                Correct               Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</div><div class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</div><div class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</div><div class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</div><div class="line">&quot;YouTube importer&quot;        YouTubeImporter</div><div class="line">                          YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p>
</blockquote>
<h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h3><p>只要是合法的，就把@Override注解给用上。</p>
<h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p>
<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  int i = Integer.parseInt(response);</div><div class="line">  return handleNumericResponse(i);</div><div class="line">&#125; catch (NumberFormatException ok) &#123;</div><div class="line">  // it&apos;s not numeric; that&apos;s fine, just continue</div><div class="line">&#125;</div><div class="line">return handleTextResponse(response);</div></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  emptyStack.pop();</div><div class="line">  fail();</div><div class="line">&#125; catch (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); // good</div><div class="line">aFoo.aStaticMethod(); // bad</div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); // very bad</div></pre></td></tr></table></figure>
<h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重载Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Multiple lines of Javadoc text are written here,</div><div class="line"> * wrapped normally...</div><div class="line"> */</div><div class="line">public int method(String p1) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/** An especially short bit of Javadoc. */</div></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。<br>它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public的<code>class</code>及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>
<h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。</p>
</blockquote>
<h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>
<h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zsr.github.io/2016/07/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
