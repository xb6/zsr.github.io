<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[BlockingQueue]]></title>
      <url>http://zsr.github.io/2016/08/16/BlockingQueue/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-BlockingQueue"><a href="#OpenJDK-源码阅读之-BlockingQueue" class="headerlink" title="OpenJDK 源码阅读之 BlockingQueue"></a>OpenJDK 源码阅读之 BlockingQueue</h1><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在java.util.Concurrent包中，BlockingQueue很好的解决了在多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。同时，BlockingQueue也用于java自带线程池的缓冲队列中，了解BlockingQueue也有助于理解线程池的工作模型。</p>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h4><p>该接口属于队列，所以继承了Queue接口，该接口最重要的五个方法分别是offer方法，poll方法，put方法，take方法和drainTo方法。</p>
<p>offer方法和poll方法分别有一个静态重载方法，分别是offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)方法。其意义是在限定时间内存入或取出对象，如果不能存入取出则返回false。</p>
<p>put方法会在当队列存储对象达到限定值时阻塞线程，而在队列不为空时唤醒被take方法所阻塞的线程。take方法是相反的。</p>
<p>drainTo方法可批量获取队列中的元素。</p>
<h4 id="常见的BlockingQueue实现"><a href="#常见的BlockingQueue实现" class="headerlink" title="常见的BlockingQueue实现"></a>常见的BlockingQueue实现</h4><ul>
<li>LinkedBlockingQueue</li>
</ul>
<p>LinkedBlockingQueue是比较常见的BlockingQueue的实现，他是基于链表的阻塞队列。在创建该对象时如果不指定可存储对象个数大小时，默认为Integer.MAX_VALUE。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p>LinkedBlockingQueue内部使用了独立的两把锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p>put方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        try &#123;</div><div class="line">            while (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            if (c + 1 &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>offer方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    public boolean offer(E e) &#123;</div><div class="line">        if (e == null) throw new NullPointerException();</div><div class="line">        final AtomicInteger count = this.count;</div><div class="line">        if (count.get() == capacity)</div><div class="line">            return false;</div><div class="line">        int c = -1;</div><div class="line">        Node&lt;E&gt; node = new Node(e);</div><div class="line">        final ReentrantLock putLock = this.putLock;</div><div class="line">        putLock.lock();</div><div class="line">        try &#123;</div><div class="line">            if (count.get() &lt; capacity) &#123;</div><div class="line">                enqueue(node);</div><div class="line">                c = count.getAndIncrement();</div><div class="line">                if (c + 1 &lt; capacity)</div><div class="line">                    notFull.signal();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        if (c == 0)</div><div class="line">            signalNotEmpty();</div><div class="line">        return c &gt;= 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法的区别是put方法在容量达到上限时会阻塞，而offer方法则会直接返回false。</p>
<ul>
<li>ArrayBlockingQueue</li>
</ul>
<p>ArrayBlockingQueue是基于数组的阻塞队列，除了有一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。<br>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p>是一种没有缓冲的阻塞队列，在生产者put的同时必须要有一个消费者进行take，否则就会阻塞。声明一个SynchronousQueue有两种不同的方式。公平模式和非公平模式的区别:如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<ul>
<li>PriorityBlockingQueue和DelayQueue</li>
</ul>
<p>PriorityBlockingQueue是基于优先级的阻塞队列，该队列不会阻塞生产者，只会阻塞消费者。<br>DelayQueue队列存储的对象只有指定的延迟时间到了才能被取出，该队列也不会阻塞生产者。</p>
<h4 id="BlockingQueue的使用"><a href="#BlockingQueue的使用" class="headerlink" title="BlockingQueue的使用"></a>BlockingQueue的使用</h4><p>在处理多线程生产者消费者问题时的演示代码：</p>
<p>main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line"> </div><div class="line">public class BlockingQueueTest &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1000);</div><div class="line">        Thread p1 = new Thread(new Producer(queue),&quot;producer1&quot;);</div><div class="line">        Thread p2 = new Thread(new Producer(queue),&quot;producer2&quot;);</div><div class="line">        Thread c1 = new Thread(new Consumer(queue),&quot;consumer1&quot;);</div><div class="line">        Thread c2 = new Thread(new Consumer(queue),&quot;consumer2&quot;);</div><div class="line"> </div><div class="line">        p1.start();</div><div class="line">        p2.start();</div><div class="line">        c1.start();</div><div class="line">        c2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Producer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Producer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                queue.put(Thread.currentThread().getName()+&quot; product &quot;+i);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                System.err.println(Thread.currentThread().getName() + &quot; error&quot;);</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Consumer implements Runnable&#123;</div><div class="line">    private BlockingQueue&lt;String&gt; queue;</div><div class="line"> </div><div class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run() &#123;</div><div class="line">        int i = 0;</div><div class="line">        while (!Thread.currentThread().isInterrupted())</div><div class="line">        &#123;</div><div class="line">            try &#123;</div><div class="line">                String str = queue.take();</div><div class="line">                System.out.println(str);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BlockingQueue在并发编程中扮演着重要的角色，既可以自己用来解决生产者消费者问题，也用于java自带线程池的缓冲队列。</p>
<p>参考：</p>
<p><a href="http://wsmajunfeng.iteye.com/blog/1629354" target="_blank" rel="external">BlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashSet]]></title>
      <url>http://zsr.github.io/2016/08/16/HashSet/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashSet"><a href="#OpenJDK-源代码阅读之-HashSet" class="headerlink" title="OpenJDK 源代码阅读之 HashSet"></a>OpenJDK 源代码阅读之 HashSet</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractSet&lt;E&gt;</div><div class="line">            java.util.HashSet&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;</div><div class="line">extends AbstractSet&lt;E&gt;</div><div class="line">implements Set&lt;E&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<ol>
<li>不保证元素次序，甚至不保证次序不随时间变化</li>
<li>基本操作(add, remove, contains, size)常量时间</li>
<li>迭代操作与当前元素个数加底层容量大小成正比</li>
<li>不保证同步</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>总体实现</li>
</ul>
<p>底层是用 <code>HashMap</code> 实现的，<code>Set</code> 中的数据是 <code>HashMap</code> 的 <code>key</code>，所有的 <code>key</code> 指向同一个 <code>value</code>, 此 <code>value</code> 定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>再看一下 <code>add</code>，大概就能明白了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds the specified element to this set if it is not already present.</div><div class="line"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</div><div class="line"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</div><div class="line"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</div><div class="line"> * If this set already contains the element, the call leaves the set</div><div class="line"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be added to this set</div><div class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</div><div class="line"> * element</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>load factor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化中，注意使用的 <code>HashMap</code> 的 load factor 设置为 0.75，如果太小，就设置成 16. </p>
<p><code>HashSet</code> 并没有什么特别之处，几乎没有自己特有的实现，都是调用 <code>HashMap</code> 的方法实现相应的功能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC ApplicationContext]]></title>
      <url>http://zsr.github.io/2016/08/16/ApplicationContext/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以只有1个Servlet的简单情况为例，一般涉及到3个配置文件：web.xml，applicationContext.xml，xxx-servlet.xml。</p>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;  </div><div class="line">         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </div><div class="line">         &lt;param-value&gt;classpath:/applicationContext.xml&lt;/param-value&gt;  </div><div class="line">&lt;/context-param&gt;  </div><div class="line">&lt;listener&gt;  </div><div class="line">         &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </div><div class="line">&lt;/listener&gt;  </div><div class="line">&lt;servlet&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </div><div class="line">         &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </div><div class="line">&lt;/servlet&gt;  </div><div class="line">&lt;servlet-mapping&gt;  </div><div class="line">         &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;  </div><div class="line">         &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;  </div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，系统会生成2个ApplicationContext，确切的说是2个WebApplicationContext.</p>
<h3 id="ROOT-ApplicationContext"><a href="#ROOT-ApplicationContext" class="headerlink" title="ROOT ApplicationContext"></a>ROOT ApplicationContext</h3><p>在Tomcat启动时，通过注册的监听器ContextLoaderListener，Spring初始化WebApplicationContext并保存到ServletContext中，初始化使用的配置文件位置由contextConfigLocation参数确定。该Context为整个框架中的ROOT Context，其他的Context都会作为其子节点或子孙节点进行关联。</p>
<p>WebApplicationContext和ServletContext互相保存对方的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存到ServletContext中  </div><div class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,this.context);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//保存ServletContext  </div><div class="line">wac.setServletContext(sc);</div></pre></td></tr></table></figure>
<h3 id="xxx-ApplicationContext"><a href="#xxx-ApplicationContext" class="headerlink" title="xxx ApplicationContext"></a>xxx ApplicationContext</h3><p>Tomcat生成xxx Servlet时，DispatcherServlet会使用xxx-servlet.xml（除非显示指定其他文件）初始化WebApplicationContext，将其父节点设为ROOT Context，并保存到ServletContext中。</p>
<p>在createWebApplicationContext()方法中，设置父节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wac.setParent(parent);</div></pre></td></tr></table></figure>
<p>在configureAndRefreshWebApplicationContext()方法中保存ServletContext：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wac.setServletContext(getServletContext());  </div><div class="line">wac.setServletConfig(getServletConfig());</div></pre></td></tr></table></figure>
<p>在initWebApplicationContext()方法中将自己保存到ServletContext中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Publish the context as a servlet context attribute.  </div><div class="line">String attrName = getServletContextAttributeName();  </div><div class="line">getServletContext().setAttribute(attrName, wac);</div></pre></td></tr></table></figure>
<p>ServletContext、ROOT Context和xxx Context三者引用之间的关系如下：</p>
<p><img src="/images/Application关系.jpg"></p>
<p>获取的方法：</p>
<ul>
<li>ServletContext：</li>
</ul>
<p>无论是在ROOT还是xxx Context中，可以通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContext. getServletContext();</div></pre></td></tr></table></figure>
<ul>
<li>ROOT Context：</li>
</ul>
<p>该Context是” org.springframework.web.context. WebApplicationContext. ROOT”为Key保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc)</div></pre></td></tr></table></figure>
<p>在xxx Context中可以通过getParent得到ROOT Context。</p>
<ul>
<li>xxx Context：</li>
</ul>
<p>该Context是以” org.springframework.web.servlet.FrameworkServlet.CONTEXT.xxx”为KEY(xxx为web.xml中定义的Servlet名称)，保存在ServletContext中。可以使用Spring提供的工具类方法获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContextsc, String attrName)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 持久化]]></title>
      <url>http://zsr.github.io/2016/08/16/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：</p>
<ul>
<li><p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</p>
</li>
<li><p>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</p>
</li>
<li><p>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</p>
</li>
<li><p>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p>
</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><p>Redis调用fork()，产生一个子进程。</p>
</li>
<li><p>子进程把数据写到一个临时的RDB文件。</p>
</li>
<li><p>当子进程写完新的RDB文件后，把旧的RDB文件替换掉。</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。</p>
</li>
<li><p>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上。</p>
</li>
<li><p>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。</p>
</li>
<li><p>比起AOF，在数据量比较大的情况下，RDB的启动速度更快。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。</p>
</li>
<li><p>RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。</p>
</li>
</ul>
<h4 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><p>默认Redis会把快照文件存储为当前目录下一个名为dump.rdb的文件。要修改文件的存储路径和名称，可以通过修改配置文件redis.conf实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RDB文件名，默认为dump.rdb。</div><div class="line">dbfilename dump.rdb</div><div class="line"></div><div class="line">文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</div><div class="line">dir ./</div></pre></td></tr></table></figure>
<h4 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h4><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save 60 1000</div></pre></td></tr></table></figure>
<p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式为：save &lt;seconds&gt; &lt;changes&gt;</div><div class="line"># 可以设置多个。</div><div class="line">save 900 1 #900秒后至少1个key有变动</div><div class="line">save 300 10 #300秒后至少10个key有变动</div><div class="line">save 60 10000 #60秒后至少10000个key有变动</div></pre></td></tr></table></figure>
<p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop-writes-on-bgsave-error yes</div></pre></td></tr></table></figure>
<h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>默认Redis会采用LZF对数据进行压缩。如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbcompression yes</div></pre></td></tr></table></figure>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>从版本5的RDB的开始，一个CRC64的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用0替代，加载的时候看到0就会直接跳过校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdbchecksum yes</div></pre></td></tr></table></figure>
<h4 id="手动生成快照"><a href="#手动生成快照" class="headerlink" title="手动生成快照"></a>手动生成快照</h4><p>Redis提供了两个命令用于手动生成快照:SAVE, BGSAVE。</p>
<h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。因此不建议在生产环境使用这个命令，除非因为某种原因需要去阻止Redis使用子进程进行后台生成快照（例如调用fork(2)出错）。</p>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，会立刻返回OK返回码。Redis会产生一个子进程进行处理并立刻恢复对客户端的服务。在客户端我们可以使用LASTSAVE命令查看操作是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; BGSAVE</div><div class="line">Background saving started</div><div class="line">127.0.0.1:6379&gt; LASTSAVE</div><div class="line">(integer) 1433936394</div></pre></td></tr></table></figure>
<p><strong>注意：配置文件里禁用了快照生成功能不影响SAVE和BGSAVE命令的效果。</strong></p>
<a id="more"></a>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。<strong>默认是每秒fsync一次。</strong>这意味着你最多丢失一秒钟的数据。</p>
</li>
<li><p>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复。</p>
</li>
<li><p>当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上。</p>
</li>
<li><p>AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用FLUSHALL命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来。</p>
</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>在相同的数据集下，AOF文件的大小一般会比RDB文件大。</p>
</li>
<li><p>在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。</p>
</li>
<li><p>在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题。</p>
</li>
</ul>
<h4 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h4><p>把配置项appendonly设为yes：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<h4 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">文件存放目录，与RDB共用。默认为当前工作目录。</div><div class="line">dir ./</div><div class="line"></div><div class="line">默认文件名为appendonly.aof</div><div class="line">appendfilename &quot;appendonly.aof&quot;</div></pre></td></tr></table></figure>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>你可以配置Redis调用fsync的频率，有三个选项：</p>
<ul>
<li><p>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全。</p>
</li>
<li><p>每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。</p>
</li>
<li><p>从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。</p>
</li>
</ul>
<p><strong>推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。</strong>相关配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># appendfsync always</div><div class="line">appendfsync everysec</div><div class="line"># appendfsync no</div></pre></td></tr></table></figure>
<h4 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h4><p>随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件。</p>
<p>工作原理如下：</p>
<ul>
<li><p>Redis调用fork()，产生一个子进程。</p>
</li>
<li><p>子进程把新的AOF写到一个临时文件里。</p>
</li>
<li><p>主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全。</p>
</li>
<li><p>当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里。</p>
</li>
</ul>
<p>我们可以通过配置设置日志重写的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</div><div class="line">如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</div><div class="line">同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</div><div class="line"></div><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure>
<p>要禁用自动的日志重写功能，我们可以把百分比设置为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 0</div></pre></td></tr></table></figure>
<p><strong>注意：Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令。</strong></p>
<h4 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h4><p>如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复：</p>
<ul>
<li><p>备份AOF文件。</p>
</li>
<li><p>使用redis-check-aof命令修复原始的AOF文件：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-check-aof --fix</div></pre></td></tr></table></figure>
<ul>
<li><p>可以使用diff -u命令看下两个文件的差异。</p>
</li>
<li><p>使用修复过的文件重启Redis服务。</p>
</li>
</ul>
<h4 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h4><p>这里只说Redis &gt;= 2.2版本的方式：</p>
<ul>
<li><p>备份一个最新的dump.rdb的文件，并把备份文件放在一个安全的地方。</p>
</li>
<li><p>运行以下两条命令：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli config set appendonly yes</div><div class="line">$ redis-cli config set save &quot;&quot;</div></pre></td></tr></table></figure>
<ul>
<li><p>确保数据跟切换前一致。</p>
</li>
<li><p>确保数据正确的写到AOF文件里。</p>
</li>
</ul>
<p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong><br><strong>记得对配置文件redis.conf进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>建议的备份方法：</p>
<ul>
<li><p>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</p>
</li>
<li><p>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</p>
</li>
<li><p>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://redis.io/topics/persistence" target="_blank" rel="external">redis</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC controller与请求映射]]></title>
      <url>http://zsr.github.io/2016/08/15/SpringMVC-controller%E4%B8%8E%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[DispatchServlet 初始化]]></title>
      <url>http://zsr.github.io/2016/08/15/DispatchServlet-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul>
<li>Servlet:</li>
</ul>
<p>所有的Servlet都是实现了Servlet接口，该接口提供了servlet生命周期的一些方法，如: init(), destroy(),service()&lt;每次接收到请求都由该方法来处理&gt;等，没有具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException;</div></pre></td></tr></table></figure>
<ul>
<li>GenericServlet:<br>该类实现了Servlet的init()方法以及提供了获取初始化参数的方法。init方法的实现最后需要由子类实现</li>
</ul>
<p>获取初始化参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ServletConfig sc = getServletConfig();</div><div class="line">        if (sc == null) &#123;</div><div class="line">            throw new IllegalStateException(</div><div class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return sc.getInitParameter(name);</div></pre></td></tr></table></figure>
<p>init()初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">this.config = config;</div><div class="line">this.init();//调用下面的init()方法（没有具体实现）</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void init() throws ServletException &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>HttpServlet<br>实现了servlet的service()方法，所有的请求都由该方法来处理，判断走doGet()还是doPost()等等。<br>该方法是有Tomcat容器来调用的(init()方法也是)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req, ServletResponse res)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        HttpServletRequest  request;</div><div class="line">        HttpServletResponse response;</div><div class="line">        </div><div class="line">        if (!(req instanceof HttpServletRequest &amp;&amp;</div><div class="line">                res instanceof HttpServletResponse)) &#123;</div><div class="line">            throw new ServletException(&quot;non-HTTP request or response&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        request = (HttpServletRequest) req;</div><div class="line">        response = (HttpServletResponse) res;</div><div class="line"></div><div class="line">        service(request, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">    &#123;</div><div class="line">        String method = req.getMethod();</div><div class="line"></div><div class="line">        if (method.equals(METHOD_GET)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            if (lastModified == -1) &#123;</div><div class="line">                // servlet doesn&apos;t support if-modified-since, no reason</div><div class="line">                // to go through further expensive logic</div><div class="line">                doGet(req, resp);</div><div class="line">            &#125; else &#123;</div><div class="line">                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</div><div class="line">                if (ifModifiedSince &lt; lastModified) &#123;</div><div class="line">                    // If the servlet mod time is later, call doGet()</div><div class="line">                    // Round down to the nearest second for a proper compare</div><div class="line">                    // A ifModifiedSince of -1 will always be less</div><div class="line">                    maybeSetLastModified(resp, lastModified);</div><div class="line">                    doGet(req, resp);</div><div class="line">                &#125; else &#123;</div><div class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_HEAD)) &#123;</div><div class="line">            long lastModified = getLastModified(req);</div><div class="line">            maybeSetLastModified(resp, lastModified);</div><div class="line">            doHead(req, resp);</div><div class="line"></div><div class="line">        &#125; else if (method.equals(METHOD_POST)) &#123;</div><div class="line">            doPost(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_PUT)) &#123;</div><div class="line">            doPut(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_DELETE)) &#123;</div><div class="line">            doDelete(req, resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</div><div class="line">            doOptions(req,resp);</div><div class="line">            </div><div class="line">        &#125; else if (method.equals(METHOD_TRACE)) &#123;</div><div class="line">            doTrace(req,resp);</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            //</div><div class="line">            // Note that this means NO servlet supports whatever</div><div class="line">            // method was requested, anywhere on this server.</div><div class="line">            //</div><div class="line"></div><div class="line">            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class="line">            Object[] errArgs = new Object[1];</div><div class="line">            errArgs[0] = method;</div><div class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</div><div class="line">            </div><div class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>以上几个类都是不需要Spring框架的参与。</p>
<a id="more"></a>
<ul>
<li>HttpServletBean</li>
</ul>
<p>该类最终重载实现了GenericServlet类的init()方法。注意: 方法是final类型，不可以被继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public final void init() throws ServletException &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Set bean properties from init parameters.</div><div class="line">		try &#123;</div><div class="line">			PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</div><div class="line">			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class="line">			ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</div><div class="line">			bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">			initBeanWrapper(bw);</div><div class="line">			bw.setPropertyValues(pvs, true);</div><div class="line">		&#125;</div><div class="line">		catch (BeansException ex) &#123;</div><div class="line">			logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Let subclasses do whatever initialization they like.</div><div class="line">		initServletBean();</div><div class="line"></div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的类需要调用initServletBean()方法，该方法在HttpServletBean类中没有具体实现，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void initServletBean() throws ServletException &#123;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FrameworkServlet<br>实现了HttpServletBean类的initServletBean()方法，初始化WebApplicationContext。并且重载了HttpServlet类的service()方法，以及所有的doGet(),doPost()方法, 这些方法最后都调用了doService()方法(该类没有实现doService(),由DispatchServlet类具体实现)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	protected final void initServletBean() throws ServletException &#123;</div><div class="line">		getServletContext().log(&quot;Initializing Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);</div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization started&quot;);</div><div class="line">		&#125;</div><div class="line">		long startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">		    //初始化WebApplicationContext</div><div class="line">			this.webApplicationContext = initWebApplicationContext();</div><div class="line">			initFrameworkServlet();</div><div class="line">		&#125;</div><div class="line">		catch (ServletException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line">		catch (RuntimeException ex) &#123;</div><div class="line">			this.logger.error(&quot;Context initialization failed&quot;, ex);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.logger.isInfoEnabled()) &#123;</div><div class="line">			long elapsedTime = System.currentTimeMillis() - startTime;</div><div class="line">			this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization completed in &quot; +</div><div class="line">					elapsedTime + &quot; ms&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class="line">		WebApplicationContext rootContext =</div><div class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">		WebApplicationContext wac = null;</div><div class="line"></div><div class="line">		if (this.webApplicationContext != null) &#123;</div><div class="line">			// A context instance was injected at construction time -&gt; use it</div><div class="line">			wac = this.webApplicationContext;</div><div class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">				if (!cwac.isActive()) &#123;</div><div class="line">					// The context has not yet been refreshed -&gt; provide services such as</div><div class="line">					// setting the parent context, setting the application context id, etc</div><div class="line">					if (cwac.getParent() == null) &#123;</div><div class="line">						// The context instance was injected without an explicit parent -&gt; set</div><div class="line">						// the root application context (if any; may be null) as the parent</div><div class="line">						cwac.setParent(rootContext);</div><div class="line">					&#125;</div><div class="line">					configureAndRefreshWebApplicationContext(cwac);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance was injected at construction time -&gt; see if one</div><div class="line">			// has been registered in the servlet context. If one exists, it is assumed</div><div class="line">			// that the parent context (if any) has already been set and that the</div><div class="line">			// user has performed any initialization such as setting the context id</div><div class="line">			wac = findWebApplicationContext();</div><div class="line">		&#125;</div><div class="line">		if (wac == null) &#123;</div><div class="line">			// No context instance is defined for this servlet -&gt; create a local one</div><div class="line">			wac = createWebApplicationContext(rootContext);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!this.refreshEventReceived) &#123;</div><div class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</div><div class="line">			// support or the context injected at construction time had already been</div><div class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</div><div class="line">			onRefresh(wac);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (this.publishContext) &#123;</div><div class="line">			// Publish the context as a servlet context attribute.</div><div class="line">			String attrName = getServletContextAttributeName();</div><div class="line">			getServletContext().setAttribute(attrName, wac);</div><div class="line">			if (this.logger.isDebugEnabled()) &#123;</div><div class="line">				this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() +</div><div class="line">						&quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return wac;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面的方法初始化一个WebApplicationContext.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		// For subclasses: do nothing by default.</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>DispatcherServlet</li>
</ul>
<p>实现FrameworkServlet类的onRefresh()方法，在该方法中具体初始化Spring MVC需要的一些策略对象。如HandlerMappings，HandlerAdapters等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * This implementation calls &#123;@link #initStrategies&#125;.</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">		initStrategies(context);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * Initialize the strategy objects that this servlet uses.</div><div class="line">	 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</div><div class="line">	 */</div><div class="line">	protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">		initMultipartResolver(context);</div><div class="line">		initLocaleResolver(context);</div><div class="line">		initThemeResolver(context);</div><div class="line">		initHandlerMappings(context);</div><div class="line">		initHandlerAdapters(context);</div><div class="line">		initHandlerExceptionResolvers(context);</div><div class="line">		initRequestToViewNameTranslator(context);</div><div class="line">		initViewResolvers(context);</div><div class="line">		initFlashMapManager(context);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，DispatchServlet对象的初始化完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[servlet 生命周期]]></title>
      <url>http://zsr.github.io/2016/08/15/servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="Servlet生命周期与工作原理"><a href="#Servlet生命周期与工作原理" class="headerlink" title="Servlet生命周期与工作原理"></a>Servlet生命周期与工作原理</h1><p><strong>Servlet生命周期分为三个阶段：</strong></p>
<p>　　1. 初始化阶段  : 调用init()方法</p>
<p>　　2. 响应客户请求阶段　:　调用service()方法</p>
<p>　　3. 终止阶段　:　调用destroy()方法
　　</p>
<h3 id="Servlet初始化阶段："><a href="#Servlet初始化阶段：" class="headerlink" title="Servlet初始化阶段："></a>Servlet初始化阶段：</h3><p>在下列时刻Servlet容器装载Servlet:</p>
<ul>
<li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<servlet></servlet>之间添加如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在Servlet容器启动后，客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后，重新装载Servlet</li>
</ul>
<p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p>
<h3 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h3><p>   首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p>
<p>   每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p>
<p>　　Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void service(ServletRequest req,ServletResponse res) </div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">      HttpRequest request;</div><div class="line">      HttpResponse response;</div><div class="line"> </div><div class="line">     try</div><div class="line">     &#123;</div><div class="line">         req = (HttpRequest)request;</div><div class="line">         res = (HttpResponse)response;</div><div class="line">      &#125;catch(ClassCastException e)</div><div class="line">      &#123;</div><div class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </div><div class="line">      &#125;</div><div class="line">      service(request,response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</div><div class="line">  throws ServletException,IOException</div><div class="line">&#123;</div><div class="line">   String protocol = req.getProtocol();</div><div class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</div><div class="line">   if(protocol.equals(&quot;1.1&quot;))</div><div class="line">   &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</div><div class="line">    &#125;</div><div class="line">   esle</div><div class="line">    &#123;</div><div class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以需要我们在自定义的Servlet中override这些方法！</p>
<h3 id="Servlet响应请求阶段："><a href="#Servlet响应请求阶段：" class="headerlink" title="Servlet响应请求阶段："></a>Servlet响应请求阶段：</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p>
<p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</div></pre></td></tr></table></figure>
<p>这是一个String–&gt;String[]的键值映射。<br>HashMap线程不安全的，Hashtable线程安全。</p>
<h3 id="Servlet终止阶段："><a href="#Servlet终止阶段：" class="headerlink" title="Servlet终止阶段："></a>Servlet终止阶段：</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p>
<h3 id="Servlet何时被创建："><a href="#Servlet何时被创建：" class="headerlink" title="Servlet何时被创建："></a>Servlet何时被创建：</h3><ul>
<li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p>
</li>
<li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p>
</li>
</ul>
<p><strong>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 参数解析原理]]></title>
      <url>http://zsr.github.io/2016/08/15/Spring-MVC-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq exchange模式]]></title>
      <url>http://zsr.github.io/2016/08/12/rabbitmq-exchange%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="rabbitmq-exchange"><a href="#rabbitmq-exchange" class="headerlink" title="rabbitmq exchange"></a>rabbitmq exchange</h1><p><strong>主要介绍rabbitmq常用的三种exchange模式：direct, fanout, topic.</strong></p>
<h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念,<strong>默认的virtual host为 “/“.</strong></p>
<h3 id="Default-exchange-默认交换机"><a href="#Default-exchange-默认交换机" class="headerlink" title="Default exchange (默认交换机)"></a>Default exchange (默认交换机)</h3><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，<strong>绑定的路由键（routing key）名称与队列名称相同。</strong></p>
<h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p><img src="/images/rabbitmq-exchange-1.png"></p>
<p><strong>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</strong></p>
<ul>
<li><p>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p>
</li>
<li><p>这种模式下不需要将Exchange进行任何绑定(binding)操作</p>
</li>
<li><p>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p>
</li>
<li><p>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//需要绑定路由键  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p><img src="/images/rabbitmq-exchange-2.png"></p>
<p><strong>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</strong></p>
<ul>
<li><p>可以理解为路由表的模式</p>
</li>
<li><p>这种模式不需要RouteKey</p>
</li>
<li><p>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</p>
</li>
<li><p>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;fanout&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey&quot;);  </div><div class="line">  </div><div class="line">channel.queueDeclare(&quot;queueName1&quot;);  </div><div class="line">channel.queueBind(&quot;queueName1&quot;, &quot;exchangeName&quot;, &quot;routingKey1&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">//路由键需要设置为空  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>
<h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p><img src="/images/rabbitmq-exchange-3.png"></p>
<p><strong>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上.</strong></p>
<ul>
<li><p>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。</p>
</li>
<li><p>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</p>
</li>
<li><p>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</p>
</li>
<li><p>“#”表示0个或若干个关键字，“<em>”表示一个关键字。如“log.</em>”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。</p>
</li>
<li><p>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Channel channel = connection.createChannel();  </div><div class="line">channel.exchangeDeclare(&quot;exchangeName&quot;, &quot;topic&quot;); //direct fanout topic  </div><div class="line">channel.queueDeclare(&quot;queueName&quot;);  </div><div class="line">channel.queueBind(&quot;queueName&quot;, &quot;exchangeName&quot;, &quot;routingKey.*&quot;);  </div><div class="line">  </div><div class="line">byte[] messageBodyBytes = &quot;hello world&quot;.getBytes();  </div><div class="line">channel.basicPublish(&quot;exchangeName&quot;, &quot;routingKey.one&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC 参数校验]]></title>
      <url>http://zsr.github.io/2016/08/11/SpringMVC-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>需要对Post请求的表单数据进行简单校验。</p>
<h3 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h3><ul>
<li>Bean Validation API 1.1: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Hibernate Validator 5.0.1.Final: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.0.1.Final&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在application-context.xml文件中加入下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;mvc:annotation-driven /&gt;</div></pre></td></tr></table></figure>
<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><ol>
<li>在需要校验的model对象前面加上@Valid注解(javax.validation.Valid):</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(</div><div class="line">      value = &quot;/v1/live/send/gift&quot;, method = RequestMethod.POST)</div><div class="line">  @Response</div><div class="line">public WebResult requestSendGift(HttpServletRequest request, @Valid @ModelAttribute SendGiftForm sendGiftForm, BindingResult bindingResult) &#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>在controller方法里面加上参数判断：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (bindingResult.hasErrors()) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;request params must be not null.&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Validator-Model"><a href="#Validator-Model" class="headerlink" title="Validator Model"></a>Validator Model</h5><p>在需要校验的model字段前面加上注解(hibernate validator):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SendGiftForm &#123;</div><div class="line">  @NotNull</div><div class="line">  private Long roomId; </div><div class="line">  @NotNull</div><div class="line">  private Long liveId; </div><div class="line">  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://www.codejava.net/frameworks/spring/spring-mvc-form-validation-example-with-bean-validation-api" target="_blank" rel="external">Spring Form Validation</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq延时队列]]></title>
      <url>http://zsr.github.io/2016/08/10/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>rabbitmq 是目前使用最为普及的消息队列组件，基于 AMQP 的 rabbitmq 在各方面设计都比较完善，同时，它具有非常丰富的功能与特性，可以支持各种实际的适用场景。</p>
<p>但是<strong>rabbitmq并不直接支持延时队列</strong>的功能，本文我们就来介绍一下，如何使用 rabbitmq 实现一个延时队列。</p>
<h1 id="延时队列的简易实现"><a href="#延时队列的简易实现" class="headerlink" title="延时队列的简易实现"></a>延时队列的简易实现</h1><p>使用redis集群来实现了这个功能，redis中存储了下单时间，以分钟为粒度扫描相应的key，即可扫出所有下单时间超过指定时间间隔的数据.</p>
<h1 id="rabbitmq-与消息过期时间-–-TTL"><a href="#rabbitmq-与消息过期时间-–-TTL" class="headerlink" title="rabbitmq 与消息过期时间 – TTL"></a>rabbitmq 与消息过期时间 – TTL</h1><h3 id="为队列设置消息过期时间"><a href="#为队列设置消息过期时间" class="headerlink" title="为队列设置消息过期时间"></a>为队列设置消息过期时间</h3><p>rabbitmq 支持在创建队列时对队列设置消息过期时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-message-ttl&quot;, 60000);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<h1 id="失效消息转发队列-–-DLX"><a href="#失效消息转发队列-–-DLX" class="headerlink" title="失效消息转发队列 – DLX"></a>失效消息转发队列 – DLX</h1><p>一旦上述消息过期时间设置生效，某条消息达到消息过期时间，那么他将会成为一条“dead-lettered”，此外，被拒绝的消息如果requeue属性为 false，或者消息所在队列已达到最大长度，那么他也将成为“dead-lettered”.</p>
<p>如果设置了DLX规则，即失效消息转发规则，那么失效的消息就会被转发到相应的exchange和queue.</p>
<h3 id="通过代码设置失效消息转发队列"><a href="#通过代码设置失效消息转发队列" class="headerlink" title="通过代码设置失效消息转发队列"></a>通过代码设置失效消息转发队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">channel.exchangeDeclare(&quot;some.exchange.name&quot;, &quot;direct&quot;);</div><div class="line"></div><div class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</div><div class="line">args.put(&quot;x-dead-letter-exchange&quot;, &quot;some.exchange.name&quot;);</div><div class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</div></pre></td></tr></table></figure>
<p>这样，一旦消息失效，则消息会被自动转发到你设置的x-dead-letter-exchange上的同名队列.</p>
<p>也可以通过下面的代码指定具体转发的目标 routing-key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;some-routing-key&quot;);</div></pre></td></tr></table></figure>
<h3 id="spring-rabbit-配置"><a href="#spring-rabbit-配置" class="headerlink" title="spring-rabbit 配置"></a>spring-rabbit 配置</h3><p>可以使用spring-rabbit配置替代代码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:queue name=&quot;q.with.dlx&quot;&gt;</div><div class="line">    &lt;rabbit:queue-arguments&gt; </div><div class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</div><div class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Long&quot;/&gt;</div><div class="line">    &lt;/rabbit:queue-arguments&gt;</div><div class="line">&lt;/rabbit:queue&gt;</div><div class="line"></div><div class="line">&lt;rabbit:queue name=&quot;dlq&quot;/&gt;</div><div class="line"></div><div class="line">&lt;rabbit:direct-exchange name=&quot;dlx&quot;&gt;</div><div class="line">    &lt;rabbit:bindings&gt;</div><div class="line">        &lt;rabbit:binding key=&quot;q.with.dlx&quot; queue=&quot;dlq&quot;/&gt;</div><div class="line">    &lt;/rabbit:bindings&gt;</div><div class="line">&lt;/rabbit:direct-exchange&gt;</div></pre></td></tr></table></figure>
<p>This assumes you routed the original message using the default direct exchange (routing by queue name). Hence the dead letter routing uses the same routing key (queue name). If you route using an explicit routing key, you would use that.</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.rabbitmq.com/ttl.html" target="_blank" rel="external">RabbitMQ TTL</a></p>
<p><a href="http://www.rabbitmq.com/dlx.html" target="_blank" rel="external">RabbitMQ DLX</a></p>
<p><a href="http://docs.spring.io/spring-amqp/docs/1.3.9.RELEASE/reference/html/amqp.html" target="_blank" rel="external">Spring AMQP</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型]]></title>
      <url>http://zsr.github.io/2016/08/08/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="深入理解Java内存模型（一）"><a href="#深入理解Java内存模型（一）" class="headerlink" title="深入理解Java内存模型（一）"></a>深入理解Java内存模型（一）</h1><p>原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-memory-model-1</a></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><strong>Java的并发采用的是共享内存模型</strong>，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</strong>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="/images/java虚拟机1-1.png"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<p><img src="/images/java虚拟机1-2.png"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<a id="more"></a> 
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="/images/java虚拟机1-3.png"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Processor A</div><div class="line"></div><div class="line">a = 1; //A1</div><div class="line">x = b; //A2</div><div class="line"></div><div class="line">Processor B</div><div class="line"></div><div class="line">b = 2; //B1</div><div class="line">y = a; //B2</div><div class="line"></div><div class="line">初始状态：a = b = 0</div><div class="line">处理器允许执行后得到结果：x = y = 0</div></pre></td></tr></table></figure>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p>
<p><img src="/images/Java虚拟机1-4.png"></p>
<p>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p>
<p><strong>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">屏障类型</th>
<th style="text-align:center">指令示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LoadLoad Barriers</td>
<td style="text-align:center">Load1; LoadLoad; Load2</td>
<td style="text-align:center">确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:center">StoreStore Barriers</td>
<td style="text-align:center">Store1; StoreStore; Store2</td>
<td style="text-align:center">确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:center">LoadStore Barriers</td>
<td style="text-align:center">Load1; LoadStore; Store2</td>
<td style="text-align:center">确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:center">StoreLoad Barriers</td>
<td style="text-align:center">Store1; StoreLoad; Load2</td>
<td style="text-align:center">确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。<strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before规则如下：</p>
<ul>
<li><p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>
</li>
<li><p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>
</li>
<li><p>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</p>
</li>
<li><p>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
</li>
</ul>
<p><strong>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</strong></p>
<p>happens-before与JMM的关系如下图所示：</p>
<p><img src="/images/Java虚拟机1-5.png"></p>
<p>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ClassLoader]]></title>
      <url>http://zsr.github.io/2016/08/05/ClassLoader/</url>
      <content type="html"><![CDATA[<h1 id="Java-类加载器"><a href="#Java-类加载器" class="headerlink" title="Java 类加载器"></a>Java 类加载器</h1><hr>
<h3 id="类加载器基本概念"><a href="#类加载器基本概念" class="headerlink" title="类加载器基本概念"></a>类加载器基本概念</h3><p><strong>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</strong></p>
<h3 id="java-lang-ClassLoader类介绍"><a href="#java-lang-ClassLoader类介绍" class="headerlink" title="java.lang.ClassLoader类介绍"></a>java.lang.ClassLoader类介绍</h3><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。为了完成加载类的这个职责，ClassLoader提供了一系列的方法，比较重要的方法如表 1所示。</p>
<h5 id="表-1-ClassLoader-中与加载类相关的方法"><a href="#表-1-ClassLoader-中与加载类相关的方法" class="headerlink" title="表 1. ClassLoader 中与加载类相关的方法"></a>表 1. ClassLoader 中与加载类相关的方法</h5><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getParent()</td>
<td style="text-align:center">返回该类加载器的父类加载器</td>
</tr>
<tr>
<td style="text-align:center">loadClass(String name)</td>
<td style="text-align:center">加载名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findClass(String name)</td>
<td style="text-align:center">查找名称为 name的类，返回的结果是 java.lang.Class类的实例</td>
</tr>
<tr>
<td style="text-align:center">findLoadedClass(String name)</td>
<td style="text-align:center">查找名称为 name的已经被加载过的类，返回的结果是java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:center">defineClass(String name, byte[] b, int off, int len)</td>
<td style="text-align:center">把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的</td>
</tr>
<tr>
<td style="text-align:center">resolveClass(Class&lt;?&gt; c)</td>
<td style="text-align:center">链接指定的 Java 类</td>
</tr>
</tbody>
</table>
<p>类加载器的树状组织结构<br>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li><p>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</p>
</li>
<li><p>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p>
</li>
<li><p>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
</li>
</ul>
<p>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求(如tomcat)。<br>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。图 1中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。</p>
<a id="more"></a>
<h5 id="图-1-类加载器树状组织结构示意图"><a href="#图-1-类加载器树状组织结构示意图" class="headerlink" title="图 1. 类加载器树状组织结构示意图"></a>图 1. 类加载器树状组织结构示意图</h5><p><img src="/images/ClassLoader_1.jpg"></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTree &#123; </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        ClassLoader loader = ClassLoaderTree.class.getClassLoader(); </div><div class="line">        while (loader != null) &#123; </div><div class="line">            System.out.println(loader.toString()); </div><div class="line">            loader = loader.getParent(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@9304b1</div><div class="line"></div><div class="line">sun.misc.Launcher$ExtClassLoader@190d11</div></pre></td></tr></table></figure>
<p>第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是 sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。需要注意的是这里并没有输出引导类加载器，这是由于有些 JDK 的实现对于父类加载器是引导类加载器的情况，getParent()方法返回 null。</p>
<h3 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h3><p><strong>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.example; </div><div class="line"></div><div class="line"> public class Sample &#123; </div><div class="line">    private Sample instance; </div><div class="line"></div><div class="line">    public void setSample(Object instance) &#123; </div><div class="line">        this.instance = (Sample) instance; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>com.example.Sample类的方法 setSample接受一个 java.lang.Object类型的参数，并且会把该参数强制转换成 com.example.Sample类型。</p>
<p><strong>测试java类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void testClassIdentity() &#123; </div><div class="line">    String classDataRootPath = &quot;C:\\workspace\\Classloader\\classData&quot;; </div><div class="line">    FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); </div><div class="line">    String className = &quot;com.example.Sample&quot;; 	</div><div class="line">    try &#123; </div><div class="line">        Class&lt;?&gt; class1 = fscl1.loadClass(className); </div><div class="line">        Object obj1 = class1.newInstance(); </div><div class="line">        Class&lt;?&gt; class2 = fscl2.loadClass(className); </div><div class="line">        Object obj2 = class2.newInstance(); </div><div class="line">        Method setSampleMethod = class1.getMethod(&quot;setSample&quot;, java.lang.Object.class); </div><div class="line">        setSampleMethod.invoke(obj1, obj2); </div><div class="line">    &#125; catch (Exception e) &#123; </div><div class="line">        e.printStackTrace(); </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>用了类 FileSystemClassLoader的两个不同实例来分别加载类 com.example.Sample，得到了两个不同的 java.lang.Class的实例，接着通过 newInstance()方法分别生成了两个类的对象obj1和obj2，最后通过 Java的反射API在对象obj1上调用方法setSample，试图把对象obj2赋值给obj1内部的instance对象。</p>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">java.lang.reflect.InvocationTargetException </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) </div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) </div><div class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</div><div class="line">at java.lang.reflect.Method.invoke(Method.java:597) </div><div class="line">at classloader.ClassIdentity.testClassIdentity(ClassIdentity.java:26) </div><div class="line">at classloader.ClassIdentity.main(ClassIdentity.java:9) </div><div class="line">Caused by: java.lang.ClassCastException: com.example.Sample </div><div class="line">cannot be cast to com.example.Sample </div><div class="line">at com.example.Sample.setSample(Sample.java:7) </div><div class="line">... 6 more</div></pre></td></tr></table></figure>
<p>从运行结果可以看到，运行时抛出了 java.lang.ClassCastException异常。虽然两个对象 obj1和 obj2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。</p>
<p>了解了这一点之后，就可以理解代理模式的设计动机了。代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。<br>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>
<p>下面具体介绍类加载器加载类的详细过程。</p>
<h3 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h3><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。<br>方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。<br>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</p>
<p>下面讨论另外一种类加载器：线程上下文类加载器。</p>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。<br>前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。<br>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<p>下面介绍另外一种加载类的方法：Class.forName。</p>
<h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h4><p>Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。</p>
<h3 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h3><p>用来加载存储在文件系统上的 Java 字节代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class FileSystemClassLoader extends ClassLoader &#123; </div><div class="line"></div><div class="line">    private String rootDir; </div><div class="line"></div><div class="line">    public FileSystemClassLoader(String rootDir) &#123; </div><div class="line">        this.rootDir = rootDir; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; </div><div class="line">        byte[] classData = getClassData(name); </div><div class="line">        if (classData == null) &#123; </div><div class="line">            throw new ClassNotFoundException(); </div><div class="line">        &#125; </div><div class="line">        else &#123; </div><div class="line">            return defineClass(name, classData, 0, classData.length); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private byte[] getClassData(String className) &#123; </div><div class="line">        String path = classNameToPath(className); </div><div class="line">        try &#123; </div><div class="line">            InputStream ins = new FileInputStream(path); </div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream(); </div><div class="line">            int bufferSize = 4096; </div><div class="line">            byte[] buffer = new byte[bufferSize]; </div><div class="line">            int bytesNumRead = 0; </div><div class="line">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123; </div><div class="line">                baos.write(buffer, 0, bytesNumRead); </div><div class="line">            &#125; </div><div class="line">            return baos.toByteArray(); </div><div class="line">        &#125; catch (IOException e) &#123; </div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">        return null; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    private String classNameToPath(String className) &#123; </div><div class="line">        return rootDir + File.separatorChar </div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>类 FileSystemClassLoader继承自类 java.lang.ClassLoader。在 表 1中列出的 java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</p>
<p>类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。</p>
<h3 id="类加载器与-Web-容器"><a href="#类加载器与-Web-容器" class="headerlink" title="类加载器与 Web 容器"></a>类加载器与 Web 容器</h3><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。<br>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<ul>
<li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li>
<li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li>
<li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[String]]></title>
      <url>http://zsr.github.io/2016/08/03/String/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-String"><a href="#OpenJDK-源代码阅读之-String" class="headerlink" title="OpenJDK 源代码阅读之 String"></a>OpenJDK 源代码阅读之 String</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.lang.String</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">Object</span></div><div class="line"><span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>一旦创建就不可改变</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>storage</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The value is used for character storage. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div></pre></td></tr></table></figure>
<p>可以看出 <code>String</code> 中的数据是如何存储的。</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = original.value;</div><div class="line">    <span class="keyword">this</span>.hash = original.hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出使用 <code>String</code> 类型初始化，新 <code>String</code> 实际上与原来的 <code>String</code> 指向同一块内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 <code>char[]</code> 初始化，可以看出，新分配了内存，并复制，保证了两者相互独立，只是内容相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</div><div class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意用 <code>StringBuffer</code> 初始化时，对同一 <code>buffer</code> 是线程安全的，即初始化 <code>String</code> 的过程中，其它线程不会改变 <code>buffer</code> 的内容。</p>
<p>另外，能告诉我下面这段代码是怎么回事么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>为啥这次不同步了呢？</p>
<ul>
<li>equals </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</div><div class="line">        String anotherString = (String) anObject;</div><div class="line">        <span class="keyword">int</span> n = value.length;</div><div class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</div><div class="line">            <span class="keyword">char</span> v1[] = value;</div><div class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<p>1) 检查类型<br>2) <code>value</code> 直接通过点访问了，<code>value</code> 是 <code>private</code> 的啊，怎么能这样？</p>
<ul>
<li>hashCode </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hash;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">            h = <span class="number">31</span> * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>String</code> 的 <code>hashCode</code> 公式：</p>
<blockquote>
<p>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]</p>
</blockquote>
<ul>
<li>replace</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</div><div class="line">        <span class="keyword">int</span> len = value.length;</div><div class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</div><div class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                buf[j] = val[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">                <span class="keyword">char</span> c = val[i];</div><div class="line">                buf[i] = (c == oldChar) ? newChar : c;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，虽然说是 <code>replace</code>，但是实际上还是新生成了 <code>buf</code> ，然后再生成新的 <code>String</code>，而不是在原来的 <code>value</code> 上修改。如果有大量的替换，还是自己实现比较好诶～</p>
<ul>
<li>indexOf</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Code shared by String and StringBuffer to do searches. The</div><div class="line"> * source is the character array being searched, and the target</div><div class="line"> * is the string being searched for.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>   source       the characters being searched.</div><div class="line"> * <span class="doctag">@param</span>   sourceOffset offset of the source string.</div><div class="line"> * <span class="doctag">@param</span>   sourceCount  count of the source string.</div><div class="line"> * <span class="doctag">@param</span>   target       the characters being searched for.</div><div class="line"> * <span class="doctag">@param</span>   targetOffset offset of the target string.</div><div class="line"> * <span class="doctag">@param</span>   targetCount  count of the target string.</div><div class="line"> * <span class="doctag">@param</span>   fromIndex    the index to begin searching from.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</div><div class="line">        <span class="keyword">int</span> fromIndex) &#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</div><div class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        fromIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> first = target[targetOffset];</div><div class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        <span class="comment">/* Look for first character. */</span></div><div class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</div><div class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></div><div class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</div><div class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</div><div class="line">                    == target[k]; j++, k++);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == end) &#123;</div><div class="line">                <span class="comment">/* Found whole string. */</span></div><div class="line">                <span class="keyword">return</span> i - sourceOffset;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码从 <code>source</code> 中寻找 <code>target</code> 第一次出现的位置，<code>for</code> 循环每次都先让 <code>i</code> 停留在一个位置，此位置上内容与 <code>target</code> 首字符相同，然后开始遍历。可以看出这是一个 <code>O(n^2)</code> 的算法，所以，标准库也不一定是最高效的，要是要高效，还是需要自己实现，或者找其它库的。</p>
<ul>
<li>matches</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正则表达式匹配函数。可以看出，是直接调用了 <code>Pattern</code> 中的相应函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</div><div class="line">    <span class="comment">/* fastpath if the regex is a</span></div><div class="line">     (1)one-char String and this character is not one of the</div><div class="line">        RegEx's meta characters ".$|()[&#123;^?*+\\", or</div><div class="line">     (2)two-char String and the first char is the backslash and</div><div class="line">        the second is not the ascii digit or ascii letter.</div><div class="line">     */</div><div class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</div><div class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</div><div class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</div><div class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</div><div class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</div><div class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</div><div class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</div><div class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</div><div class="line">                list.add(substring(off, next));</div><div class="line">                off = next + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></div><div class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></div><div class="line">                list.add(substring(off, value.length));</div><div class="line">                off = value.length;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// If no match was found, return this</span></div><div class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Add remaining segment</span></div><div class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</div><div class="line">            list.add(substring(off, value.length));</div><div class="line"></div><div class="line">        <span class="comment">// Construct result</span></div><div class="line">        <span class="keyword">int</span> resultSize = list.size();</div><div class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>)</div><div class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>)</div><div class="line">                resultSize--;</div><div class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</div><div class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按 <code>regex</code> 将字符串分割，思路是如果是单个字符，或者转义字符，就手工分割，否则就直接调用 <code>Pattern.comile(regex).split</code> 函数。手工分割时每次都将 <code>[off, next]</code> 之间的内容加入 <code>list</code>，最后将 剩余的 <code>[off, ]</code>  加入。另外注意 <code>limit</code> 对分割次数的限制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Nio]]></title>
      <url>http://zsr.github.io/2016/08/02/Java-Nio/</url>
      <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><hr>
<h3 id="Nio-服务端"><a href="#Nio-服务端" class="headerlink" title="Nio 服务端"></a>Nio 服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.ServerSocketChannel;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 服务端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOServer &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个ServerSocket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param port 绑定的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initServer(int port) throws IOException &#123;</div><div class="line">    // 获得一个ServerSocket通道</div><div class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    serverChannel.configureBlocking(false);</div><div class="line">    // 将该通道对应的ServerSocket绑定到指定端口</div><div class="line">    serverChannel.socket().bind(new InetSocketAddress(port));</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，</div><div class="line">    // 当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。</div><div class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio server listen start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 客户端请求连接事件</div><div class="line">        if (key.isAcceptable()) &#123;</div><div class="line">          ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">          // 获得和客户端连接的通道</div><div class="line">          SocketChannel channel = server.accept();</div><div class="line">          // 设置成非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 在这里可以给客户端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;服务器收到客户端连接请求.&quot;).getBytes()));</div><div class="line"></div><div class="line">          // 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line">          // 获得了可读事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取客户端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line"></div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;服务器端收到客户端信息:&quot; + msg);</div><div class="line">    // 将消息回送给客户端</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;服务器端发送客户端消息: world.&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 服务器端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOServer nioServer = new NIOServer();</div><div class="line">    nioServer.initServer(8000);</div><div class="line">    nioServer.listen();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Nio-客户端"><a href="#Nio-客户端" class="headerlink" title="Nio 客户端"></a>Nio 客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">package com.zsr.test.nio;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.SelectionKey;</div><div class="line">import java.nio.channels.Selector;</div><div class="line">import java.nio.channels.SocketChannel;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * nio 客户端 Created by david.zhang</div><div class="line"> */</div><div class="line">public class NIOClient &#123;</div><div class="line"></div><div class="line">  // 通道管理器</div><div class="line">  private Selector selector;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 获得一个Socket通道，并对该通道做一些初始化的工作</div><div class="line">   * </div><div class="line">   * @param ip 连接的服务器的ip</div><div class="line">   * @param port 连接的服务器的端口号</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void initClient(String ip, int port) throws IOException &#123;</div><div class="line">    // 获得一个Socket通道</div><div class="line">    SocketChannel channel = SocketChannel.open();</div><div class="line">    // 设置通道为非阻塞</div><div class="line">    channel.configureBlocking(false);</div><div class="line">    // 获得一个通道管理器</div><div class="line">    this.selector = Selector.open();</div><div class="line"></div><div class="line">    // 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调</div><div class="line">    // 用channel.finishConnect();才能完成连接</div><div class="line">    channel.connect(new InetSocketAddress(ip, port));</div><div class="line">    // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</div><div class="line">    channel.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">   * </div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void listen() throws IOException &#123;</div><div class="line">    System.out.println(&quot;nio client liesten start.&quot;);</div><div class="line">    // 轮询访问selector</div><div class="line">    while (true) &#123;</div><div class="line">      // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞</div><div class="line">      selector.select();</div><div class="line">      // 获得selector中选中的项的迭代器，选中的项为注册的事件</div><div class="line">      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line">      while (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = it.next();</div><div class="line">        // 删除已选的key,以防重复处理</div><div class="line">        it.remove();</div><div class="line">        // 连接事件发生</div><div class="line">        if (key.isConnectable()) &#123;</div><div class="line">          SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">          // 如果正在连接，则完成连接</div><div class="line">          if (channel.isConnectionPending()) &#123;</div><div class="line">            channel.finishConnect();</div><div class="line">          &#125;</div><div class="line">          // 设置非阻塞</div><div class="line">          channel.configureBlocking(false);</div><div class="line"></div><div class="line">          // 向服务器端发送信息</div><div class="line">          channel.write(ByteBuffer.wrap(new String(&quot;客户端请求连接服务器端.&quot;).getBytes()));</div><div class="line">          // 在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</div><div class="line">          channel.register(selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">          // 获得了可读的事件</div><div class="line">        &#125; else if (key.isReadable()) &#123;</div><div class="line">          read(key);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 处理读取服务器端发来的信息 的事件</div><div class="line">   * </div><div class="line">   * @param key</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public void read(SelectionKey key) throws IOException &#123;</div><div class="line">    // 服务器可读取消息:得到事件发生的Socket通道</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    // 创建读取的缓冲区</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">    channel.read(buffer);</div><div class="line">    byte[] data = buffer.array();</div><div class="line">    String msg = new String(data);</div><div class="line">    System.out.println(&quot;客户端收到服务器信息:&quot; + msg);</div><div class="line">    ByteBuffer outBuffer = ByteBuffer.wrap(new String(&quot;客户端发送服务器消息: hello&quot;).getBytes());</div><div class="line">    channel.write(outBuffer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 客户端测试</div><div class="line">  public static void main(String[] args) throws IOException &#123;</div><div class="line">    NIOClient nioClient = new NIOClient();</div><div class="line">    nioClient.initClient(&quot;127.0.0.1&quot;, 8000);</div><div class="line">    nioClient.listen();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReducer]]></title>
      <url>http://zsr.github.io/2016/08/02/MapReducer/</url>
      <content type="html"><![CDATA[<h1 id="MapReducer笔记"><a href="#MapReducer笔记" class="headerlink" title="MapReducer笔记"></a>MapReducer笔记</h1><h3 id="参入mapreduce作业执行涉及4个独立的实体："><a href="#参入mapreduce作业执行涉及4个独立的实体：" class="headerlink" title="参入mapreduce作业执行涉及4个独立的实体："></a>参入mapreduce作业执行涉及4个独立的实体：</h3><ul>
<li><p>客户端（client）：编写mapreduce程序，配置作业，提交作业，这就是程序员完成的工作；</p>
</li>
<li><p>JobTracker：初始化作业，分配作业，与TaskTracker通信，协调整个作业的执行；</p>
</li>
<li><p>TaskTracker：保持与JobTracker的通信，在分配的数据片段上执行Map或Reduce任务，TaskTracker和JobTracker的不同有个很重要的方面，就是在执行任务时候TaskTracker可以有n多个，JobTracker则只会有一个</p>
</li>
<li><p>Hdfs：保存作业的数据、配置信息等等，最后的结果也是保存在hdfs上面</p>
</li>
</ul>
<p><img src="/images/MapReducer.jpg"></p>
<a id="more"></a>
<h3 id="mapreduce运行过程"><a href="#mapreduce运行过程" class="headerlink" title="mapreduce运行过程"></a>mapreduce运行过程</h3><ul>
<li><p>首先是客户端要编写好mapreduce程序，配置好mapreduce的作业也就是job，接下来就是提交job了，提交job是提交到JobTracker上的，这个时候JobTracker就会构建这个job，具体就是分配一个新的job任务的ID值，接下来它会做检查操作，这个检查就是确定输出目录是否存在，如果存在那么job就不能正常运行下去，JobTracker会抛出错误给客户端，接下来还要检查输入目录是否存在，如果不存在同样抛出错误，如果存在JobTracker会根据输入计算输入分片（Input Split），如果分片计算不出来也会抛出错误，至于输入分片我后面会做讲解的，这些都做好了JobTracker就会配置Job需要的资源了。分配好资源后，JobTracker就会初始化作业，初始化主要做的是将Job放入一个内部的队列，让配置好的作业调度器能调度到这个作业，作业调度器会初始化这个job，初始化就是创建一个正在运行的job对象（封装任务和记录信息），以便JobTracker跟踪job的状态和进程。</p>
</li>
<li><p>初始化完毕后，作业调度器会获取输入分片信息（input split），每个分片创建一个map任务。接下来就是任务分配了，这个时候tasktracker会运行一个简单的循环机制定期发送心跳给jobtracker，心跳间隔是5秒，程序员可以配置这个时间，心跳就是jobtracker和tasktracker沟通的桥梁，通过心跳，jobtracker可以监控tasktracker是否存活，也可以获取tasktracker处理的状态和问题，同时tasktracker也可以通过心跳里的返回值获取jobtracker给它的操作指令。任务分配好后就是执行任务了。在任务执行时候jobtracker可以通过心跳机制监控tasktracker的状态和进度，同时也能计算出整个job的状态和进度，而tasktracker也可以本地监控自己的状态和进度。当jobtracker获得了最后一个完成指定任务的tasktracker操作成功的通知时候，jobtracker会把整个job状态置为成功，然后当客户端查询job运行状态时候（注意：这个是异步操作），客户端会查到job完成的通知的。如果job中途失败，mapreduce也会有相应机制处理，一般而言如果不是程序员程序本身有bug，mapreduce错误处理机制都能保证提交的job能正常完成。</p>
</li>
</ul>
<h5 id="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"><a href="#从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input-split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。" class="headerlink" title="从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。"></a>从逻辑实体的角度讲解mapreduce运行机制，这些按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。</h5><ol>
<li>输入分片（input split）：在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</li>
</ol>
<ol>
<li><p>map阶段：就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</p>
</li>
<li><p>combiner阶段：combiner阶段是程序员可以选择的，combiner其实也是一种reduce操作，因此我们看见WordCount类里是用reduce进行加载的。Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如我们对文件里的单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错。</p>
</li>
<li><p>shuffle阶段：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。这里我不讲怎么优化shuffle阶段，讲讲shuffle阶段的原理，因为大部分的书籍里都没讲清楚shuffle阶段。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。<br>每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。</p>
</li>
<li><p>reduce阶段：和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h1><hr>
<h6 id="Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"><a href="#Spring-AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring-AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring-AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。" class="headerlink" title="Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。"></a>Spring AOP使用动态代理技术在运行期织入增强的代码，为了揭示Spring AOP底层的工作机理，有必要对涉及到的Java知识进行学习。Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代理，而不支持类的代理。</h6><h5 id="带有横切逻辑的实例"><a href="#带有横切逻辑的实例" class="headerlink" title="带有横切逻辑的实例"></a>带有横切逻辑的实例</h5><p>我们通过具体化代码实现上一节所介绍例子的性能监视横切逻辑，并通过动态代理技术对此进行改造。在调用每一个目标类方法时启动方法的性能监视，在目标类方法调用完成时记录方法的花费时间。 </p>
<p>代码清单6-2  ForumService：包含性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;          </div><div class="line">         //①-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">                            &quot;com.baobaotao.proxy.ForumServiceImpl. removeTopic&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //①-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">          //②-1开始对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.begin(  </div><div class="line">&quot;com.baobaotao.proxy.ForumServiceImpl. removeForum&quot;);  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;         </div><div class="line">         //②-2结束对该方法进行性能监视  </div><div class="line">        PerformanceMonitor.end();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码清单6-2中粗体表示的代码就是具有横切逻辑特征的代码，每个Service类和每个业务方法体的前后都执行相同的代码逻辑：方法调用前启动PerformanceMonitor，方法调用后通知PerformanceMonitor结束性能监视并给记录性能监视结果。<br><a id="more"></a></p>
<p>PerformanceMonitor是性能监视的实现类，我们给出一个非常简单的实现版本，其代码如代码清单6-3所示： </p>
<p>代码清单6-3  PerformanceMonitor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class PerformanceMonitor &#123;  </div><div class="line">     //①通过一个ThreadLocal保存调用线程相关的性能监视信息  </div><div class="line">    private static ThreadLocal&lt;MethodPerformace&gt; performanceRecord =          </div><div class="line">                                new ThreadLocal&lt;MethodPerformance&gt;();  </div><div class="line">    //②启动对某一目标方法的性能监视  </div><div class="line">     public static void begin(String method) &#123;  </div><div class="line">        System.out.println(&quot;begin monitor...&quot;);  </div><div class="line">        MethodPerformance mp = new MethodPerformance(method);  </div><div class="line">        performanceRecord.set(mp);  </div><div class="line">    &#125;  </div><div class="line">    public static void end() &#123;  </div><div class="line">        System.out.println(&quot;end monitor...&quot;);  </div><div class="line">        MethodPerformance mp = performanceRecord.get();  </div><div class="line">         //③打印出方法性能监视的结果信息。  </div><div class="line">        mp.printPerformance();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal是将非线程安全类改造为线程安全类的法宝，在9.2节中我们将详细介绍这个Java基础知识。PerformanceMonitor提供了两个方法：通过调用begin(String method)方法开始对某个目标类方法的监视，method为目标类方法的全限定名；而end()方法结束对目标类方法的监视，并给出性能监视的信息。这两个方法必须配套使用。 </p>
<p>用于记录性能监视信息的MethodPerformance类的代码如所示： </p>
<p>代码清单6-4  MethodPerformance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">public class MethodPerformance &#123;  </div><div class="line">    private long begin;  </div><div class="line">    private long end;  </div><div class="line">    private String serviceMethod;  </div><div class="line">    public MethodPerformance(String serviceMethod)&#123;  </div><div class="line">       this.serviceMethod = serviceMethod;  </div><div class="line">       //①记录目标类方法开始执行点的系统时间    </div><div class="line">       this.begin = System.currentTimeMillis();    </div><div class="line">    &#125;  </div><div class="line">    public void printPerformance()&#123;  </div><div class="line">        //②获取目标类方法执行完成后的系统时间，并进而计算出目标类方法执行时间  </div><div class="line">        end = System.currentTimeMillis();   </div><div class="line">        long elapse = end - begin;  </div><div class="line">        //③报告目标类方法的执行时间  </div><div class="line">        System.out.println(serviceMethod+&quot;花费&quot;+elapse+&quot;毫秒。&quot;);    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过下面的代码测试拥有性能监视能力的ForumServiceImpl业务方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy; </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ForumService forumService = new ForumServiceImpl();  </div><div class="line">        forumService .removeForum(10);  </div><div class="line">       forumService .removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们得到以下输出信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... ①removeForum(10)方法的性能监视报告 </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... ①removeTopic(1012)方法的性能监视报告 </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>正如代码清单6 2实例所示，当某个方法需要进行性能监视，就必须调整方法代码，在方法体前后分别添加上开启性能监视和结束性能监视的代码。这些非业务逻辑的性能监视代码破坏了ForumServiceImpl业务逻辑的纯粹性。我们希望通过代理的方式，将业务类方法中开启和结束性能监视的这些横切代码从业务类中完全移除。并通过JDK动态代理技术或CGLib动态代理技术将横切代码动态织入到目标方法的相应位置。 </p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK 1.3以后，Java提供了动态代理的技术，允许开发者在运行期创建接口的代理实例。在Sun刚推出动态代理时，还很难想象它有多大的实际用途，现在我们终于发现动态代理是实现AOP的绝好底层技术。 </p>
<p>JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。 </p>
<p>而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。这样讲一定很抽象，我们马上着手使用Proxy和InvocationHandler这两个魔法戒对上一节中的性能监视代码进行革新。 </p>
<p>首先，我们从业务类ForumServiceImpl中删除性能监视的横切代码，使ForumServiceImpl只负责具体的业务逻辑，如代码清单6-5所示： </p>
<p>代码清单6-5  ForumServiceImpl：移除性能监视横切代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;   </div><div class="line">public class ForumServiceImpl implements ForumService &#123;  </div><div class="line">    public void removeTopic(int topicId) &#123;                                </div><div class="line">                             ①  </div><div class="line">        System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(20);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                             ①  </div><div class="line">    &#125;  </div><div class="line">    public void removeForum(int forumId) &#123;  </div><div class="line">                          ②  </div><div class="line">        System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);  </div><div class="line">        try &#123;  </div><div class="line">            Thread.currentThread().sleep(40);  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            throw new RuntimeException(e);  </div><div class="line">        &#125;  </div><div class="line">                          ②  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码清单6-5中的①和②处，原来的性能监视代码被移除了，我们只保留了真正的业务逻辑。 </p>
<p>从业务类中移除的性能监视横切代码当然不能漂浮在空气中，它还得找到一个安身之所，InvocationHandler就是横切代码的安家乐园，我们将性能监视的代码安置在PerformanceHandler中，如代码清单6-6所示： </p>
<p>代码清单6-6  PerformanceHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.InvocationHandler;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">public class PerformanceHandler implements InvocationHandler &#123;//①实现InvocationHandler  </div><div class="line">    private Object target;  </div><div class="line">    public PerformanceHandler(Object target)&#123; //②target为目标的业务类  </div><div class="line">        this.target = target;  </div><div class="line">    &#125;  </div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) ③  </div><div class="line">            throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(target.getClass().getName()+&quot;.&quot;+ method. getName());③-1  </div><div class="line">        Object obj = method.invoke(target, args);// ③-2通过反射方法调用业务类的目标方法  </div><div class="line">        PerformanceMonitor.end();③-1  </div><div class="line">        return obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>③处invoke()方法中粗体所示部分的代码为性能监视的横切代码，我们发现，横切代码只出现一次，而不是原来那样星洒各处。③-2处的method.invoke()语句通过Java反射机制间接调用目标对象的方法，这样InvocationHandler的invoke()方法就将横切逻辑代码（③-1）和业务类方法的业务逻辑代码（③-2）编织到一起了，所以我们可以将InvocationHandler看成是一个编织器。下面，我们对这段代码做进一步的说明。 </p>
<p>首先，我们实现InvocationHandler接口，该接口定义了一个 invoke(Object proxy, Method method, Object[] args)的方法，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是通过被代理实例某一个方法的入参，在方法反射调用时使用。 </p>
<p>此外，我们在构造函数里通过target传入希望被代理的目标对象，如②处所示，在InvocationHandler接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传给method.invoke()方法，调用目标实例的方法，如③所示。<br>下面，我们通过Proxy结合PerformanceHandler创建ForumService接口的代理实例，如代码清单6-7所示： </p>
<p>代码清单6-7  TestForumService：创建代理实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;                 </div><div class="line">               //①希望被代理的目标业务类  </div><div class="line">        ForumService target = new ForumServiceImpl();            </div><div class="line">               //②将目标业务类和横切代码编织到一起  </div><div class="line">        PerformanceHandler handler = new PerformanceHandler(target);  </div><div class="line">               //③根据编织了目标业务类逻辑和性能监视横切逻辑的InvocationHandler实例创建代理实例  </div><div class="line">        ForumService proxy = (ForumService) Proxy.newProxyInstance(    </div><div class="line">                target.getClass().getClassLoader(),  </div><div class="line">                target.getClass().getInterfaces(),  </div><div class="line">                handler);  </div><div class="line">               //④调用代理实例  </div><div class="line">        proxy.removeForum(10);     </div><div class="line">        proxy.removeTopic(1012);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码完成业务类代码和横切代码的编织工作并生成了代理实例。在②处，我们让PerformanceHandler将性能监视横切逻辑编织到ForumService实例中，然后在③处，通过Proxy的newProxyInstance()静态方法为编织了业务类逻辑和性能监视逻辑的handler创建一个符合ForumService接口的代理实例。该方法的第一个入参为类加载器；第二个入参为创建代理实例所需要实现的一组接口；第三个参数是整合了业务逻辑和横切逻辑的编织器对象。 </p>
<p>按照③处的设置方式，这个代理实例实现了目标业务类的所有接口，即Forum ServiceImpl的ForumService接口。这样，我们就可以按照调用ForumService接口实例相同的方式调用代理实例，如④所示。运行以上的代码，输出以下信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1012 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl.removeTopic花费26毫秒。</div></pre></td></tr></table></figure>
<p>我们发现，程序的运行效果和直接在业务类中编写性能监视逻辑的效果一致，但是在这里，原来分散的横切逻辑代码已经被我们抽取到PerformanceHandler中。当其他业务类（如UserService、SystemService等）的业务方法也需要使用性能监视时，我们只要按照代码清单6-7相似的方式，分别为它们创建代理对象就可以了。下面，我们通过时序图描述通过创建代理对象进行业务方法调用的整体逻辑，以进一步认识代理对象的本质，如图6-3所示。 </p>
<p><img src="/images/图6-3 动态代理.jpg"></p>
<p>我们在上图中使用虚线的方式对通过Proxy创建的ForumService代理实例加以凸显，ForumService代理实例内部利用PerformaceHandler整合横切逻辑和业务逻辑。调用者调用代理对象的removeForum()和removeTopic()方法时，上图的内部调用时序清晰地告诉我们实际上所发生的一切。 </p>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>使用JDK创建代理有一个限制，即它只能为接口创建代理实例，这一点我们可从Proxy的接口newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)的方法签名中就看得很清楚：第二个入参interfaces就是需要代理实例实现的接口列表。虽然面向接口编程的思想被很多大师级人物（包括Rod Johnson）推崇，但在实际开发中，许多开发者也对此深感困惑：难道对一个简单业务表的操作也需要老老实实地创建5个类（领域对象类、Dao接口，Dao实现类，Service接口和Service实现类）吗？难道不能直接通过实现类构建程序吗？对于这个问题，我们很难给出一个孰好孰劣的准确判断，但我们确实发现有很多不使用接口的项目也取得了非常好的效果（包括大家所熟悉的SpringSide开源项目）。 </p>
<p>对于没有通过接口定义业务方法的类，如何动态创建代理实例呢？JDK的代理技术显然已经黔驴技穷，CGLib作为一个替代者，填补了这个空缺。 </p>
<p>CGLib采用非常底层的字节码技术，可以为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，并顺势织入横切逻辑。下面，我们采用CGLib技术，编写一个可以为任何类创建织入性能监视横切逻辑代理对象的代理创建器，如代码清单 6-8所示： </p>
<p>代码清单6-8  CglibProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Method;  </div><div class="line">import net.sf.cglib.proxy.Enhancer;  </div><div class="line">import net.sf.cglib.proxy.MethodInterceptor;  </div><div class="line">import net.sf.cglib.proxy.MethodProxy;  </div><div class="line">public class CglibProxy implements MethodInterceptor &#123;  </div><div class="line">    private Enhancer enhancer = new Enhancer();  </div><div class="line">    public Object getProxy(Class clazz) &#123;  </div><div class="line">        enhancer.setSuperclass(clazz); //① 设置需要创建子类的类  </div><div class="line">        enhancer.setCallback(this);   </div><div class="line">        return enhancer.create(); //②通过字节码技术动态创建子类实例  </div><div class="line">    &#125;  </div><div class="line">        //③拦截父类所有方法的调用  </div><div class="line">    public Object intercept(Object obj, Method method, Object[] args,   </div><div class="line">            MethodProxy proxy) throws Throwable &#123;  </div><div class="line">        PerformanceMonitor.begin(obj.getClass().getName()+&quot;.&quot;+method. getName());//③-1  </div><div class="line">        Object result=proxy.invokeSuper(obj, args); ③-2   </div><div class="line">        PerformanceMonitor.end();//③-1通过代理类调用父类中的方法  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码中，用户可以通过getProxy(Class clazz)为一个类创建动态代理对象，该代理对象通过扩展clazz创建代理对象。在这个代理对象中，我们织入性能监视的横切逻辑（③-1）。intercept(Object obj, Method method, Object[] args,MethodProxy proxy)是CGLib定义的Interceptor接口的方法，它拦截所有目标类方法的调用，obj表示目标类的实例；method为目标类方法的反射对象；args为方法的动态入参；而proxy为代理类实例。 </p>
<p>下面，我们通过CglibProxy为ForumServiceImpl类创建代理对象，并测试代理对象的方法，如代码清单6-9所示： </p>
<p>代码清单6-9  TestForumService：测试Cglib创建的代理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.proxy;  </div><div class="line">import java.lang.reflect.Proxy;  </div><div class="line">public class TestForumService &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">      CglibProxy proxy = new CglibProxy();  </div><div class="line">      ForumServiceImpl forumService = ①   </div><div class="line">                (ForumServiceImpl )proxy.getProxy(ForumServiceImpl.class);  </div><div class="line">      forumService.removeForum(10);  </div><div class="line">      forumService.removeTopic(1023);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在①中，我们通过CglibProxy为ForumServiceImpl动态创建了一个织入性能监视逻辑的代理对象，并调用代理类的业务方法。运行上面的代码，输入以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">begin monitor... </div><div class="line">模拟删除Forum记录:10 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeForum花费47毫秒。 </div><div class="line">begin monitor... </div><div class="line">模拟删除Topic记录:1023 </div><div class="line">end monitor... </div><div class="line">com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0.removeTopic花费16毫秒。</div></pre></td></tr></table></figure></p>
<p>观察以上的输出，除了发现两个业务方法中都织入了性能监控的逻辑外，我们还发现代理类的名字是com.baobaotao.proxy.ForumServiceImpl$$EnhancerByCGLIB$$2a9199c0，这个特殊的类就是CGLib为ForumServiceImpl动态创建的子类。 </p>
<h3 id="代理知识小结"><a href="#代理知识小结" class="headerlink" title="代理知识小结"></a>代理知识小结</h3><p>Spring AOP的底层就是通过使用JDK动态代理或CGLib动态代理技术为目标Bean织入横切逻辑。在这里，我们对前面两节动态创建代理对象作一个小结。 </p>
<p>我们虽然通过PerformanceHandler或CglibProxy实现了性能监视横切逻辑的动态织入，但这种实现方式存在三个明显需要改进的地方： </p>
<ul>
<li>目标类的所有方法都添加了性能监视横切逻辑，而有时，这并不是我们所期望的，我们可能只希望对业务类中的某些特定方法添加横切逻辑； </li>
<li>我们通过硬编码的方式指定了织入横切逻辑的织入点，即在目标类业务方法的开始和结束前织入代码； </li>
<li>我们手工编写代理实例的创建过程，为不同类创建代理时，需要分别编写相应的创建代码，无法做到通用。 </li>
</ul>
<p>以上三个问题，在AOP中占用重要的地位，因为Spring AOP的主要工作就是围绕以上三点展开：Spring AOP通过Pointcut（切点）指定在哪些类的哪些方法上织入横切逻辑，通过Advice（增强）描述横切逻辑和方法的具体织入点（方法前、方法后、方法的两端等）。此外，Spring通过Advisor（切面）将Pointcut和Advice两者组装起来。有了Advisor的信息，Spring就可以利用JDK或CGLib的动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象了。 </p>
<p>JDK动态代理所创建的代理对象，在JDK 1.3下，性能强差人意。虽然在高版本的JDK中，动态代理对象的性能得到了很大的提高，但是有研究表明，CGLib所创建的动态代理对象的性能依旧比JDK的所创建的代理对象的性能高不少（大概10倍）。但CGLib在创建代理对象时所花费的时间却比JDK动态代理多（大概8倍），所以对于singleton的代理对象或者具有实例池的代理，因为无须频繁创建代理对象，所以比较适合用CGLib动态代理技术，反之适合用JDK动态代理技术。值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final方法进行代理。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java反射]]></title>
      <url>http://zsr.github.io/2016/08/01/Java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><hr>
<h6 id="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"><a href="#Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。" class="headerlink" title="Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。"></a>Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。</h6><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们将从一个简单例子开始探访Java反射机制的征程，下面的Car类拥有两个构造函数、两个方法以及三个属性，如代码清单3-9所示： </p>
<p>代码清单3-9  Car<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.reflect;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String brand;  </div><div class="line">    <span class="keyword">private</span> String color;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; </div><div class="line">    <span class="comment">//①默认构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">     <span class="comment">//②带参构造函数  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand,String color,<span class="keyword">int</span> maxSpeed)</span></span>&#123;   </div><div class="line">        <span class="keyword">this</span>.brand = brand;  </div><div class="line">        <span class="keyword">this</span>.color = color;  </div><div class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//③未带参的方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123;   </div><div class="line">       System.out.println(<span class="string">"brand:"</span>+brand+<span class="string">";color:"</span>+color+<span class="string">";maxSpeed:"</span> +maxSpeed);  </div><div class="line">    &#125;  </div><div class="line">     <span class="comment">//省略参数的getter/Setter方法  </span></div><div class="line">     …  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，我们会使用如下的代码创建Car的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Car car = <span class="keyword">new</span> Car();  </div><div class="line">car.setBrand(<span class="string">"红旗CA72"</span>);</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car = new Car(&quot;红旗CA72&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure></p>
<p>以上两种方法都采用传统方式的直接调用目标类的方法，下面我们通过Java反射机制以一种更加通用的方式间接地操作目标类：<br><a id="more"></a></p>
<p>代码清单3-10  ReflectTest<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao. reflect;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car  <span class="title">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> Throwable  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//①通过类装载器获取Car类对象  </span></div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();   </div><div class="line">        Class clazz = loader.loadClass(<span class="string">"com.baobaotao.reflect.Car"</span>); </div><div class="line">        <span class="comment">//②获取类的默认构造器对象并通过它实例化Car  </span></div><div class="line">        Constructor cons = clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>);   </div><div class="line">        Car car = (Car)cons.newInstance();  </div><div class="line">        <span class="comment">//③通过反射方法设置属性  </span></div><div class="line">        Method setBrand = clazz.getMethod(<span class="string">"setBrand"</span>,String.class);          </div><div class="line">        setBrand.invoke(car,<span class="string">"红旗CA72"</span>);        </div><div class="line">        Method setColor = clazz.getMethod(<span class="string">"setColor"</span>,String.class);  </div><div class="line">        setColor.invoke(car,<span class="string">"黑色"</span>);        </div><div class="line">        Method setMaxSpeed = clazz.getMethod(<span class="string">"setMaxSpeed"</span>,<span class="keyword">int</span>.class);  </div><div class="line">        setMaxSpeed.invoke(car,<span class="number">200</span>);          </div><div class="line">        <span class="keyword">return</span> car;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">        Car car = initByDefaultConst();  </div><div class="line">        car.introduce();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上程序，在控制台上将打印出以下信息：<br>引用<br>brand:红旗CA72;color:黑色;maxSpeed:200</p>
<p>这说明我们完全可以通过编程方式调用Class的各项功能，这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。 </p>
<p>在ReflectTest中，使用了几个重要的反射类，分别是ClassLoader、Class、Constructor和Method，通过这些反射类就可以间接调用目标Class的各项功能了。在①处，我们获取当前线程的ClassLoader，然后通过指定的全限定类“com.baobaotao.beans.Car”装载Car类对应的反射实例。在②处，我们通过Car的反射类对象获取Car的构造函数对象cons，通过构造函数对象的newInstrance()方法实例化Car对象，其效果等同于new Car()。在③处，我们又通过Car的反射类对象的getMethod（String methodName,Class paramClass）获取属性的Setter方法对象，第一个参数是目标Class的方法名；第二个参数是方法入参的对象类型。获取方法反射对象后，即可通过invoke（Object obj,Object param）方法调用目标类的方法，该方法的第一个参数是操作的目标类对象实例；第二个参数是目标方法的入参。 </p>
<p>在代码清单3 10中，粗体所示部分的信息即是通过反射方法操控目标类的元信息，如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用的代码对类似于Car的类进行实例化及功能调用操作了。 </p>
<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3><h4 id="类装载器工作机制"><a href="#类装载器工作机制" class="headerlink" title="类装载器工作机制"></a>类装载器工作机制</h4><p>类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： </p>
<ul>
<li>装载：查找和导入Class文件； </li>
<li>链接：执行校验、准备和解析步骤，其中解析步骤是可以选择的： <ul>
<li>校验：检查载入Class文件数据的正确性； </li>
<li>准备：给类的静态变量分配存储空间； </li>
<li>解析：将符号引用转成直接引用； </li>
</ul>
</li>
<li>初始化：对类的静态变量、静态代码块执行初始化工作。 </li>
</ul>
<p>类装载工作由ClassLoader及其子类负责，ClassLoader是一个重要的Java运行时系统组件，它负责在运行时查找和装入Class字节码文件。JVM在运行时会产生三个ClassLoader：根装载器、ExtClassLoader（扩展类装载器）和AppClassLoader（系统类装载器）。其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在Java中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的rt.jar、charsets.jar等。ExtClassLoader和AppClassLoader都是ClassLoader的子类。其中ExtClassLoader负责装载JRE扩展目录ext中的JAR类包；AppClassLoader负责装载Classpath路径下的类包。 </p>
<p>这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下，使用AppClassLoader装载应用程序的类，我们可以做一个实验： </p>
<p>代码清单3-11  ClassLoaderTest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">        System.out.println(&quot;current loader:&quot;+loader);  </div><div class="line">        System.out.println(&quot;parent loader:&quot;+loader.getParent());  </div><div class="line">        System.out.println(&quot;grandparent loader:&quot;+loader.getParent(). getParent());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上代码，在控制台上将打出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">current loader:sun.misc.Launcher$AppClassLoader@131f71a </div><div class="line">parent loader:sun.misc.Launcher$ExtClassLoader@15601ea </div><div class="line"> //①根装载器在Java中访问不到，所以返回null </div><div class="line">grandparent loader:null</div></pre></td></tr></table></figure></p>
<p>通过以上的输出信息，我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在Java中无法获得它的句柄，所以仅返回null。 </p>
<p>JVM装载类时使用“全盘负责委托机制”，“全盘负责”是指当一个ClassLoader装载一个类的时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全角度考虑的，试想如果有人编写了一个恶意的基础类（如java.lang.String）并装载到JVM中将会引起多么可怕的后果。但是由于有了“全盘负责委托机制”，java.lang.String永远是由根装载器来装载的，这样就避免了上述事件的发生。 </p>
<h4 id="ClassLoader重要方法"><a href="#ClassLoader重要方法" class="headerlink" title="ClassLoader重要方法"></a>ClassLoader重要方法</h4><p>在Java中，ClassLoader是一个抽象类，位于java.lang包中。下面对该类的一些重要接口方法进行介绍： </p>
<ul>
<li><p>Class loadClass(String name)<br>  name参数指定类装载器需要装载类的名字，必须使用全限定类名，如com.baobaotao. beans.Car。该方法有一个重载方法loadClass(String name ,boolean resolve)，resolve参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进行类解析的工作，但并不是所有的类都需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。 </p>
</li>
<li><p>Class defineClass(String name, byte[] b, int off, int len)<br> 将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。</p>
</li>
<li><p>Class findSystemClass(String name)<br> 从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 </p>
</li>
<li><p>Class findLoadedClass(String name)<br>调用该方法来查看ClassLoader是否已装入某个类。如果已装入，那么返回java.lang.Class对象，否则返回null。如果强行装载已存在的类，将会抛出链接错误。 </p>
</li>
<li><p>ClassLoader getParent()<br> 获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 </p>
</li>
</ul>
<p>除JVM默认的三个ClassLoader以外，可以编写自己的第三方类装载器，以实现一些特殊的需求。类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用，如图3-4所示。 </p>
<p><img src="/images/图3-4 类加载.jpg"></p>
<p>每一个类在JVM中都拥有一个对应的java.lang.Class对象，它提供了类结构信息的描述。数组、枚举、注解以及基本Java类型（如int、double等），甚至void都拥有对应的Class对象。Class没有public的构造方法。Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 </p>
<h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p>Class反射对象描述类语义结构，可以从Class对象中获取构造函数、成员变量、方法类等类元素的反射对象，并以编程的方式通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类： </p>
<ul>
<li><p>Constructor：类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。在JDK5.0中，还可以通过getConstructor(Class… parameterTypes)获取拥有特定入参的构造函数反射对象。Constructor的一个主要方法是newInstance(Object[] initargs)，通过该方法可以创建一个对象类的实例，相当于new关键字。在JDK5.0中该方法演化为更为灵活的形式：newInstance (Object… initargs)。</p>
</li>
<li><p>Method：类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组Method[]。在JDK5.0中可以通过getDeclaredMethod(String name, Class… parameterTypes)获取特定签名的方法，name为方法名；Class…为方法入参类型列表。Method最主要的方法是invoke(Object obj, Object[] args)，obj表示操作的目标对象；args为方法入参，代码清单3 10③处演示了这个反射类的使用方法。在JDK 5.0中，该方法的形式调整为invoke(Object obj, Object… args)。此外，Method还有很多用于获取类方法更多信息的方法：</p>
<pre><code>- Class getReturnType()：获取方法的返回值类型； 
- Class[] getParameterTypes()：获取方法的入参类型数组； 
- Class[] getExceptionTypes()：获取方法的异常类型数组； 
- Annotation[][] getParameterAnnotations()：获取方法的注解信息，JDK 5.0中的新方法；
</code></pre></li>
<li><p>Field：类的成员变量的反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredField(String name)则可获取某个特定名称的成员变量反射对象。Field类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标对象的成员变量设置值。如果成员变量为基础类型，用户可以使用Field类中提供的带类型名的值设置方法，如setBoolean(Object obj, boolean value)、setInt(Object obj, int value)等。</p>
</li>
</ul>
<p>此外，Java还为包提供了Package反射类，在JDK 5.0中还为注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中所有的元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用，请看下面的例子： </p>
<p>代码清单3-12  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.baobaotao.reflect;  </div><div class="line">public class PrivateCar &#123;  </div><div class="line">   //①private成员变量：使用传统的类实例调用方式，只能在本类中访问  </div><div class="line">   private String color;   </div><div class="line">   //②protected方法：使用传统的类实例调用方式，只能在子类和本包中访问  </div><div class="line">   protected void drive()&#123;       </div><div class="line">		System.out.println(&quot;drive private car! the color is:&quot;+color);  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>color变量和drive()方法都是私有的，通过类实例变量无法在外部访问私有变量、调用私有方法的，但通过反射机制却可以绕过这个限制： </p>
<p>代码清单3-13  PrivateCarReflect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">…  </div><div class="line">public class PrivateCarReflect &#123;  </div><div class="line">   public static void main(String[] args) throws Throwable&#123;  </div><div class="line">       ClassLoader loader = Thread.currentThread().getContextClassLoader();  </div><div class="line">       Class clazz = loader.loadClass(&quot;com.baobaotao.reflect.PrivateCar&quot;);  </div><div class="line">       PrivateCar pcar = (PrivateCar)clazz.newInstance();   </div><div class="line">       Field colorFld = clazz.getDeclaredField(&quot;color&quot;);  </div><div class="line">        //①取消Java语言访问检查以访问private变量  </div><div class="line">       colorFld.setAccessible(true);   </div><div class="line">       colorFld.set(pcar,&quot;红色&quot;);  </div><div class="line">       Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;,(Class[])null);  </div><div class="line">        //Method driveMtd = clazz.getDeclaredMethod(&quot;drive&quot;); JDK5.0下使用  </div><div class="line">        //②取消Java语言访问检查以访问protected方法  </div><div class="line">       driveMtd.setAccessible(true);   </div><div class="line">       driveMtd.invoke(pcar,(Object[])null);  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行该类，打印出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drive private car! the color is:红色</div></pre></td></tr></table></figure></p>
<p>在访问private、protected成员变量和方法时必须通过setAccessible(boolean access)方法取消Java语言检查，否则将抛出IllegalAccessException。如果JVM的安全管理器设置了相应的安全机制，调用该方法将抛出SecurityException。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap]]></title>
      <url>http://zsr.github.io/2016/08/01/HashMap/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源代码阅读之-HashMap"><a href="#OpenJDK-源代码阅读之-HashMap" class="headerlink" title="OpenJDK 源代码阅读之 HashMap"></a>OpenJDK 源代码阅读之 HashMap</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractMap&lt;K,V&gt;</div><div class="line">        java.util.TreeMap&lt;K,V&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class TreeMap&lt;K,V&gt;</div><div class="line">extends AbstractMap&lt;K,V&gt;</div><div class="line">implements NavigableMap&lt;K,V&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<ul>
<li>要点</li>
</ul>
<p>1) 与 Hashtable 区别在于：非同步，允许 <code>null</code><br>2) 不保证次序，甚至不保证次序随时间不变<br>3) 基本操作 put, get 常量时间<br>4) 遍历操作 与 capacity+size 成正比<br>5) HashMap 性能与 <code>capacity</code> 和 <code>load factor</code> 相关，<code>load factor</code> 是当前元素个数与 <code>capacity</code> 的比值，通常设定为 <code>0.75</code>，如果此值过大，空间利用率高，但是冲突的可能性增加，因而可能导致查找时间增加，如果过小，反之。当元素个数大于 <code>capacity * load_factor</code> 时，<code>HashMap</code> 会重新安排 Hash 表。因此高效地使用 <code>HashMap</code> 需要预估元素个数，设置最佳的 <code>capacity</code> 和 <code>load factor</code> ，使得重新安排 Hash 表的次数下降。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>capacity</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，<code>HashMap</code> 并不会按照你指定的 <code>initialCapacity</code> 来确定 <code>capacity</code> 大小，而是会找到一个比它大的数，并且是 <code>2的n次方</code>。</p>
<blockquote>
<p>为什么要是 2 的n次方呢？</p>
</blockquote>
<ul>
<li>hash </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Retrieve object hash code and applies a supplemental hash function to the</div><div class="line"> * result hash, which defends against poor quality hash functions.  This is</div><div class="line"> * critical because HashMap uses power-of-two length hash tables, that</div><div class="line"> * otherwise encounter collisions for hashCodes that do not differ</div><div class="line"> * in lower bits. Note: Null keys always map to hash 0, thus index 0.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</div><div class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h = hashSeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 <code>k</code> 是 <code>String</code> 类型，使用了特别的 <code>hash</code> 函数，否则首先得到 <code>hashCode</code>，然后又对 <code>h</code> 作了移位，异或操作，问题：</p>
<blockquote>
<p>为什么这里要作移位，异或操作呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">at 22: </div><div class="line">h = abcdefgh</div><div class="line">h1 = h &gt;&gt;&gt; 20 = 00000abc</div><div class="line">h2 = h &gt;&gt;&gt; 12 = 000abcde</div><div class="line">h3 = h1 ^ h2 = [0][0][0][a][b][a^c][b^d][c^e]</div><div class="line">h4 = h ^ h3 = [a][b][c][a^d][b^e][a^c^f][b^d^g][c^e^h]</div><div class="line">h5 = h4 &gt;&gt;&gt; 4 = [0][a][b][c][a^d][b^e][a^c^f][b^d^g]</div><div class="line">h6 = h4 &gt;&gt;&gt; 7 = ([0][:3])[0][0][a][b][c][a^d][b^e][a^c^f]([a^c^f][0])</div><div class="line">h7 = h4 ^ h6 = 太凶残了。。。</div></pre></td></tr></table></figure>
<ul>
<li>put</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</div><div class="line"> * <span class="doctag">@param</span> value value to be associated with the specified key</div><div class="line"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>put</code> 其实可以看出各个 <code>hash</code> 表是如何实现的，首先取得 <code>hash</code> 值，然后由 <code>indexFor</code> 找到链表头的 <code>index</code>，然后开始遍历链表，如果链表里的一个元素 <code>hash</code> 值与当前 <code>key</code> 的 <code>hash</code> 值相同，或者元素 <code>key</code> 的引用与当前 <code>key</code> 相同，或者 <code>equals</code> 相同，就说明当前 <code>key</code> 已经在 <code>hash</code> 表里了，那么修改它的值，返回旧值。</p>
<p>如果不在表里，会调用 <code>addEntry</code>，将这一 <code>(key, value)</code> 对添加进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Adds a new entry with the specified key, value and hash code to</div><div class="line"> * the specified bucket.  It is the responsibility of this</div><div class="line"> * method to resize the table if appropriate.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of put method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Like addEntry except that this version is used when creating entries</div><div class="line"> * as part of Map construction or "pseudo-construction" (cloning,</div><div class="line"> * deserialization).  This version needn't worry about resizing the table.</div><div class="line"> *</div><div class="line"> * Subclass overrides this to alter the behavior of HashMap(Map),</div><div class="line"> * clone, and readObject.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，新增加元素时，可能会调整 <code>hash</code> 表的大小，原因之前已经讨论过。直接的添加在 <code>createEntry</code> 中完成，但是这里并没有体现出如何处理冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里，将 <code>n</code> 赋值给了 <code>next</code>，这其实就是将新添加的项指向了当前链表头。这一操作在 <code>Entry</code> 的构造函数中完成。</p>
<p><code>put</code> 操作的基本思路在到这里已经很清楚了，有了这个思路，不难想象 <code>get</code> 是如何动作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 <code>put</code> 差不多，只是找到了就会返回相应的 <code>value</code> ，找不到就返回 <code>null</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git使用小记]]></title>
      <url>http://zsr.github.io/2016/08/01/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Git使用小记"><a href="#Git使用小记" class="headerlink" title="Git使用小记"></a>Git使用小记</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。</p>
<!--![git](git流程.png)-->
<p><img src="/images/git流程.png"></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><p>了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。</p>
<p>从时间先后来讲，工作目录的内容是你当前看到的，也是最新的；index区标记了你当前工作目录中，哪些内容是被git管理的；而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些；远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p>
<p>任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。<br><a id="more"></a></p>
<h3 id="远程仓库操作命令"><a href="#远程仓库操作命令" class="headerlink" title="远程仓库操作命令"></a>远程仓库操作命令</h3><ul>
<li><p>从远程仓库克隆仓库到本地：$ git clone git://github.com/**.git</p>
</li>
<li><p>查看远程仓库别名以及地址：$ git remote -v</p>
</li>
<li><p>添加远程仓库：$ git remote add [name] [url]</p>
</li>
<li><p>删除远程仓库：$ git remote rm [name]</p>
</li>
<li><p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
</li>
<li><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
</li>
<li><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
</li>
<li><p>提交本地test分支作为远程的master分支：$git push origin test:master</p>
</li>
<li><p>提交本地test分支作为远程的test分支：$git push origin test:test</p>
</li>
</ul>
<h3 id="分支操作命令–branch"><a href="#分支操作命令–branch" class="headerlink" title="分支操作命令–branch"></a>分支操作命令–branch</h3><ul>
<li><p>查看远程和本地所有分支：$ git branch -a</p>
</li>
<li><p>创建本地分支：$ git branch [name]</p>
</li>
<li><p>切换分支：$ git checkout [name]</p>
</li>
<li><p>创建新分支并且切换到新的分支：$ git check -b [name]</p>
</li>
<li><p>复制远程的分支并且以此来创建新分支：$ git check -t /remotes/origin/branch1 //这样就能在本地创建一个复制来自远程branch1分支</p>
</li>
<li><p>删除分支：$ git branch -d [name] //-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
</li>
<li><p>合并分支：$git merge [name] //将名称为[name]的分支与当前的分支合并</p>
</li>
<li><p>创建远程分支：(本地分支push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p>
</li>
</ul>
<h3 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h3><ul>
<li><p>查看版本：$ git tag</p>
</li>
<li><p>创建版本：$ git tag [name]</p>
</li>
<li><p>删除版本：$ git tag -d [name]</p>
</li>
<li><p>查看远程版本：$ git tag -r</p>
</li>
<li><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
</li>
<li><p>删除远程版本：$ git push origin :refs/tags/[name]</p>
</li>
<li><p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
</li>
<li><p>上传本地tag到远程仓库：$ git push origin –tags</p>
</li>
<li><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
</li>
</ul>
<h3 id="子模块-submodule-相关操作命令"><a href="#子模块-submodule-相关操作命令" class="headerlink" title="子模块(submodule)相关操作命令"></a>子模块(submodule)相关操作命令</h3><ul>
<li><p>添加子模块：$ git submodule add [url] [path]</p>
</li>
<li><p>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</p>
</li>
<li><p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p>
</li>
<li><p>删除子模块：（分4步走哦）</p>
<ul>
<li><p>$ git rm –cached [path]</p>
</li>
<li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>编辑“ .git/config”文件，将子模块的相关配置节点删除掉</p>
</li>
<li><p>手动删除子模块残留的目录</p>
</li>
</ul>
</li>
<li><p>忽略一些文件、文件夹不提交</p>
<ul>
<li>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target</div><div class="line">bin</div><div class="line">*.db</div></pre></td></tr></table></figure>
<ul>
<li><p>删除缓存区的文件</p>
<ul>
<li>不怎么进行删除操作，所以就常用这一个命令：$ git rm -r –cached .</li>
</ul>
</li>
</ul>
<h3 id="git撤销操作"><a href="#git撤销操作" class="headerlink" title="git撤销操作"></a>git撤销操作</h3><h5 id="撤销已暂存的操作"><a href="#撤销已暂存的操作" class="headerlink" title="撤销已暂存的操作"></a>撤销已暂存的操作</h5><p>对于一些已经被git add后的文件，如果想要撤销刚刚的操作，就要进行如下操作:</p>
<ul>
<li>首先查看一下本地有哪些已经被add但是还未commit的数据，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<ul>
<li>然后找到你要进行删掉的文件后，执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD filename</div></pre></td></tr></table></figure>
<h5 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h5><p>对于已经commit的数据，要回退的步骤为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm -r --cached</div></pre></td></tr></table></figure>
<h3 id="git-版本回退"><a href="#git-版本回退" class="headerlink" title="git 版本回退"></a>git 版本回退</h3><h5 id="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"><a href="#关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退" class="headerlink" title="关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退"></a>关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退</h5><p>1.先来说说本地的好了，本地的话就依次执行一下操作即可。</p>
<p>根据-soft,-mixed,-hard，会对working tree和index和HEAD进行重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.git reset -mixed：这种为默认方式，不带任何参数的git reset，它回退到某个版本，只保留源码，回退commit和index信息</div><div class="line">2.git reset -soft: 回退到某个版本，只回退了commit信息，不会恢复到index file一级。如果还要提交的话，直接commit即可。</div><div class="line">3.git reset -hard:彻底回退到某个版本，本地的源码也会变成上一个版本的内容，操作需要谨慎！！</div><div class="line">示例：</div><div class="line">* HEAD是指向最新的提交的，上一次的提交是HEAD^,上上次是HEAD^^,也可以写成HEAD~2,其中的--hard表示放弃所有本地改动</div><div class="line">git reset --hard HEAD^</div></pre></td></tr></table></figure></p>
<p>或者也可以回退倒指定的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;哈希值&gt;</div></pre></td></tr></table></figure>
<p>2.关于远程的话也得分情况了，如果远程仓库能够远程ssh上去的话那就比较简单了，方法和在本地一样了，但是如果ssh上不上去就不行了，这里我看到找到了两种方法：</p>
<ul>
<li>第一种就是比较暴力的方法，就是直接强制提交，git push -f,但是这个非常不推荐，除非你是自己一个人开发的小项目。</li>
<li>第二种就是先将远程分支备份好以后直接删除，然后再将本地的回滚后的版本的push到远程分支上，这样就等于回退了版本。</li>
</ul>
<h3 id="git-merge解冲突"><a href="#git-merge解冲突" class="headerlink" title="git merge解冲突"></a>git merge解冲突</h3><h5 id="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"><a href="#在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。" class="headerlink" title="在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。"></a>在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。</h5><p>这里假设有两个分支，一个是develop分支，一个是developby分支，develop分支是主要分支，这时候，我们可以 在developby分支里面运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge develop</div></pre></td></tr></table></figure>
<p>这样的话就将将develop中的内容merge到了developby分支中，如果没有冲突的话，merge完成，如果有冲突的话，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<p>这样的话git会列出有冲突的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">printf (“test1″);</div><div class="line">=======</div><div class="line">printf (“test2″);</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</div></pre></td></tr></table></figure>
<h5 id="接下来我们来讲解一下里面的符号各代表什么意思。"><a href="#接下来我们来讲解一下里面的符号各代表什么意思。" class="headerlink" title="接下来我们来讲解一下里面的符号各代表什么意思。"></a>接下来我们来讲解一下里面的符号各代表什么意思。</h5><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记冲突的开始，后面的内同是当前分支中的内容。</p>
<p>HEAD 指向当前分支末梢的提交。</p>
<p>=======之后，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之前 是从develop分支上面merge过来的代码。&gt;&gt;&gt;&gt;&gt;&gt;&gt;之后跟的是要合并过来的分支的名称。</p>
<h5 id="然后我们就开始手动解冲突了"><a href="#然后我们就开始手动解冲突了" class="headerlink" title="然后我们就开始手动解冲突了"></a>然后我们就开始手动解冲突了</h5><p>这时候根据你的需要选择你要保留的是哪个分支上的代码，你要删除哪个分支上的代码，想要删除的代码就直接删掉就可以了，最后将多余符号删掉保存就可以了。</p>
<h3 id="一般的代码管理流程："><a href="#一般的代码管理流程：" class="headerlink" title="一般的代码管理流程："></a>一般的代码管理流程：</h3><ul>
<li><p>远程已经建完仓库后直接克隆到本地： $ git clone [仓库地址]</p>
</li>
<li><p>查看本地和远程的branch：$ git branch -a</p>
</li>
<li><p>如果远程的branch更新了的话运行：$ git fetch -p //这样会将远程的分支列表重新拉取</p>
</li>
<li><p>将远程的branch复制到本地并且切换到这个分支下面：$ git checkout -t [远程分支名字]</p>
</li>
<li><p>这是看到自己已经在新建的branch下面了，然后看一下有没有文件。</p>
</li>
<li><p>若没有的话试一下：$ git pull</p>
</li>
<li><p>做完修改以后的话先add：$ git add . //这样会将除了在.gitignore中写入的文件都加入进要提交的文件内</p>
</li>
<li><p>然后进行提交到本地仓库：$ git commit - m “提交”</p>
</li>
<li><p>可以查看状态：$ git status 或者 $git diff</p>
</li>
<li><p>如果没什么问题的话就进行提交到远程库： $ git push //如果加入-f的话是强制提交。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList]]></title>
      <url>http://zsr.github.io/2016/07/29/ArrayList/</url>
      <content type="html"><![CDATA[<h1 id="OpenJDK-源码阅读之-ArrayList"><a href="#OpenJDK-源码阅读之-ArrayList" class="headerlink" title="OpenJDK 源码阅读之 ArrayList"></a>OpenJDK 源码阅读之 ArrayList</h1><hr>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>类继承关系 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">    java.util.AbstractCollection&lt;E&gt;</div><div class="line">        java.util.AbstractList&lt;E&gt;</div><div class="line">            java.util.ArrayList&lt;E&gt;</div></pre></td></tr></table></figure>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>transient</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>声明为 <code>transient</code>后，这个字段不会被序列化。</p>
<ul>
<li>toArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a list containing the elements of the specified</div><div class="line"> * collection, in the order they are returned by the collection's</div><div class="line"> * iterator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对 <code>elementData</code> 的检查，<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="external">Bug 6260652</a>中对此有详细描述。主要原因是 <code>c.toArray()</code> 不一定会返回　<code>Object[]</code> 类型的值。</p>
<a id="more"></a>
<ul>
<li>SuppressWarnings</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">               ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</div></pre></td></tr></table></figure>
<p>告诉编译器，对特定类型的 <code>warning</code> 保持静默。</p>
<ul>
<li>参数检查</li>
</ul>
<p>可以看出标准库中的程序，在很多地方都需要对参数进行检查，以保证程序的健壮性。</p>
<p>检查 <code>null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>检查参数上界，下界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>ArrayList 的 index 检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       rangeCheck(index);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> elementData(index);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意　<code>rangeCheck</code> 只检查了上界，但是如果将　<code>index</code> 设置成负数，也会抛出异常，异常是在 <code>elementData[index]</code> 中抛出的，猜想是在数组的实现中，对负数进行检查，因为任何一个数组，<code>index</code> 都不可能为负数，但是在实现数组时，不知道数组的元素个数，所以上界检查在此时发生。</p>
<ul>
<li>元素访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (E) elementData[index];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>专门写了一个函数用来访问元素，而不是直接使用 <code>elementData[index]</code>，只因为需要向上转型么？还是 <code>SuppressWarning</code>　会重复。</p>
<ul>
<li>private</li>
</ul>
<p>对于仅仅在类内部使用的函数，要声明为 <code>private</code>。</p>
<ul>
<li>add 参数检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">     rangeCheckForAdd(index);</div><div class="line"></div><div class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">     System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                      size - index);</div><div class="line">     elementData[index] = element;</div><div class="line">     size++;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出这里对　<code>index</code> 的上界和下界都检查了，虽然　<code>add</code> 的<code>7</code> 行会进行检查，但在 <code>add</code>　的 <code>4</code>, <code>5</code> 行中就已经可能出错。</p>
<ul>
<li>强制垃圾回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意第 <code>11</code>行把最后一个元素设置为<code>null</code>，这可以使得<code>gc</code>工作。好奇如何用实验验证这一点。</p>
<ul>
<li>remove(Object o)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个框架与 <code>indexOf</code> 函数是相似的，注意那个 <code>fastRemove</code> 函数，它与 <code>remove(index)</code> 的不同在于它：</p>
<ol>
<li>是 <code>private</code></li>
<li>无参数检查，因为传给它的参数一定是合法的</li>
<li>不返回值</li>
</ol>
<p>由此细节可见，标准库中函数的精益求精。(不知道是不是我过度揣测了，有经过性能测试么？)</p>
<ul>
<li>batchRemove</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</div><div class="line">     <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">     <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">             <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</div><div class="line">                 elementData[w++] = elementData[r];</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">         <span class="comment">// even if c.contains() throws.</span></div><div class="line">         <span class="keyword">if</span> (r != size) &#123;</div><div class="line">             System.arraycopy(elementData, r,</div><div class="line">                              elementData, w,</div><div class="line">                              size - r);</div><div class="line">             w += size - r;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (w != size) &#123;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</div><div class="line">                 elementData[i] = <span class="keyword">null</span>;</div><div class="line">             modCount += size - w;</div><div class="line">             size = w;</div><div class="line">             modified = <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> modified;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>注意 <code>finally</code> 里的代码，这段代码保证，即使 <code>try</code> 中的代码出了问题，也会最大程度上保证数据的一致性。如果 <code>r</code> 没有遍历完，那么后面没有检查过的数据都要保留下来。</p>
<ul>
<li>线程安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out array length</span></div><div class="line">    s.writeInt(elementData.length);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意那个　<code>modCount</code> 的检查，这是为了确定在 <code>5-12</code>　行代码执行过程中，<code>List</code> 没有改变。改变的原因可能是由于多线程并发执行，在这期间另一个线程执行，改变了 <code>List</code> 的状态。</p>
<ul>
<li>容量扩充</li>
</ul>
<p>容量扩充会在任何可能引起　<code>ArrayList</code> 大小改变的情况下发生，如何扩充呢，代码在 <code>grow</code> 函数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="comment">// overflow-conscious code</span></div><div class="line">     <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">         newCapacity = minCapacity;</div><div class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">         newCapacity = hugeCapacity(minCapacity);</div><div class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">     <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">         Integer.MAX_VALUE :</div><div class="line">         MAX_ARRAY_SIZE;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出，<code>oldCapacity</code> 新增的容量是它的一半。另外，还有一个 <code>hugeCapacity</code>，如果需要扩充的容量比　<code>MAX_ARRAY_SIZE</code> 还大，会调用这个函数，重新调整大小。但再大也大不过　<code>Integer.MAX_VALUE</code>。</p>
<ul>
<li>元素位置调整</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论是增加元素还是删除元素，都可能使得很多元素的位置发生改变，这里就是用 <code>System.arraycopy</code> 来把大量元素放在其它位置，如果元素很多，经常需要调整，是很浪费时间的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java-coding-style]]></title>
      <url>http://zsr.github.io/2016/07/29/java-coding-style/</url>
      <content type="html"><![CDATA[<h1 id="Java编码风格"><a href="#Java编码风格" class="headerlink" title="Java编码风格"></a>Java编码风格</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这份文档源自Google Java编程风格规范，并根据我的想法，做了一些调整，当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Ximalaya直播team的Java编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是强制要求的，我们尽量不提供意见。</p>
<h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p>
<p>术语<code>class</code>可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语<code>comment</code>只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p>
<h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Ximalaya编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<a id="more"></a>
<h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h3 id="2-2-编码"><a href="#2-2-编码" class="headerlink" title="2.2 编码"></a>2.2 编码</h3><p>源文件编码格式为<code>UTF-8</code>。</p>
<h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><p>不要使用特殊字符。</p>
<h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p>
<ul>
<li>许可证或版权信息</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ul>
<blockquote>
<p>以上每个部分之间用一个空行隔开。</p>
</blockquote>
<h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。<br>公司版权信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 文件名称: $&#123;filename&#125; Copyright 2011-2014 Ximalaya All right reserved.</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，即package语句写在一行里。</p>
<h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>
<h4 id="3-3-2-不要import静态变量和方法"><a href="#3-3-2-不要import静态变量和方法" class="headerlink" title="3.3.2 不要import静态变量和方法"></a>3.3.2 不要import静态变量和方法</h4><p>即，不要出现类似这样的import语句：<code>import static org.junit.Assert.fail;</code></p>
<h4 id="3-3-3-不要换行"><a href="#3-3-3-不要换行" class="headerlink" title="3.3.3 不要换行"></a>3.3.3 不要换行</h4><p>import语句不换行，即每个import语句独立成行。</p>
<h4 id="3-3-4-顺序和间距"><a href="#3-3-4-顺序和间距" class="headerlink" title="3.3.4 顺序和间距"></a>3.3.4 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<p>每个顶级包为一组，字典序，组内不空行，按字典序排列。</p>
<h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p>
<p>例外：package-info.java，该文件中可没有package-info类。</p>
<h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<p>总的来说，按照<code>static</code>、<code>private</code>、<code>protected</code>等修饰符归类。</p>
<h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p>
<p>左大括号前不换行<br>左大括号后换行<br>右大括号前换行<br>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">return new MyClass() &#123;</div><div class="line">  @Override public void method() &#123;</div><div class="line">    if (condition()) &#123;</div><div class="line">      try &#123;</div><div class="line">        something();</div><div class="line">      &#125; catch (ProblemException e) &#123;</div><div class="line">        recover();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>4.8.1节给出了enum类的一些例外。</p>
</blockquote>
<h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void doNothing() &#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>不过理论上不应该出现这样什么都不做的方法或if/else等。</p>
</blockquote>
<h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p>
<h3 id="4-4-列限制：100"><a href="#4-4-列限制：100" class="headerlink" title="4.4 列限制：100"></a>4.4 列限制：100</h3><p>一个项目可以选择一行100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<p>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。<br>package和import语句(见3.2节和3.3节)。<br>注释中那些可能被剪切并粘贴到shell中的命令行。</p>
<h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行，我们通常通过使用统一的eclipse formatter来保证大家的换行格式统一，格式优美是首先要考虑的。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题，或者合理缩短命名长度。</p>
</blockquote>
<h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p>
<p>类内连续的成员之间：</p>
<ul>
<li>字段</li>
<li>构造函数</li>
<li>方法</li>
<li>嵌套类</li>
<li>静态初始化块</li>
<li>实例初始化块</li>
</ul>
<p>例外：</p>
<ul>
<li><code>两个连续字段之间的空行是可选的</code>，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句根据业务逻辑分组。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ul>
<h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ul>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li>@SomeAnnotation({a, b})(不使用空格)。</li>
<li>String[][] x = foo;(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<t extends="" foo="" &="" bar="">)。</t></li>
</ul>
</li>
<li>catch块中的管道符号(catch (FooException | BarException e)。</li>
<li>foreach语句中的分号。</li>
<li>在, : ;及右括号())后</li>
<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li>
</ul>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h4 id="4-6-3-水平对齐：不建议"><a href="#4-6-3-水平对齐：不建议" class="headerlink" title="4.6.3 水平对齐：不建议"></a>4.6.3 水平对齐：不建议</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private int x; // this is fine</div><div class="line">private Color color; // this too</div><div class="line"></div><div class="line">private int   x;      // 不建议</div><div class="line">private Color color;  // 不建议</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
</blockquote>
<h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如<code>int a, b;</code>。</p>
<h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1, 2, 3 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0,</div><div class="line">  1,</div><div class="line">  2,</div><div class="line">  3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new int[] &#123;</div><div class="line">  0, 1,</div><div class="line">  2, 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new int[]</div><div class="line">    &#123;0, 1, 2, 3&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：String[] args， 而非String args[]。</p>
<h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (input) &#123;</div><div class="line">  case 1:</div><div class="line">  case 2:</div><div class="line">    handleOneTwoOr();</div><div class="line">    break;</div><div class="line">  case 3:</div><div class="line">    handleThree();</div><div class="line">    break;</div><div class="line">  default:</div><div class="line">    handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>
<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h5 id="4-8-4-2-default的情况要写出来"><a href="#4-8-4-2-default的情况要写出来" class="headerlink" title="4.8.4.2 default的情况要写出来"></a>4.8.4.2 default的情况要写出来</h5><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p>
<h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">@Nullable</div><div class="line">public String getNameIfPresent() &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的多个注解不允许与字段出现在同一行，并且一个注解独占一行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Partial </div><div class="line">@Mock </div><div class="line">DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<p>例外：应用于方法参数的注解<code>不用换行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public String getNameIfPresent(@RequestParam String param) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * This is          // And so           /**  </div><div class="line"> * okay.            // is this.          * Or you can even do this.</div><div class="line"> */                                      */</div><div class="line">注释不要封闭在由星号或其它字符绘制的框架里。</div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
</blockquote>
<h5 id="4-8-6-2-被注释的代码"><a href="#4-8-6-2-被注释的代码" class="headerlink" title="4.8.6.2 被注释的代码"></a>4.8.6.2 被注释的代码</h5><p>有时可能出于某种原因某段代码被注释，那么在之后的10个commit内，建议移除。</p>
<h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<ul>
<li>public </li>
<li>protected </li>
<li>private </li>
<li>abstract </li>
<li>static </li>
<li>final </li>
<li>transient </li>
<li>volatile </li>
<li>synchronized </li>
<li>native </li>
<li>strictfp</li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p>
<h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以UpperCamelCase风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p>
<h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以lowerCamelCase风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Constants</div><div class="line">static final int NUMBER = 5;</div><div class="line">static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</div><div class="line">static final Joiner COMMA_JOINER = Joiner.on(&apos;,&apos;);  // because Joiner is immutable</div><div class="line">static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line">// Not constants</div><div class="line">static String nonFinal = &quot;non-final&quot;;</div><div class="line">final String nonStatic = &quot;non-static&quot;;</div><div class="line">static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();</div><div class="line">static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line">static final Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line">static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以lowerCamelCase风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以lowerCamelCase风格编写。</p>
<p>参数应该避免用单个字符命名，并且要尽量容易理解。</p>
<h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p>
<p>单个或者多个的大写字母，后面可以跟一个数字(如：E, T, X, IN, OUT)。</p>
<h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ul>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Prose form                Correct               Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</div><div class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</div><div class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</div><div class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</div><div class="line">&quot;YouTube importer&quot;        YouTubeImporter</div><div class="line">                          YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p>
</blockquote>
<h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h3><p>只要是合法的，就把@Override注解给用上。</p>
<h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p>
<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  int i = Integer.parseInt(response);</div><div class="line">  return handleNumericResponse(i);</div><div class="line">&#125; catch (NumberFormatException ok) &#123;</div><div class="line">  // it&apos;s not numeric; that&apos;s fine, just continue</div><div class="line">&#125;</div><div class="line">return handleTextResponse(response);</div></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  emptyStack.pop();</div><div class="line">  fail();</div><div class="line">&#125; catch (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); // good</div><div class="line">aFoo.aStaticMethod(); // bad</div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); // very bad</div></pre></td></tr></table></figure>
<h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重载Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Multiple lines of Javadoc text are written here,</div><div class="line"> * wrapped normally...</div><div class="line"> */</div><div class="line">public int method(String p1) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/** An especially short bit of Javadoc. */</div></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。<br>它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public的<code>class</code>及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>
<h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。</p>
</blockquote>
<h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>
<h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zsr.github.io/2016/07/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
